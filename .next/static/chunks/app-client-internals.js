/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app-client-internals"],{

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/app-router.js */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/layout-router.js */ \"(app-client)/./node_modules/next/dist/client/components/layout-router.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/render-from-template-context.js */ \"(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\", 23));\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/components/error-boundary.js */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\", 23))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGcmFodWwlMkZEb2N1bWVudHMlMkZOZXh0LUlzc3VlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGYXBwLXJvdXRlci5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGcmFodWwlMkZEb2N1bWVudHMlMkZOZXh0LUlzc3VlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGbGF5b3V0LXJvdXRlci5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGcmFodWwlMkZEb2N1bWVudHMlMkZOZXh0LUlzc3VlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcyZtb2R1bGVzPSUyRlVzZXJzJTJGcmFodWwlMkZEb2N1bWVudHMlMkZOZXh0LUlzc3VlJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZjb21wb25lbnRzJTJGZXJyb3ItYm91bmRhcnkuanMmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSx5T0FBNkg7QUFDN0gsK09BQWdJO0FBQ2hJLDZRQUErSTtBQUMvSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2I5NDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmFodWwvRG9jdW1lbnRzL05leHQtSXNzdWUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmFodWwvRG9jdW1lbnRzL05leHQtSXNzdWUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmFodWwvRG9jdW1lbnRzL05leHQtSXNzdWUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzXCIpO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmFodWwvRG9jdW1lbnRzL05leHQtSXNzdWUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qc1wiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/add-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/add-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"(app-client)/./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction addBasePath(path, required) {\n    if (false) {}\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvYWRkLWJhc2UtcGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQkFBbUIsR0FBR0U7QUFDdEIsSUFBSUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyxvSUFBNEM7QUFDekUsSUFBSUMsMEJBQTBCRCxtQkFBT0EsQ0FBQyw0R0FBNEI7QUFDbEUsTUFBTUUsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTTCxZQUFZUSxJQUFJLEVBQUVDLFFBQVEsRUFBRTtJQUNqQyxJQUFJSixLQUEwQyxFQUFFLEVBSS9DO0lBQ0QsT0FBTyxDQUFDLEdBQUdGLHVCQUF1QixFQUFFUSwwQkFBMEIsQ0FBQyxDQUFDLEdBQUdWLGNBQWMsRUFBRVcsYUFBYSxDQUFDSixNQUFNSjtBQUMzRztBQUVBLElBQUksQ0FBQyxPQUFPTixRQUFRZSxPQUFPLEtBQUssY0FBZSxPQUFPZixRQUFRZSxPQUFPLEtBQUssWUFBWWYsUUFBUWUsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPZixRQUFRZSxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRZSxPQUFPLEVBQUUsY0FBYztRQUFFZCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT21CLE1BQU0sQ0FBQ2pCLFFBQVFlLE9BQU8sRUFBRWY7SUFDL0JrQixPQUFPbEIsT0FBTyxHQUFHQSxRQUFRZSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvYWRkLWJhc2UtcGF0aC5qcz82MTMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRCYXNlUGF0aCA9IGFkZEJhc2VQYXRoO1xudmFyIF9hZGRQYXRoUHJlZml4ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeFwiKTtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbmZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGgsIHJlcXVpcmVkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCkge1xuICAgICAgICBpZiAoIXJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoKS5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCgoMCwgX2FkZFBhdGhQcmVmaXgpLmFkZFBhdGhQcmVmaXgocGF0aCwgYmFzZVBhdGgpKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRCYXNlUGF0aCIsIl9hZGRQYXRoUHJlZml4IiwicmVxdWlyZSIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJyZXF1aXJlZCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwiYWRkUGF0aFByZWZpeCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/add-base-path.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/app-router-announcer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-announcer.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AppRouterAnnouncer = AppRouterAnnouncer;\nvar _react = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\nvar _reactDom = __webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/next/dist/compiled/react-dom/index.js\");\nconst ANNOUNCER_TYPE = \"next-route-announcer\";\nconst ANNOUNCER_ID = \"__next-route-announcer__\";\nfunction getAnnouncerNode() {\n    var ref;\n    const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0];\n    if (existingAnnouncer == null ? void 0 : (ref = existingAnnouncer.shadowRoot) == null ? void 0 : ref.childNodes[0]) {\n        return existingAnnouncer.shadowRoot.childNodes[0];\n    } else {\n        const container = document.createElement(ANNOUNCER_TYPE);\n        const announcer = document.createElement(\"div\");\n        announcer.setAttribute(\"aria-live\", \"assertive\");\n        announcer.setAttribute(\"id\", ANNOUNCER_ID);\n        announcer.setAttribute(\"role\", \"alert\");\n        announcer.style.cssText = \"position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal\";\n        // Use shadow DOM here to avoid any potential CSS bleed\n        const shadow = container.attachShadow({\n            mode: \"open\"\n        });\n        shadow.appendChild(announcer);\n        document.body.appendChild(container);\n        return announcer;\n    }\n}\nfunction AppRouterAnnouncer(param) {\n    let { tree  } = param;\n    _s();\n    const [portalNode, setPortalNode] = (0, _react).useState(null);\n    (0, _react).useEffect(()=>{\n        const announcer = getAnnouncerNode();\n        setPortalNode(announcer);\n        return ()=>{\n            const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0];\n            if (container == null ? void 0 : container.isConnected) {\n                document.body.removeChild(container);\n            }\n        };\n    }, []);\n    const [routeAnnouncement, setRouteAnnouncement] = (0, _react).useState(\"\");\n    const previousTitle = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        let currentTitle = \"\";\n        if (document.title) {\n            currentTitle = document.title;\n        } else {\n            const pageHeader = document.querySelector(\"h1\");\n            if (pageHeader) {\n                currentTitle = pageHeader.innerText || pageHeader.textContent || \"\";\n            }\n        }\n        // Only announce the title change, but not for the first load because screen\n        // readers do that automatically.\n        if (typeof previousTitle.current !== \"undefined\") {\n            setRouteAnnouncement(currentTitle);\n        }\n        previousTitle.current = currentTitle;\n    }, [\n        tree\n    ]);\n    return portalNode ? /*#__PURE__*/ (0, _reactDom).createPortal(routeAnnouncement, portalNode) : null;\n}\n_s(AppRouterAnnouncer, \"07+XTu/Cj+sb1TVKwt29I3ov2QY=\");\n_c = AppRouterAnnouncer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-announcer.js.map\nvar _c;\n$RefreshReg$(_c, \"AppRouterAnnouncer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWFubm91bmNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdFO0FBQzdCLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLDRFQUFPO0FBQzVCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLG9GQUFXO0FBQ25DLE1BQU1FLGlCQUFpQjtBQUN2QixNQUFNQyxlQUFlO0FBQ3JCLFNBQVNDLG1CQUFtQjtJQUN4QixJQUFJQztJQUNKLE1BQU1DLG9CQUFvQkMsU0FBU0MsaUJBQWlCLENBQUNOLGVBQWUsQ0FBQyxFQUFFO0lBQ3ZFLElBQUlJLHFCQUFxQixJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUNELE1BQU1DLGtCQUFrQkcsVUFBVSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUlKLElBQUlLLFVBQVUsQ0FBQyxFQUFFLEVBQUU7UUFDaEgsT0FBT0osa0JBQWtCRyxVQUFVLENBQUNDLFVBQVUsQ0FBQyxFQUFFO0lBQ3JELE9BQU87UUFDSCxNQUFNQyxZQUFZSixTQUFTSyxhQUFhLENBQUNWO1FBQ3pDLE1BQU1XLFlBQVlOLFNBQVNLLGFBQWEsQ0FBQztRQUN6Q0MsVUFBVUMsWUFBWSxDQUFDLGFBQWE7UUFDcENELFVBQVVDLFlBQVksQ0FBQyxNQUFNWDtRQUM3QlUsVUFBVUMsWUFBWSxDQUFDLFFBQVE7UUFDL0JELFVBQVVFLEtBQUssQ0FBQ0MsT0FBTyxHQUFHO1FBQzFCLHVEQUF1RDtRQUN2RCxNQUFNQyxTQUFTTixVQUFVTyxZQUFZLENBQUM7WUFDbENDLE1BQU07UUFDVjtRQUNBRixPQUFPRyxXQUFXLENBQUNQO1FBQ25CTixTQUFTYyxJQUFJLENBQUNELFdBQVcsQ0FBQ1Q7UUFDMUIsT0FBT0U7SUFDWCxDQUFDO0FBQ0w7QUFDQSxTQUFTZixtQkFBbUIsS0FBUyxFQUFFO1FBQVgsRUFBRXdCLEtBQUksRUFBRyxHQUFUOztJQUN4QixNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBRyxDQUFDLEdBQUd6QixNQUFNLEVBQUUwQixRQUFRLENBQUMsSUFBSTtJQUM1RCxJQUFHMUIsTUFBTSxFQUFFMkIsU0FBUyxDQUFDLElBQUk7UUFDdEIsTUFBTWIsWUFBWVQ7UUFDbEJvQixjQUFjWDtRQUNkLE9BQU8sSUFBSTtZQUNQLE1BQU1GLFlBQVlKLFNBQVNvQixvQkFBb0IsQ0FBQ3pCLGVBQWUsQ0FBQyxFQUFFO1lBQ2xFLElBQUlTLGFBQWEsSUFBSSxHQUFHLEtBQUssSUFBSUEsVUFBVWlCLFdBQVcsRUFBRTtnQkFDcERyQixTQUFTYyxJQUFJLENBQUNRLFdBQVcsQ0FBQ2xCO1lBQzlCLENBQUM7UUFDTDtJQUNKLEdBQUcsRUFBRTtJQUNMLE1BQU0sQ0FBQ21CLG1CQUFtQkMscUJBQXFCLEdBQUcsQ0FBQyxHQUFHaEMsTUFBTSxFQUFFMEIsUUFBUSxDQUFDO0lBQ3ZFLE1BQU1PLGdCQUFnQixDQUFDLEdBQUdqQyxNQUFNLEVBQUVrQyxNQUFNO0lBQ3ZDLElBQUdsQyxNQUFNLEVBQUUyQixTQUFTLENBQUMsSUFBSTtRQUN0QixJQUFJUSxlQUFlO1FBQ25CLElBQUkzQixTQUFTNEIsS0FBSyxFQUFFO1lBQ2hCRCxlQUFlM0IsU0FBUzRCLEtBQUs7UUFDakMsT0FBTztZQUNILE1BQU1DLGFBQWE3QixTQUFTOEIsYUFBYSxDQUFDO1lBQzFDLElBQUlELFlBQVk7Z0JBQ1pGLGVBQWVFLFdBQVdFLFNBQVMsSUFBSUYsV0FBV0csV0FBVyxJQUFJO1lBQ3JFLENBQUM7UUFDTCxDQUFDO1FBQ0QsNEVBQTRFO1FBQzVFLGlDQUFpQztRQUNqQyxJQUFJLE9BQU9QLGNBQWNRLE9BQU8sS0FBSyxhQUFhO1lBQzlDVCxxQkFBcUJHO1FBQ3pCLENBQUM7UUFDREYsY0FBY1EsT0FBTyxHQUFHTjtJQUM1QixHQUFHO1FBQ0NaO0tBQ0g7SUFDRCxPQUFPQyxhQUEyQixXQUFILEdBQUksSUFBR3RCLFNBQVMsRUFBRXdDLFlBQVksQ0FBQ1gsbUJBQW1CUCxjQUFjLElBQUk7QUFDdkc7R0FsQ1N6QjtLQUFBQTtBQW9DVCxJQUFJLENBQUMsT0FBT0YsUUFBUThDLE9BQU8sS0FBSyxjQUFlLE9BQU85QyxRQUFROEMsT0FBTyxLQUFLLFlBQVk5QyxRQUFROEMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPOUMsUUFBUThDLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktqRCxPQUFPQyxjQUFjLENBQUNDLFFBQVE4QyxPQUFPLEVBQUUsY0FBYztRQUFFN0MsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rRCxNQUFNLENBQUNoRCxRQUFROEMsT0FBTyxFQUFFOUM7SUFDL0JpRCxPQUFPakQsT0FBTyxHQUFHQSxRQUFROEMsT0FBTztBQUNsQyxDQUFDLENBRUQsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvYXBwLXJvdXRlci1hbm5vdW5jZXIuanM/NmUwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQXBwUm91dGVyQW5ub3VuY2VyID0gQXBwUm91dGVyQW5ub3VuY2VyO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVhY3REb20gPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuY29uc3QgQU5OT1VOQ0VSX1RZUEUgPSAnbmV4dC1yb3V0ZS1hbm5vdW5jZXInO1xuY29uc3QgQU5OT1VOQ0VSX0lEID0gJ19fbmV4dC1yb3V0ZS1hbm5vdW5jZXJfXyc7XG5mdW5jdGlvbiBnZXRBbm5vdW5jZXJOb2RlKCkge1xuICAgIHZhciByZWY7XG4gICAgY29uc3QgZXhpc3RpbmdBbm5vdW5jZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShBTk5PVU5DRVJfVFlQRSlbMF07XG4gICAgaWYgKGV4aXN0aW5nQW5ub3VuY2VyID09IG51bGwgPyB2b2lkIDAgOiAocmVmID0gZXhpc3RpbmdBbm5vdW5jZXIuc2hhZG93Um9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ0Fubm91bmNlci5zaGFkb3dSb290LmNoaWxkTm9kZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChBTk5PVU5DRVJfVFlQRSk7XG4gICAgICAgIGNvbnN0IGFubm91bmNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhbm5vdW5jZXIuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgICAgIGFubm91bmNlci5zZXRBdHRyaWJ1dGUoJ2lkJywgQU5OT1VOQ0VSX0lEKTtcbiAgICAgICAgYW5ub3VuY2VyLnNldEF0dHJpYnV0ZSgncm9sZScsICdhbGVydCcpO1xuICAgICAgICBhbm5vdW5jZXIuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDtoZWlnaHQ6MXB4O21hcmdpbjotMXB4O3BhZGRpbmc6MDt3aWR0aDoxcHg7Y2xpcDpyZWN0KDAgMCAwIDApO292ZXJmbG93OmhpZGRlbjt3aGl0ZS1zcGFjZTpub3dyYXA7d29yZC13cmFwOm5vcm1hbCc7XG4gICAgICAgIC8vIFVzZSBzaGFkb3cgRE9NIGhlcmUgdG8gYXZvaWQgYW55IHBvdGVudGlhbCBDU1MgYmxlZWRcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gY29udGFpbmVyLmF0dGFjaFNoYWRvdyh7XG4gICAgICAgICAgICBtb2RlOiAnb3BlbidcbiAgICAgICAgfSk7XG4gICAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChhbm5vdW5jZXIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBhbm5vdW5jZXI7XG4gICAgfVxufVxuZnVuY3Rpb24gQXBwUm91dGVyQW5ub3VuY2VyKHsgdHJlZSAgfSkge1xuICAgIGNvbnN0IFtwb3J0YWxOb2RlLCBzZXRQb3J0YWxOb2RlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKG51bGwpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBjb25zdCBhbm5vdW5jZXIgPSBnZXRBbm5vdW5jZXJOb2RlKCk7XG4gICAgICAgIHNldFBvcnRhbE5vZGUoYW5ub3VuY2VyKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShBTk5PVU5DRVJfVFlQRSlbMF07XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXIuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IFtyb3V0ZUFubm91bmNlbWVudCwgc2V0Um91dGVBbm5vdW5jZW1lbnRdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUoJycpO1xuICAgIGNvbnN0IHByZXZpb3VzVGl0bGUgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgbGV0IGN1cnJlbnRUaXRsZSA9ICcnO1xuICAgICAgICBpZiAoZG9jdW1lbnQudGl0bGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUaXRsZSA9IGRvY3VtZW50LnRpdGxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFnZUhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gxJyk7XG4gICAgICAgICAgICBpZiAocGFnZUhlYWRlcikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUaXRsZSA9IHBhZ2VIZWFkZXIuaW5uZXJUZXh0IHx8IHBhZ2VIZWFkZXIudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhbm5vdW5jZSB0aGUgdGl0bGUgY2hhbmdlLCBidXQgbm90IGZvciB0aGUgZmlyc3QgbG9hZCBiZWNhdXNlIHNjcmVlblxuICAgICAgICAvLyByZWFkZXJzIGRvIHRoYXQgYXV0b21hdGljYWxseS5cbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1RpdGxlLmN1cnJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRSb3V0ZUFubm91bmNlbWVudChjdXJyZW50VGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzVGl0bGUuY3VycmVudCA9IGN1cnJlbnRUaXRsZTtcbiAgICB9LCBbXG4gICAgICAgIHRyZWVcbiAgICBdKTtcbiAgICByZXR1cm4gcG9ydGFsTm9kZSA/IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdERvbSkuY3JlYXRlUG9ydGFsKHJvdXRlQW5ub3VuY2VtZW50LCBwb3J0YWxOb2RlKSA6IG51bGw7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZXItYW5ub3VuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFwcFJvdXRlckFubm91bmNlciIsIl9yZWFjdCIsInJlcXVpcmUiLCJfcmVhY3REb20iLCJBTk5PVU5DRVJfVFlQRSIsIkFOTk9VTkNFUl9JRCIsImdldEFubm91bmNlck5vZGUiLCJyZWYiLCJleGlzdGluZ0Fubm91bmNlciIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJzaGFkb3dSb290IiwiY2hpbGROb2RlcyIsImNvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJhbm5vdW5jZXIiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsImNzc1RleHQiLCJzaGFkb3ciLCJhdHRhY2hTaGFkb3ciLCJtb2RlIiwiYXBwZW5kQ2hpbGQiLCJib2R5IiwidHJlZSIsInBvcnRhbE5vZGUiLCJzZXRQb3J0YWxOb2RlIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImlzQ29ubmVjdGVkIiwicmVtb3ZlQ2hpbGQiLCJyb3V0ZUFubm91bmNlbWVudCIsInNldFJvdXRlQW5ub3VuY2VtZW50IiwicHJldmlvdXNUaXRsZSIsInVzZVJlZiIsImN1cnJlbnRUaXRsZSIsInRpdGxlIiwicGFnZUhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJpbm5lclRleHQiLCJ0ZXh0Q29udGVudCIsImN1cnJlbnQiLCJjcmVhdGVQb3J0YWwiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/app-router-announcer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/app-router-headers.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router-headers.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FLIGHT_PARAMETERS = exports.RSC_VARY_HEADER = exports.RSC_CONTENT_TYPE_HEADER = exports.FETCH_CACHE_HEADER = exports.NEXT_ROUTER_PREFETCH = exports.NEXT_ROUTER_STATE_TREE = exports.ACTION = exports.RSC = void 0;\nconst RSC = \"RSC\";\nexports.RSC = RSC;\nconst ACTION = \"Next-Action\";\nexports.ACTION = ACTION;\nconst NEXT_ROUTER_STATE_TREE = \"Next-Router-State-Tree\";\nexports.NEXT_ROUTER_STATE_TREE = NEXT_ROUTER_STATE_TREE;\nconst NEXT_ROUTER_PREFETCH = \"Next-Router-Prefetch\";\nexports.NEXT_ROUTER_PREFETCH = NEXT_ROUTER_PREFETCH;\nconst FETCH_CACHE_HEADER = \"x-vercel-sc-headers\";\nexports.FETCH_CACHE_HEADER = FETCH_CACHE_HEADER;\nconst RSC_CONTENT_TYPE_HEADER = \"text/x-component\";\nexports.RSC_CONTENT_TYPE_HEADER = RSC_CONTENT_TYPE_HEADER;\nconst RSC_VARY_HEADER = \"\".concat(RSC, \", \").concat(NEXT_ROUTER_STATE_TREE, \", \").concat(NEXT_ROUTER_PREFETCH);\nexports.RSC_VARY_HEADER = RSC_VARY_HEADER;\nconst FLIGHT_PARAMETERS = [\n    [\n        RSC\n    ],\n    [\n        NEXT_ROUTER_STATE_TREE\n    ],\n    [\n        NEXT_ROUTER_PREFETCH\n    ]\n];\nexports.FLIGHT_PARAMETERS = FLIGHT_PARAMETERS;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router-headers.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLWhlYWRlcnMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUdBLHVCQUF1QixHQUFHQSwrQkFBK0IsR0FBR0EsMEJBQTBCLEdBQUdBLDRCQUE0QixHQUFHQSw4QkFBOEIsR0FBR0EsY0FBYyxHQUFHQSxXQUFXLEdBQUcsS0FBSztBQUN6TixNQUFNUyxNQUFNO0FBQ1pULFdBQVcsR0FBR1M7QUFDZCxNQUFNRCxTQUFTO0FBQ2ZSLGNBQWMsR0FBR1E7QUFDakIsTUFBTUQseUJBQXlCO0FBQy9CUCw4QkFBOEIsR0FBR087QUFDakMsTUFBTUQsdUJBQXVCO0FBQzdCTiw0QkFBNEIsR0FBR007QUFDL0IsTUFBTUQscUJBQXFCO0FBQzNCTCwwQkFBMEIsR0FBR0s7QUFDN0IsTUFBTUQsMEJBQTBCO0FBQ2hDSiwrQkFBK0IsR0FBR0k7QUFDbEMsTUFBTUQsa0JBQWtCLEdBQVdJLE9BQVJFLEtBQUksTUFBK0JILE9BQTNCQyx3QkFBdUIsTUFBeUIsT0FBckJEO0FBQzlETix1QkFBdUIsR0FBR0c7QUFDMUIsTUFBTUQsb0JBQW9CO0lBQ3RCO1FBQ0lPO0tBQ0g7SUFDRDtRQUNJRjtLQUNIO0lBQ0Q7UUFDSUQ7S0FDSDtDQUNKO0FBQ0ROLHlCQUF5QixHQUFHRTtBQUU1QixJQUFJLENBQUMsT0FBT0YsUUFBUVUsT0FBTyxLQUFLLGNBQWUsT0FBT1YsUUFBUVUsT0FBTyxLQUFLLFlBQVlWLFFBQVFVLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1YsUUFBUVUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRVSxPQUFPLEVBQUUsY0FBYztRQUFFVCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2MsTUFBTSxDQUFDWixRQUFRVSxPQUFPLEVBQUVWO0lBQy9CYSxPQUFPYixPQUFPLEdBQUdBLFFBQVFVLE9BQU87QUFDbEMsQ0FBQyxDQUVELDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXItaGVhZGVycy5qcz8zNTZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5GTElHSFRfUEFSQU1FVEVSUyA9IGV4cG9ydHMuUlNDX1ZBUllfSEVBREVSID0gZXhwb3J0cy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9IGV4cG9ydHMuRkVUQ0hfQ0FDSEVfSEVBREVSID0gZXhwb3J0cy5ORVhUX1JPVVRFUl9QUkVGRVRDSCA9IGV4cG9ydHMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9IGV4cG9ydHMuQUNUSU9OID0gZXhwb3J0cy5SU0MgPSB2b2lkIDA7XG5jb25zdCBSU0MgPSAnUlNDJztcbmV4cG9ydHMuUlNDID0gUlNDO1xuY29uc3QgQUNUSU9OID0gJ05leHQtQWN0aW9uJztcbmV4cG9ydHMuQUNUSU9OID0gQUNUSU9OO1xuY29uc3QgTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9ICdOZXh0LVJvdXRlci1TdGF0ZS1UcmVlJztcbmV4cG9ydHMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRSA9IE5FWFRfUk9VVEVSX1NUQVRFX1RSRUU7XG5jb25zdCBORVhUX1JPVVRFUl9QUkVGRVRDSCA9ICdOZXh0LVJvdXRlci1QcmVmZXRjaCc7XG5leHBvcnRzLk5FWFRfUk9VVEVSX1BSRUZFVENIID0gTkVYVF9ST1VURVJfUFJFRkVUQ0g7XG5jb25zdCBGRVRDSF9DQUNIRV9IRUFERVIgPSAneC12ZXJjZWwtc2MtaGVhZGVycyc7XG5leHBvcnRzLkZFVENIX0NBQ0hFX0hFQURFUiA9IEZFVENIX0NBQ0hFX0hFQURFUjtcbmNvbnN0IFJTQ19DT05URU5UX1RZUEVfSEVBREVSID0gJ3RleHQveC1jb21wb25lbnQnO1xuZXhwb3J0cy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUiA9IFJTQ19DT05URU5UX1RZUEVfSEVBREVSO1xuY29uc3QgUlNDX1ZBUllfSEVBREVSID0gYCR7UlNDfSwgJHtORVhUX1JPVVRFUl9TVEFURV9UUkVFfSwgJHtORVhUX1JPVVRFUl9QUkVGRVRDSH1gO1xuZXhwb3J0cy5SU0NfVkFSWV9IRUFERVIgPSBSU0NfVkFSWV9IRUFERVI7XG5jb25zdCBGTElHSFRfUEFSQU1FVEVSUyA9IFtcbiAgICBbXG4gICAgICAgIFJTQ1xuICAgIF0sXG4gICAgW1xuICAgICAgICBORVhUX1JPVVRFUl9TVEFURV9UUkVFXG4gICAgXSxcbiAgICBbXG4gICAgICAgIE5FWFRfUk9VVEVSX1BSRUZFVENIXG4gICAgXSwgXG5dO1xuZXhwb3J0cy5GTElHSFRfUEFSQU1FVEVSUyA9IEZMSUdIVF9QQVJBTUVURVJTO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLWhlYWRlcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiRkxJR0hUX1BBUkFNRVRFUlMiLCJSU0NfVkFSWV9IRUFERVIiLCJSU0NfQ09OVEVOVF9UWVBFX0hFQURFUiIsIkZFVENIX0NBQ0hFX0hFQURFUiIsIk5FWFRfUk9VVEVSX1BSRUZFVENIIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIkFDVElPTiIsIlJTQyIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/app-router-headers.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/app-router.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/app-router.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = AppRouter;\nexports.urlToUrlWithoutFlightMarker = urlToUrlWithoutFlightMarker;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _routerReducer = __webpack_require__(/*! ./router-reducer/router-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\");\nvar _routerReducerTypes = __webpack_require__(/*! ./router-reducer/router-reducer-types */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ./router-reducer/create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../../shared/lib/hooks-client-context */ \"(app-client)/./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nvar _useReducerWithDevtools = __webpack_require__(/*! ./use-reducer-with-devtools */ \"(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\");\nvar _createInitialRouterState = __webpack_require__(/*! ./router-reducer/create-initial-router-state */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\");\nvar _fetchServerResponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _isBot = __webpack_require__(/*! ../../shared/lib/router/utils/is-bot */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _addBasePath = __webpack_require__(/*! ../add-base-path */ \"(app-client)/./node_modules/next/dist/client/add-base-path.js\");\nvar _appRouterAnnouncer = __webpack_require__(/*! ./app-router-announcer */ \"(app-client)/./node_modules/next/dist/client/components/app-router-announcer.js\");\nfunction AppRouter(props) {\n    const { globalErrorComponent  } = props, rest = _object_without_properties_loose(props, [\n        \"globalErrorComponent\"\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n        errorComponent: globalErrorComponent\n    }, /*#__PURE__*/ _react.default.createElement(Router, Object.assign({}, rest)));\n}\n_c = AppRouter;\nconst isServer = \"object\" === \"undefined\";\n// Ensure the initialParallelRoutes are not combined because of double-rendering in the browser with Strict Mode.\nlet initialParallelRoutes = isServer ? null : new Map();\nfunction urlToUrlWithoutFlightMarker(url) {\n    const urlWithoutFlightParameters = new URL(url, location.origin);\n    // TODO-APP: handle .rsc for static export case\n    return urlWithoutFlightParameters;\n}\nconst HotReloader =  false ? 0 : (__webpack_require__(/*! ./react-dev-overlay/hot-reloader-client */ \"(app-client)/./node_modules/next/dist/client/components/react-dev-overlay/hot-reloader-client.js\")[\"default\"]);\nconst prefetched = new Set();\nfunction isExternalURL(url) {\n    return url.origin !== window.location.origin;\n}\n/**\n * The global router that wraps the application components.\n */ function Router(param) {\n    let { initialHead , initialTree , initialCanonicalUrl , children , assetPrefix  } = param;\n    _s();\n    const initialState = (0, _react).useMemo(()=>(0, _createInitialRouterState).createInitialRouterState({\n            children,\n            initialCanonicalUrl,\n            initialTree,\n            initialParallelRoutes,\n            isServer,\n            location: !isServer ? window.location : null,\n            initialHead\n        }), [\n        children,\n        initialCanonicalUrl,\n        initialTree,\n        initialHead\n    ]);\n    const [{ tree , cache , prefetchCache , pushRef , focusAndScrollRef , canonicalUrl  }, dispatch, sync] = (0, _useReducerWithDevtools).useReducerWithReduxDevtools(_routerReducer.reducer, initialState);\n    (0, _react).useEffect(()=>{\n        // Ensure initialParallelRoutes is cleaned up from memory once it's used.\n        initialParallelRoutes = null;\n    }, []);\n    // Add memoized pathname/query for useSearchParams and usePathname.\n    const { searchParams , pathname  } = (0, _react).useMemo(()=>{\n        const url = new URL(canonicalUrl,  false ? 0 : window.location.href);\n        return {\n            // This is turned into a readonly class in `useSearchParams`\n            searchParams: url.searchParams,\n            pathname: url.pathname\n        };\n    }, [\n        canonicalUrl\n    ]);\n    /**\n   * Server response that only patches the cache and tree.\n   */ const changeByServerResponse = (0, _react).useCallback((previousTree, flightData, overrideCanonicalUrl)=>{\n        dispatch({\n            type: _routerReducerTypes.ACTION_SERVER_PATCH,\n            flightData,\n            previousTree,\n            overrideCanonicalUrl,\n            cache: {\n                status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                data: null,\n                subTreeData: null,\n                parallelRoutes: new Map()\n            },\n            mutable: {}\n        });\n    }, [\n        dispatch\n    ]);\n    /**\n   * The app router that is exposed through `useRouter`. It's only concerned with dispatching actions to the reducer, does not hold state.\n   */ const appRouter = (0, _react).useMemo(()=>{\n        const navigate = (href, navigateType, forceOptimisticNavigation)=>{\n            const url = new URL((0, _addBasePath).addBasePath(href), location.origin);\n            return dispatch({\n                type: _routerReducerTypes.ACTION_NAVIGATE,\n                url,\n                isExternalUrl: isExternalURL(url),\n                locationSearch: location.search,\n                forceOptimisticNavigation,\n                navigateType,\n                cache: {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map()\n                },\n                mutable: {}\n            });\n        };\n        const routerInstance = {\n            back: ()=>window.history.back(),\n            forward: ()=>window.history.forward(),\n            prefetch: _async_to_generator(function*(href) {\n                const hrefWithBasePath = (0, _addBasePath).addBasePath(href);\n                // If prefetch has already been triggered, don't trigger it again.\n                if (prefetched.has(hrefWithBasePath) ||  true && (0, _isBot).isBot(window.navigator.userAgent)) {\n                    return;\n                }\n                prefetched.add(hrefWithBasePath);\n                const url = new URL(hrefWithBasePath, location.origin);\n                // External urls can't be prefetched in the same way.\n                if (isExternalURL(url)) {\n                    return;\n                }\n                try {\n                    var ref;\n                    const routerTree = ((ref = window.history.state) == null ? void 0 : ref.tree) || initialTree;\n                    const serverResponse = yield (0, _fetchServerResponse).fetchServerResponse(url, routerTree, true);\n                    // @ts-ignore startTransition exists\n                    _react.default.startTransition(()=>{\n                        dispatch({\n                            type: _routerReducerTypes.ACTION_PREFETCH,\n                            url,\n                            tree: routerTree,\n                            serverResponse\n                        });\n                    });\n                } catch (err) {\n                    console.error(\"PREFETCH ERROR\", err);\n                }\n            }),\n            replace: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"replace\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            push: function(href) {\n                let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    navigate(href, \"push\", Boolean(options.forceOptimisticNavigation));\n                });\n            },\n            refresh: ()=>{\n                // @ts-ignore startTransition exists\n                _react.default.startTransition(()=>{\n                    dispatch({\n                        type: _routerReducerTypes.ACTION_REFRESH,\n                        cache: {\n                            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                            data: null,\n                            subTreeData: null,\n                            parallelRoutes: new Map()\n                        },\n                        mutable: {},\n                        origin: window.location.origin\n                    });\n                });\n            }\n        };\n        return routerInstance;\n    }, [\n        dispatch,\n        initialTree\n    ]);\n    (0, _react).useEffect(()=>{\n        // When mpaNavigation flag is set do a hard navigation to the new url.\n        if (pushRef.mpaNavigation) {\n            const location1 = window.location;\n            if (pushRef.pendingPush) {\n                location1.assign(canonicalUrl);\n            } else {\n                location1.replace(canonicalUrl);\n            }\n            return;\n        }\n        // Identifier is shortened intentionally.\n        // __NA is used to identify if the history entry can be handled by the app-router.\n        // __N is used to identify if the history entry can be handled by the old router.\n        const historyState = {\n            __NA: true,\n            tree\n        };\n        if (pushRef.pendingPush && (0, _createHrefFromUrl).createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl) {\n            // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n            pushRef.pendingPush = false;\n            window.history.pushState(historyState, \"\", canonicalUrl);\n        } else {\n            window.history.replaceState(historyState, \"\", canonicalUrl);\n        }\n        sync();\n    }, [\n        tree,\n        pushRef,\n        canonicalUrl,\n        sync\n    ]);\n    // Add `window.nd` for debugging purposes.\n    // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n    if (true) {\n        // @ts-ignore this is for debugging\n        window.nd = {\n            router: appRouter,\n            cache,\n            prefetchCache,\n            tree\n        };\n    }\n    /**\n   * Handle popstate event, this is used to handle back/forward in the browser.\n   * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n   * That case can happen when the old router injected the history entry.\n   */ const onPopState = (0, _react).useCallback((param)=>{\n        let { state  } = param;\n        if (!state) {\n            // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n            return;\n        }\n        // This case happens when the history entry was pushed by the `pages` router.\n        if (!state.__NA) {\n            window.location.reload();\n            return;\n        }\n        // @ts-ignore useTransition exists\n        // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n        // Without startTransition works if the cache is there for this path\n        _react.default.startTransition(()=>{\n            dispatch({\n                type: _routerReducerTypes.ACTION_RESTORE,\n                url: new URL(window.location.href),\n                tree: state.tree\n            });\n        });\n    }, [\n        dispatch\n    ]);\n    // Register popstate event to call onPopstate.\n    (0, _react).useEffect(()=>{\n        window.addEventListener(\"popstate\", onPopState);\n        return ()=>{\n            window.removeEventListener(\"popstate\", onPopState);\n        };\n    }, [\n        onPopState\n    ]);\n    const content = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, cache.subTreeData, /*#__PURE__*/ _react.default.createElement(_appRouterAnnouncer.AppRouterAnnouncer, {\n        tree: tree\n    }));\n    return /*#__PURE__*/ _react.default.createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: pathname\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: searchParams\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.GlobalLayoutRouterContext.Provider, {\n        value: {\n            changeByServerResponse,\n            tree,\n            focusAndScrollRef\n        }\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: appRouter\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            childNodes: cache.parallelRoutes,\n            tree: tree,\n            // Root node always has `url`\n            // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n            url: canonicalUrl,\n            headRenderedAboveThisLevel: false\n        }\n    }, HotReloader ? /*#__PURE__*/ _react.default.createElement(HotReloader, {\n        assetPrefix: assetPrefix\n    }, content) : content)))));\n}\n_s(Router, \"yWCtvIH/OEoTmoHU249b5/prOjk=\");\n_c1 = Router;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=app-router.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"AppRouter\");\n$RefreshReg$(_c1, \"Router\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9hcHAtcm91dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQkgsbUNBQW1DLEdBQUdJO0FBQ3RDLElBQUlDLHNCQUFzQkMsc0pBQTBEO0FBQ3BGLElBQUlDLDRCQUE0QkQsa0tBQWdFO0FBQ2hHLElBQUlFLG1DQUFtQ0YsZ0xBQXVFO0FBQzlHLElBQUlHLFNBQVNGLDBCQUEwQkQsbUJBQU9BLENBQUMsNEVBQU87QUFDdEQsSUFBSUksb0JBQW9CSixtQkFBT0EsQ0FBQyxtSEFBcUM7QUFDckUsSUFBSUssaUJBQWlCTCxtQkFBT0EsQ0FBQyxpSUFBaUM7QUFDOUQsSUFBSU0sc0JBQXNCTixtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDekUsSUFBSU8scUJBQXFCUCxtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDeEUsSUFBSVEsc0JBQXNCUixtQkFBT0EsQ0FBQyx1SEFBdUM7QUFDekUsSUFBSVMsMEJBQTBCVCxtQkFBT0EsQ0FBQyx5SEFBNkI7QUFDbkUsSUFBSVUsaUJBQWlCVixtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDL0MsSUFBSVcsNEJBQTRCWCxtQkFBT0EsQ0FBQywySkFBOEM7QUFDdEYsSUFBSVksdUJBQXVCWixtQkFBT0EsQ0FBQywrSUFBd0M7QUFDM0UsSUFBSWEsU0FBU2IsbUJBQU9BLENBQUMscUhBQXNDO0FBQzNELElBQUljLGVBQWVkLG1CQUFPQSxDQUFDLHVGQUFrQjtBQUM3QyxJQUFJZSxzQkFBc0JmLG1CQUFPQSxDQUFDLCtHQUF3QjtBQUMxRCxTQUFTSCxVQUFVbUIsS0FBSyxFQUFFO0lBQ3RCLE1BQU0sRUFBRUMscUJBQW9CLEVBQUcsR0FBR0QsT0FBT0UsT0FBT2hCLGlDQUFpQ2MsT0FBTztRQUNwRjtLQUNIO0lBQ0QsT0FBTyxXQUFX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QVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2FwcC1yb3V0ZXIuanM/NDE1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwUm91dGVyO1xuZXhwb3J0cy51cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIgPSB1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXI7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX3JvdXRlclJlZHVjZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlclwiKTtcbnZhciBfcm91dGVyUmVkdWNlclR5cGVzID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvcm91dGVyLXJlZHVjZXItdHlwZXNcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG52YXIgX2hvb2tzQ2xpZW50Q29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0XCIpO1xudmFyIF91c2VSZWR1Y2VyV2l0aERldnRvb2xzID0gcmVxdWlyZShcIi4vdXNlLXJlZHVjZXItd2l0aC1kZXZ0b29sc1wiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9jcmVhdGVJbml0aWFsUm91dGVyU3RhdGUgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGVcIik7XG52YXIgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2VcIik7XG52YXIgX2lzQm90ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdFwiKTtcbnZhciBfYWRkQmFzZVBhdGggPSByZXF1aXJlKFwiLi4vYWRkLWJhc2UtcGF0aFwiKTtcbnZhciBfYXBwUm91dGVyQW5ub3VuY2VyID0gcmVxdWlyZShcIi4vYXBwLXJvdXRlci1hbm5vdW5jZXJcIik7XG5mdW5jdGlvbiBBcHBSb3V0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IGdsb2JhbEVycm9yQ29tcG9uZW50ICB9ID0gcHJvcHMsIHJlc3QgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShwcm9wcywgW1xuICAgICAgICBcImdsb2JhbEVycm9yQ29tcG9uZW50XCJcbiAgICBdKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgZXJyb3JDb21wb25lbnQ6IGdsb2JhbEVycm9yQ29tcG9uZW50XG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCkpKTtcbn1cblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbi8vIEVuc3VyZSB0aGUgaW5pdGlhbFBhcmFsbGVsUm91dGVzIGFyZSBub3QgY29tYmluZWQgYmVjYXVzZSBvZiBkb3VibGUtcmVuZGVyaW5nIGluIHRoZSBicm93c2VyIHdpdGggU3RyaWN0IE1vZGUuXG5sZXQgaW5pdGlhbFBhcmFsbGVsUm91dGVzID0gaXNTZXJ2ZXIgPyBudWxsIDogbmV3IE1hcCgpO1xuZnVuY3Rpb24gdXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyKHVybCkge1xuICAgIGNvbnN0IHVybFdpdGhvdXRGbGlnaHRQYXJhbWV0ZXJzID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbik7XG4gICAgLy8gVE9ETy1BUFA6IGhhbmRsZSAucnNjIGZvciBzdGF0aWMgZXhwb3J0IGNhc2VcbiAgICByZXR1cm4gdXJsV2l0aG91dEZsaWdodFBhcmFtZXRlcnM7XG59XG5jb25zdCBIb3RSZWxvYWRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyBudWxsIDogcmVxdWlyZSgnLi9yZWFjdC1kZXYtb3ZlcmxheS9ob3QtcmVsb2FkZXItY2xpZW50JykuZGVmYXVsdDtcbmNvbnN0IHByZWZldGNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBpc0V4dGVybmFsVVJMKHVybCkge1xuICAgIHJldHVybiB1cmwub3JpZ2luICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xufVxuLyoqXG4gKiBUaGUgZ2xvYmFsIHJvdXRlciB0aGF0IHdyYXBzIHRoZSBhcHBsaWNhdGlvbiBjb21wb25lbnRzLlxuICovIGZ1bmN0aW9uIFJvdXRlcih7IGluaXRpYWxIZWFkICwgaW5pdGlhbFRyZWUgLCBpbml0aWFsQ2Fub25pY2FsVXJsICwgY2hpbGRyZW4gLCBhc3NldFByZWZpeCAgfSkge1xuICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PigwLCBfY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlKS5jcmVhdGVJbml0aWFsUm91dGVyU3RhdGUoe1xuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBpbml0aWFsQ2Fub25pY2FsVXJsLFxuICAgICAgICAgICAgaW5pdGlhbFRyZWUsXG4gICAgICAgICAgICBpbml0aWFsUGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICBpc1NlcnZlcixcbiAgICAgICAgICAgIGxvY2F0aW9uOiAhaXNTZXJ2ZXIgPyB3aW5kb3cubG9jYXRpb24gOiBudWxsLFxuICAgICAgICAgICAgaW5pdGlhbEhlYWRcbiAgICAgICAgfSksIFtcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIGluaXRpYWxDYW5vbmljYWxVcmwsXG4gICAgICAgIGluaXRpYWxUcmVlLFxuICAgICAgICBpbml0aWFsSGVhZFxuICAgIF0pO1xuICAgIGNvbnN0IFt7IHRyZWUgLCBjYWNoZSAsIHByZWZldGNoQ2FjaGUgLCBwdXNoUmVmICwgZm9jdXNBbmRTY3JvbGxSZWYgLCBjYW5vbmljYWxVcmwgIH0sIGRpc3BhdGNoLCBzeW5jLCBdID0gKDAsIF91c2VSZWR1Y2VyV2l0aERldnRvb2xzKS51c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHMoX3JvdXRlclJlZHVjZXIucmVkdWNlciwgaW5pdGlhbFN0YXRlKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgLy8gRW5zdXJlIGluaXRpYWxQYXJhbGxlbFJvdXRlcyBpcyBjbGVhbmVkIHVwIGZyb20gbWVtb3J5IG9uY2UgaXQncyB1c2VkLlxuICAgICAgICBpbml0aWFsUGFyYWxsZWxSb3V0ZXMgPSBudWxsO1xuICAgIH0sIFtdKTtcbiAgICAvLyBBZGQgbWVtb2l6ZWQgcGF0aG5hbWUvcXVlcnkgZm9yIHVzZVNlYXJjaFBhcmFtcyBhbmQgdXNlUGF0aG5hbWUuXG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgLCBwYXRobmFtZSAgfSA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChjYW5vbmljYWxVcmwsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdHVybmVkIGludG8gYSByZWFkb25seSBjbGFzcyBpbiBgdXNlU2VhcmNoUGFyYW1zYFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZVxuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY2Fub25pY2FsVXJsXG4gICAgXSk7XG4gICAgLyoqXG4gICAqIFNlcnZlciByZXNwb25zZSB0aGF0IG9ubHkgcGF0Y2hlcyB0aGUgY2FjaGUgYW5kIHRyZWUuXG4gICAqLyBjb25zdCBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKHByZXZpb3VzVHJlZSwgZmxpZ2h0RGF0YSwgb3ZlcnJpZGVDYW5vbmljYWxVcmwpPT57XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1NFUlZFUl9QQVRDSCxcbiAgICAgICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWUsXG4gICAgICAgICAgICBvdmVycmlkZUNhbm9uaWNhbFVybCxcbiAgICAgICAgICAgIGNhY2hlOiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG11dGFibGU6IHt9XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgZGlzcGF0Y2hcbiAgICBdKTtcbiAgICAvKipcbiAgICogVGhlIGFwcCByb3V0ZXIgdGhhdCBpcyBleHBvc2VkIHRocm91Z2ggYHVzZVJvdXRlcmAuIEl0J3Mgb25seSBjb25jZXJuZWQgd2l0aCBkaXNwYXRjaGluZyBhY3Rpb25zIHRvIHRoZSByZWR1Y2VyLCBkb2VzIG5vdCBob2xkIHN0YXRlLlxuICAgKi8gY29uc3QgYXBwUm91dGVyID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBuYXZpZ2F0ZSA9IChocmVmLCBuYXZpZ2F0ZVR5cGUsIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pPT57XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKCgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKGhyZWYpLCBsb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9OQVZJR0FURSxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgaXNFeHRlcm5hbFVybDogaXNFeHRlcm5hbFVSTCh1cmwpLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uU2VhcmNoOiBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgICAgICAgICAgZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0ZVR5cGUsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVELFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbXV0YWJsZToge31cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByb3V0ZXJJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGJhY2s6ICgpPT53aW5kb3cuaGlzdG9yeS5iYWNrKCksXG4gICAgICAgICAgICBmb3J3YXJkOiAoKT0+d2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpLFxuICAgICAgICAgICAgcHJlZmV0Y2g6IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKGhyZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmV2l0aEJhc2VQYXRoID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoaHJlZik7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJlZmV0Y2ggaGFzIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQsIGRvbid0IHRyaWdnZXIgaXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgaWYgKHByZWZldGNoZWQuaGFzKGhyZWZXaXRoQmFzZVBhdGgpIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgwLCBfaXNCb3QpLmlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZWZldGNoZWQuYWRkKGhyZWZXaXRoQmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZldpdGhCYXNlUGF0aCwgbG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgICAgICAvLyBFeHRlcm5hbCB1cmxzIGNhbid0IGJlIHByZWZldGNoZWQgaW4gdGhlIHNhbWUgd2F5LlxuICAgICAgICAgICAgICAgIGlmIChpc0V4dGVybmFsVVJMKHVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZXJUcmVlID0gKChyZWYgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50cmVlKSB8fCBpbml0aWFsVHJlZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUmVzcG9uc2UgPSB5aWVsZCAoMCwgX2ZldGNoU2VydmVyUmVzcG9uc2UpLmZldGNoU2VydmVyUmVzcG9uc2UodXJsLCAvLyBpbml0aWFsVHJlZSBpcyB1c2VkIHdoZW4gaGlzdG9yeS5zdGF0ZS50cmVlIGlzIG1pc3NpbmcgYmVjYXVzZSB0aGUgaGlzdG9yeSBzdGF0ZSBpcyBzZXQgaW4gYHVzZUVmZmVjdGAgYmVsb3csIGl0IGJlaW5nIG1pc3NpbmcgbWVhbnMgdGhpcyBpcyB0aGUgaHlkcmF0aW9uIGNhc2UuXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlclRyZWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fUFJFRkVUQ0gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyZWU6IHJvdXRlclRyZWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUFJFRkVUQ0ggRVJST1InLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVwbGFjZTogKGhyZWYsIG9wdGlvbnMgPSB7fSk9PntcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHN0YXJ0VHJhbnNpdGlvbiBleGlzdHNcbiAgICAgICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGUoaHJlZiwgJ3JlcGxhY2UnLCBCb29sZWFuKG9wdGlvbnMuZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHB1c2g6IChocmVmLCBvcHRpb25zID0ge30pPT57XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlKGhyZWYsICdwdXNoJywgQm9vbGVhbihvcHRpb25zLmZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZyZXNoOiAoKT0+e1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgc3RhcnRUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfcm91dGVyUmVkdWNlclR5cGVzLkFDVElPTl9SRUZSRVNILFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YWJsZToge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW5cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByb3V0ZXJJbnN0YW5jZTtcbiAgICB9LCBbXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBpbml0aWFsVHJlZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBXaGVuIG1wYU5hdmlnYXRpb24gZmxhZyBpcyBzZXQgZG8gYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIG5ldyB1cmwuXG4gICAgICAgIGlmIChwdXNoUmVmLm1wYU5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICAgICAgaWYgKHB1c2hSZWYucGVuZGluZ1B1c2gpIHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5hc3NpZ24oY2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb24ucmVwbGFjZShjYW5vbmljYWxVcmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElkZW50aWZpZXIgaXMgc2hvcnRlbmVkIGludGVudGlvbmFsbHkuXG4gICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgLy8gX19OIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIG9sZCByb3V0ZXIuXG4gICAgICAgIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHtcbiAgICAgICAgICAgIF9fTkE6IHRydWUsXG4gICAgICAgICAgICB0cmVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwdXNoUmVmLnBlbmRpbmdQdXNoICYmICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpKSAhPT0gY2Fub25pY2FsVXJsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGludGVudGlvbmFsbHkgbXV0YXRlcyBSZWFjdCBzdGF0ZSwgcHVzaFJlZiBpcyBvdmVyd3JpdHRlbiB0byBlbnN1cmUgYWRkaXRpb25hbCBwdXNoL3JlcGxhY2UgY2FsbHMgZG8gbm90IHRyaWdnZXIgYW4gYWRkaXRpb25hbCBoaXN0b3J5IGVudHJ5LlxuICAgICAgICAgICAgcHVzaFJlZi5wZW5kaW5nUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIGNhbm9uaWNhbFVybCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgY2Fub25pY2FsVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBzeW5jKCk7XG4gICAgfSwgW1xuICAgICAgICB0cmVlLFxuICAgICAgICBwdXNoUmVmLFxuICAgICAgICBjYW5vbmljYWxVcmwsXG4gICAgICAgIHN5bmNcbiAgICBdKTtcbiAgICAvLyBBZGQgYHdpbmRvdy5uZGAgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAgICAvLyBUaGlzIGlzIG5vdCBtZWFudCBmb3IgdXNlIGluIGFwcGxpY2F0aW9ucyBhcyBjb25jdXJyZW50IHJlbmRlcmluZyB3aWxsIGFmZmVjdCB0aGUgY2FjaGUvdHJlZS9yb3V0ZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHdpbmRvdy5uZCA9IHtcbiAgICAgICAgICAgIHJvdXRlcjogYXBwUm91dGVyLFxuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBwcmVmZXRjaENhY2hlLFxuICAgICAgICAgICAgdHJlZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICogSGFuZGxlIHBvcHN0YXRlIGV2ZW50LCB0aGlzIGlzIHVzZWQgdG8gaGFuZGxlIGJhY2svZm9yd2FyZCBpbiB0aGUgYnJvd3Nlci5cbiAgICogQnkgZGVmYXVsdCBkaXNwYXRjaGVzIEFDVElPTl9SRVNUT1JFLCBob3dldmVyIGlmIHRoZSBoaXN0b3J5IGVudHJ5IHdhcyBub3QgcHVzaGVkL3JlcGxhY2VkIGJ5IGFwcC1yb3V0ZXIgaXQgd2lsbCByZWxvYWQgdGhlIHBhZ2UuXG4gICAqIFRoYXQgY2FzZSBjYW4gaGFwcGVuIHdoZW4gdGhlIG9sZCByb3V0ZXIgaW5qZWN0ZWQgdGhlIGhpc3RvcnkgZW50cnkuXG4gICAqLyBjb25zdCBvblBvcFN0YXRlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKHsgc3RhdGUgIH0pPT57XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiB0aGlzIGNhc2Ugb25seSBoYXBwZW5zIHdoZW4gcHVzaFN0YXRlL3JlcGxhY2VTdGF0ZSB3YXMgY2FsbGVkIG91dHNpZGUgb2YgTmV4dC5qcy4gSXQgc2hvdWxkIHByb2JhYmx5IHJlbG9hZCB0aGUgcGFnZSBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgaGlzdG9yeSBlbnRyeSB3YXMgcHVzaGVkIGJ5IHRoZSBgcGFnZXNgIHJvdXRlci5cbiAgICAgICAgaWYgKCFzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZSB1c2VUcmFuc2l0aW9uIGV4aXN0c1xuICAgICAgICAvLyBUT0RPLUFQUDogSWRlYWxseSB0aGUgYmFjayBidXR0b24gc2hvdWxkIG5vdCB1c2Ugc3RhcnRUcmFuc2l0aW9uIGFzIGl0IHNob3VsZCBhcHBseSB0aGUgdXBkYXRlcyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIFdpdGhvdXQgc3RhcnRUcmFuc2l0aW9uIHdvcmtzIGlmIHRoZSBjYWNoZSBpcyB0aGVyZSBmb3IgdGhpcyBwYXRoXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1JFU1RPUkUsXG4gICAgICAgICAgICAgICAgdXJsOiBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSxcbiAgICAgICAgICAgICAgICB0cmVlOiBzdGF0ZS50cmVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBkaXNwYXRjaFxuICAgIF0pO1xuICAgIC8vIFJlZ2lzdGVyIHBvcHN0YXRlIGV2ZW50IHRvIGNhbGwgb25Qb3BzdGF0ZS5cbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgb25Qb3BTdGF0ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBvblBvcFN0YXRlXG4gICAgXSk7XG4gICAgY29uc3QgY29udGVudCA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2FjaGUuc3ViVHJlZURhdGEsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQW5ub3VuY2VyLkFwcFJvdXRlckFubm91bmNlciwge1xuICAgICAgICB0cmVlOiB0cmVlXG4gICAgfSkpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hvb2tzQ2xpZW50Q29udGV4dC5QYXRobmFtZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHBhdGhuYW1lXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9ob29rc0NsaWVudENvbnRleHQuU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogc2VhcmNoUGFyYW1zXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0Lkdsb2JhbExheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UsXG4gICAgICAgICAgICB0cmVlLFxuICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWZcbiAgICAgICAgfVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfYXBwUm91dGVyQ29udGV4dC5BcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBhcHBSb3V0ZXJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuTGF5b3V0Um91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgY2hpbGROb2RlczogY2FjaGUucGFyYWxsZWxSb3V0ZXMsXG4gICAgICAgICAgICB0cmVlOiB0cmVlLFxuICAgICAgICAgICAgLy8gUm9vdCBub2RlIGFsd2F5cyBoYXMgYHVybGBcbiAgICAgICAgICAgIC8vIFByb3ZpZGVkIGluIEFwcFRyZWVDb250ZXh0IHRvIGVuc3VyZSBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gaW4gbGF5b3V0LXJvdXRlclxuICAgICAgICAgICAgdXJsOiBjYW5vbmljYWxVcmwsXG4gICAgICAgICAgICBoZWFkUmVuZGVyZWRBYm92ZVRoaXNMZXZlbDogZmFsc2VcbiAgICAgICAgfVxuICAgIH0sIEhvdFJlbG9hZGVyID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhvdFJlbG9hZGVyLCB7XG4gICAgICAgIGFzc2V0UHJlZml4OiBhc3NldFByZWZpeFxuICAgIH0sIGNvbnRlbnQpIDogY29udGVudCkpKSkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJBcHBSb3V0ZXIiLCJ1cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZSIsIl9yZWFjdCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX3JvdXRlclJlZHVjZXIiLCJfcm91dGVyUmVkdWNlclR5cGVzIiwiX2NyZWF0ZUhyZWZGcm9tVXJsIiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsIl91c2VSZWR1Y2VyV2l0aERldnRvb2xzIiwiX2Vycm9yQm91bmRhcnkiLCJfY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJfaXNCb3QiLCJfYWRkQmFzZVBhdGgiLCJfYXBwUm91dGVyQW5ub3VuY2VyIiwicHJvcHMiLCJnbG9iYWxFcnJvckNvbXBvbmVudCIsInJlc3QiLCJjcmVhdGVFbGVtZW50IiwiRXJyb3JCb3VuZGFyeSIsImVycm9yQ29tcG9uZW50IiwiUm91dGVyIiwiYXNzaWduIiwiaXNTZXJ2ZXIiLCJpbml0aWFsUGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJ1cmwiLCJ1cmxXaXRob3V0RmxpZ2h0UGFyYW1ldGVycyIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiSG90UmVsb2FkZXIiLCJwcm9jZXNzIiwicHJlZmV0Y2hlZCIsIlNldCIsImlzRXh0ZXJuYWxVUkwiLCJ3aW5kb3ciLCJpbml0aWFsSGVhZCIsImluaXRpYWxUcmVlIiwiaW5pdGlhbENhbm9uaWNhbFVybCIsImNoaWxkcmVuIiwiYXNzZXRQcmVmaXgiLCJpbml0aWFsU3RhdGUiLCJ1c2VNZW1vIiwiY3JlYXRlSW5pdGlhbFJvdXRlclN0YXRlIiwidHJlZSIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImNhbm9uaWNhbFVybCIsImRpc3BhdGNoIiwic3luYyIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsInJlZHVjZXIiLCJ1c2VFZmZlY3QiLCJzZWFyY2hQYXJhbXMiLCJwYXRobmFtZSIsImhyZWYiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwidXNlQ2FsbGJhY2siLCJwcmV2aW91c1RyZWUiLCJmbGlnaHREYXRhIiwib3ZlcnJpZGVDYW5vbmljYWxVcmwiLCJ0eXBlIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInBhcmFsbGVsUm91dGVzIiwibXV0YWJsZSIsImFwcFJvdXRlciIsIm5hdmlnYXRlIiwibmF2aWdhdGVUeXBlIiwiZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiIsImFkZEJhc2VQYXRoIiwiQUNUSU9OX05BVklHQVRFIiwiaXNFeHRlcm5hbFVybCIsImxvY2F0aW9uU2VhcmNoIiwic2VhcmNoIiwicm91dGVySW5zdGFuY2UiLCJiYWNrIiwiaGlzdG9yeSIsImZvcndhcmQiLCJwcmVmZXRjaCIsImhyZWZXaXRoQmFzZVBhdGgiLCJoYXMiLCJpc0JvdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImFkZCIsInJlZiIsInJvdXRlclRyZWUiLCJzdGF0ZSIsInNlcnZlclJlc3BvbnNlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsInN0YXJ0VHJhbnNpdGlvbiIsIkFDVElPTl9QUkVGRVRDSCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsInJlcGxhY2UiLCJvcHRpb25zIiwiQm9vbGVhbiIsInB1c2giLCJyZWZyZXNoIiwiQUNUSU9OX1JFRlJFU0giLCJtcGFOYXZpZ2F0aW9uIiwicGVuZGluZ1B1c2giLCJoaXN0b3J5U3RhdGUiLCJfX05BIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJwdXNoU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJuZCIsInJvdXRlciIsIm9uUG9wU3RhdGUiLCJyZWxvYWQiLCJBQ1RJT05fUkVTVE9SRSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29udGVudCIsIkZyYWdtZW50IiwiQXBwUm91dGVyQW5ub3VuY2VyIiwiUGF0aG5hbWVDb250ZXh0IiwiUHJvdmlkZXIiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkFwcFJvdXRlckNvbnRleHQiLCJMYXlvdXRSb3V0ZXJDb250ZXh0IiwiY2hpbGROb2RlcyIsImhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsIiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/app-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/error-boundary.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/error-boundary.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = GlobalError;\nexports.ErrorBoundary = ErrorBoundary;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nfunction GlobalError(param) {\n    let { error  } = param;\n    return /*#__PURE__*/ _react.default.createElement(\"html\", null, /*#__PURE__*/ _react.default.createElement(\"head\", null), /*#__PURE__*/ _react.default.createElement(\"body\", null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.error\n    }, /*#__PURE__*/ _react.default.createElement(\"div\", {\n        style: styles.desc\n    }, /*#__PURE__*/ _react.default.createElement(\"h2\", {\n        style: styles.text\n    }, \"Application error: a client-side exception has occurred (see the browser console for more information).\"), (error == null ? void 0 : error.digest) && /*#__PURE__*/ _react.default.createElement(\"p\", {\n        style: styles.text\n    }, \"Digest: \".concat(error.digest))))));\n}\n_c = GlobalError;\nconst styles = {\n    error: {\n        // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n        fontFamily: 'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        textAlign: \"left\"\n    },\n    text: {\n        fontSize: \"14px\",\n        fontWeight: 400,\n        lineHeight: \"3em\",\n        margin: 0\n    }\n};\nclass ErrorBoundaryHandler extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    render() {\n        if (this.state.error) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, this.props.errorStyles, /*#__PURE__*/ _react.default.createElement(this.props.errorComponent, {\n                error: this.state.error,\n                reset: this.reset\n            }));\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.reset = ()=>{\n            this.setState({\n                error: null\n            });\n        };\n        this.state = {\n            error: null\n        };\n    }\n}\nexports.ErrorBoundaryHandler = ErrorBoundaryHandler;\nfunction ErrorBoundary(param) {\n    let { errorComponent , errorStyles , children  } = param;\n    if (errorComponent) {\n        return /*#__PURE__*/ _react.default.createElement(ErrorBoundaryHandler, {\n            errorComponent: errorComponent,\n            errorStyles: errorStyles\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c1 = ErrorBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=error-boundary.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"GlobalError\");\n$RefreshReg$(_c1, \"ErrorBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQkgscUJBQXFCLEdBQUdJO0FBQ3hCLElBQUlDLDJCQUEyQkMsZ0tBQStEO0FBQzlGLElBQUlDLFNBQVNGLHlCQUF5QkMsbUJBQU9BLENBQUMsNEVBQU87QUFDckQsU0FBU0gsWUFBWSxLQUFVLEVBQUU7UUFBWixFQUFFSyxNQUFLLEVBQUcsR0FBVjtJQUNqQixPQUFPLFdBQVcsR0FBR0QsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsUUFBUSxJQUFJLEVBQUUsV0FBVyxHQUFHRixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxRQUFRLElBQUksR0FBRyxXQUFXLEdBQUdGLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLFFBQVEsSUFBSSxFQUFFLFdBQVcsR0FBR0YsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsT0FBTztRQUNqT0MsT0FBT0MsT0FBT0gsS0FBSztJQUN2QixHQUFHLFdBQVcsR0FBR0QsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsT0FBTztRQUNqREMsT0FBT0MsT0FBT0MsSUFBSTtJQUN0QixHQUFHLFdBQVcsR0FBR0wsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUMsTUFBTTtRQUNoREMsT0FBT0MsT0FBT0UsSUFBSTtJQUN0QixHQUFHLDRHQUE0RyxDQUFDTCxTQUFTLElBQUksR0FBRyxLQUFLLElBQUlBLE1BQU1NLE1BQU0sS0FBSyxXQUFXLEdBQUdQLE9BQU9MLE9BQU8sQ0FBQ08sYUFBYSxDQUFDLEtBQUs7UUFDdE1DLE9BQU9DLE9BQU9FLElBQUk7SUFDdEIsR0FBRyxXQUF3QixPQUFiTCxNQUFNTSxNQUFNO0FBQzlCO0tBVlNYO0FBWVQsTUFBTVEsU0FBUztJQUNYSCxPQUFPO1FBQ0gsMEZBQTBGO1FBQzFGTyxZQUFZO1FBQ1pDLFFBQVE7UUFDUkMsV0FBVztRQUNYQyxTQUFTO1FBQ1RDLGVBQWU7UUFDZkMsWUFBWTtRQUNaQyxnQkFBZ0I7SUFDcEI7SUFDQVQsTUFBTTtRQUNGSyxXQUFXO0lBQ2Y7SUFDQUosTUFBTTtRQUNGUyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxRQUFRO0lBQ1o7QUFDSjtBQUNBLE1BQU1DLDZCQUE2Qm5CLE9BQU9MLE9BQU8sQ0FBQ3lCLFNBQVM7SUFDdkQsT0FBT0MseUJBQXlCcEIsS0FBSyxFQUFFO1FBQ25DLE9BQU87WUFDSEE7UUFDSjtJQUNKO0lBQ0FxQixTQUFTO1FBQ0wsSUFBSSxJQUFJLENBQUNDLEtBQUssQ0FBQ3RCLEtBQUssRUFBRTtZQUNsQixPQUFPLFdBQVcsR0FBR0QsT0FBT0wsT0FBTyxDQUFDTyxhQUFhLENBQUNGLE9BQU9MLE9BQU8sQ0FBQzZCLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDQyxLQUFLLENBQUNDLFdBQVcsRUFBRSxXQUFXLEdBQUcxQixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQyxJQUFJLENBQUN1QixLQUFLLENBQUNFLGNBQWMsRUFBRTtnQkFDM0sxQixPQUFPLElBQUksQ0FBQ3NCLEtBQUssQ0FBQ3RCLEtBQUs7Z0JBQ3ZCMkIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDckI7UUFDSixDQUFDO1FBQ0QsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksUUFBUTtJQUM5QjtJQUNBQyxZQUFZTCxLQUFLLENBQUM7UUFDZCxLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDRyxLQUFLLEdBQUcsSUFBSTtZQUNiLElBQUksQ0FBQ0csUUFBUSxDQUFDO2dCQUNWOUIsT0FBTyxJQUFJO1lBQ2Y7UUFDSjtRQUNBLElBQUksQ0FBQ3NCLEtBQUssR0FBRztZQUNUdEIsT0FBTyxJQUFJO1FBQ2Y7SUFDSjtBQUNKO0FBQ0FSLDRCQUE0QixHQUFHMEI7QUFDL0IsU0FBU3RCLGNBQWMsS0FBNEMsRUFBRTtRQUE5QyxFQUFFOEIsZUFBYyxFQUFHRCxZQUFXLEVBQUdHLFNBQVEsRUFBRyxHQUE1QztJQUNuQixJQUFJRixnQkFBZ0I7UUFDaEIsT0FBTyxXQUFXLEdBQUczQixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQ2lCLHNCQUFzQjtZQUNwRVEsZ0JBQWdCQTtZQUNoQkQsYUFBYUE7UUFDakIsR0FBR0c7SUFDUCxDQUFDO0lBQ0QsT0FBTyxXQUFXLEdBQUc3QixPQUFPTCxPQUFPLENBQUNPLGFBQWEsQ0FBQ0YsT0FBT0wsT0FBTyxDQUFDNkIsUUFBUSxFQUFFLElBQUksRUFBRUs7QUFDckY7TUFSU2hDO0FBVVQsSUFBSSxDQUFDLE9BQU9KLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ3FDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLekMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzBDLE1BQU0sQ0FBQ3hDLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0J5QyxPQUFPekMsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9lcnJvci1ib3VuZGFyeS5qcz83Njk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHbG9iYWxFcnJvcjtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBHbG9iYWxFcnJvcih7IGVycm9yICB9KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsKSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiYm9keVwiLCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLmVycm9yXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy5kZXNjXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwge1xuICAgICAgICBzdHlsZTogc3R5bGVzLnRleHRcbiAgICB9LCBcIkFwcGxpY2F0aW9uIGVycm9yOiBhIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQgKHNlZSB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBtb3JlIGluZm9ybWF0aW9uKS5cIiksIChlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IuZGlnZXN0KSAmJiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IHN0eWxlcy50ZXh0XG4gICAgfSwgYERpZ2VzdDogJHtlcnJvci5kaWdlc3R9YCkpKSkpO1xufVxuXG5jb25zdCBzdHlsZXMgPSB7XG4gICAgZXJyb3I6IHtcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9tb2Rlcm4tbm9ybWFsaXplL2Jsb2IvbWFpbi9tb2Rlcm4tbm9ybWFsaXplLmNzcyNMMzgtTDUyXG4gICAgICAgIGZvbnRGYW1pbHk6ICdzeXN0ZW0tdWksXCJTZWdvZSBVSVwiLFJvYm90byxIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIHRleHRBbGlnbjogJ2xlZnQnXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDQwMCxcbiAgICAgICAgbGluZUhlaWdodDogJzNlbScsXG4gICAgICAgIG1hcmdpbjogMFxuICAgIH1cbn07XG5jbGFzcyBFcnJvckJvdW5kYXJ5SGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgdGhpcy5wcm9wcy5lcnJvclN0eWxlcywgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuZXJyb3JDb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5zdGF0ZS5lcnJvcixcbiAgICAgICAgICAgICAgICByZXNldDogdGhpcy5yZXNldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9ICgpPT57XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRXJyb3JCb3VuZGFyeUhhbmRsZXIgPSBFcnJvckJvdW5kYXJ5SGFuZGxlcjtcbmZ1bmN0aW9uIEVycm9yQm91bmRhcnkoeyBlcnJvckNvbXBvbmVudCAsIGVycm9yU3R5bGVzICwgY2hpbGRyZW4gIH0pIHtcbiAgICBpZiAoZXJyb3JDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5SGFuZGxlciwge1xuICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yQ29tcG9uZW50LFxuICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzXG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci1ib3VuZGFyeS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiR2xvYmFsRXJyb3IiLCJFcnJvckJvdW5kYXJ5IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsImVycm9yIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwic3R5bGVzIiwiZGVzYyIsInRleHQiLCJkaWdlc3QiLCJmb250RmFtaWx5IiwiaGVpZ2h0IiwidGV4dEFsaWduIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0IiwibWFyZ2luIiwiRXJyb3JCb3VuZGFyeUhhbmRsZXIiLCJDb21wb25lbnQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJyZW5kZXIiLCJzdGF0ZSIsIkZyYWdtZW50IiwicHJvcHMiLCJlcnJvclN0eWxlcyIsImVycm9yQ29tcG9uZW50IiwicmVzZXQiLCJjaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwic2V0U3RhdGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/error-boundary.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/infinite-promise.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/infinite-promise.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInfinitePromise = createInfinitePromise;\n/**\n * Used to cache in createInfinitePromise\n */ let infinitePromise;\nfunction createInfinitePromise() {\n    if (!infinitePromise) {\n        // Only create the Promise once\n        infinitePromise = new Promise(()=>{\n        // This is used to debug when the rendering is never updated.\n        // setTimeout(() => {\n        //   infinitePromise = new Error('Infinite promise')\n        //   resolve()\n        // }, 5000)\n        });\n    }\n    return infinitePromise;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=infinite-promise.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9pbmZpbml0ZS1wcm9taXNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDZCQUE2QixHQUFHRTtBQUNoQzs7Q0FFQyxHQUFHLElBQUlDO0FBQ1IsU0FBU0Qsd0JBQXdCO0lBQzdCLElBQUksQ0FBQ0MsaUJBQWlCO1FBQ2xCLCtCQUErQjtRQUMvQkEsa0JBQWtCLElBQUlDLFFBQVEsSUFBSTtRQUNsQyw2REFBNkQ7UUFDN0QscUJBQXFCO1FBQ3JCLG9EQUFvRDtRQUNwRCxjQUFjO1FBQ2QsV0FBVztRQUNYO0lBQ0osQ0FBQztJQUNELE9BQU9EO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT0gsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1MsTUFBTSxDQUFDUCxRQUFRSyxPQUFPLEVBQUVMO0lBQy9CUSxPQUFPUixPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2luZmluaXRlLXByb21pc2UuanM/NzJmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlSW5maW5pdGVQcm9taXNlID0gY3JlYXRlSW5maW5pdGVQcm9taXNlO1xuLyoqXG4gKiBVc2VkIHRvIGNhY2hlIGluIGNyZWF0ZUluZmluaXRlUHJvbWlzZVxuICovIGxldCBpbmZpbml0ZVByb21pc2U7XG5mdW5jdGlvbiBjcmVhdGVJbmZpbml0ZVByb21pc2UoKSB7XG4gICAgaWYgKCFpbmZpbml0ZVByb21pc2UpIHtcbiAgICAgICAgLy8gT25seSBjcmVhdGUgdGhlIFByb21pc2Ugb25jZVxuICAgICAgICBpbmZpbml0ZVByb21pc2UgPSBuZXcgUHJvbWlzZSgoKT0+e1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gZGVidWcgd2hlbiB0aGUgcmVuZGVyaW5nIGlzIG5ldmVyIHVwZGF0ZWQuXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyAgIGluZmluaXRlUHJvbWlzZSA9IG5ldyBFcnJvcignSW5maW5pdGUgcHJvbWlzZScpXG4gICAgICAgIC8vICAgcmVzb2x2ZSgpXG4gICAgICAgIC8vIH0sIDUwMDApXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5maW5pdGVQcm9taXNlO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZpbml0ZS1wcm9taXNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUluZmluaXRlUHJvbWlzZSIsImluZmluaXRlUHJvbWlzZSIsIlByb21pc2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/infinite-promise.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = OuterLayoutRouter;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"(app-client)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _fetchServerResponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _infinitePromise = __webpack_require__(/*! ./infinite-promise */ \"(app-client)/./node_modules/next/dist/client/components/infinite-promise.js\");\nvar _errorBoundary = __webpack_require__(/*! ./error-boundary */ \"(app-client)/./node_modules/next/dist/client/components/error-boundary.js\");\nvar _matchSegments = __webpack_require__(/*! ./match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\nvar _navigation = __webpack_require__(/*! ./navigation */ \"(app-client)/./node_modules/next/dist/client/components/navigation.js\");\nvar _handleSmoothScroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nvar _redirect = __webpack_require__(/*! ./redirect */ \"(app-client)/./node_modules/next/dist/client/components/redirect.js\");\nvar _findHeadInCache = __webpack_require__(/*! ./router-reducer/reducers/find-head-in-cache */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\");\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey , segmentPath , childProp , error , errorStyles , templateStyles , loading , loadingStyles , hasLoading , template , notFound , notFoundStyles , asNotFound  } = param;\n    _s();\n    const context = (0, _react).useContext(_appRouterContext.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes , tree , url , headRenderedAboveThisLevel  } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodes.set(parallelRouterKey, new Map());\n        childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    const childPropSegment = Array.isArray(childProp.segment) ? childProp.segment[1] : childProp.segment;\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegment = Array.isArray(treeSegment) ? treeSegment[1] : treeSegment;\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        currentChildSegment\n    ];\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, preservedSegments.map((preservedSegment)=>{\n        return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ _react.default.createElement(_appRouterContext.TemplateContext.Provider, {\n            key: preservedSegment,\n            value: /*#__PURE__*/ _react.default.createElement(_errorBoundary.ErrorBoundary, {\n                errorComponent: error,\n                errorStyles: errorStyles\n            }, /*#__PURE__*/ _react.default.createElement(LoadingBoundary, {\n                hasLoading: hasLoading,\n                loading: loading,\n                loadingStyles: loadingStyles\n            }, /*#__PURE__*/ _react.default.createElement(NotFoundBoundary, {\n                notFound: notFound,\n                notFoundStyles: notFoundStyles,\n                asNotFound: asNotFound\n            }, /*#__PURE__*/ _react.default.createElement(RedirectBoundary, null, /*#__PURE__*/ _react.default.createElement(InnerLayoutRouter, {\n                parallelRouterKey: parallelRouterKey,\n                url: url,\n                tree: tree,\n                childNodes: childNodesForParallelRouter,\n                childProp: childPropSegment === preservedSegment ? childProp : null,\n                segmentPath: segmentPath,\n                path: preservedSegment,\n                isActive: currentChildSegment === preservedSegment,\n                headRenderedAboveThisLevel: headRenderedAboveThisLevel\n            })))))\n        }, /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, templateStyles, template)));\n    }));\n}\n_s(OuterLayoutRouter, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n_c = OuterLayoutRouter;\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchSegments).matchSegment(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        _extends({}, treeToRecreate[1], {\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        })\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    _extends({}, treeToRecreate[1], {\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    })\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactDom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactDom.default.findDOMNode(instance);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var ref;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (ref = document.getElementById(hashFragment)) != null ? ref : document.getElementsByName(hashFragment)[0];\n}\nclass ScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef  } = this.props;\n            if (focusAndScrollRef.apply) {\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOMNode this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof HTMLElement)) {\n                    return;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                (0, _handleSmoothScroll).handleSmoothScroll(()=>{\n                    // In case of hash scroll we need to scroll to the top of the element\n                    if (hashFragment) {\n                        window.scrollTo(0, domNode.offsetTop);\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true\n                });\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey , url , childNodes , childProp , segmentPath , tree , // isActive,\n    path , headRenderedAboveThisLevel  } = param;\n    _s1();\n    const context = (0, _react).useContext(_appRouterContext.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { changeByServerResponse , tree: fullTree , focusAndScrollRef  } = context;\n    const head = (0, _react).useMemo(()=>{\n        if (headRenderedAboveThisLevel) {\n            return null;\n        }\n        return (0, _findHeadInCache).findHeadInCache(childNodes, tree[1]);\n    }, [\n        childNodes,\n        tree,\n        headRenderedAboveThisLevel\n    ]);\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(path);\n    // If childProp is available this means it's the Flight / SSR case.\n    if (childProp && // TODO-APP: verify if this can be null based on user code\n    childProp.current !== null) {\n        if (childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.status = _appRouterContext.CacheStates.READY;\n            // @ts-expect-error TODO-APP: handle changing of the type\n            childNode.subTreeData = childProp.current;\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n        } else {\n            // Add the segment's subTreeData to the cache.\n            // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n            childNodes.set(path, {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: childProp.current,\n                parallelRoutes: new Map()\n            });\n            // Mutates the prop in order to clean up the memory associated with the subTreeData as it is now part of the cache.\n            childProp.current = null;\n            // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n            childNode = childNodes.get(path);\n        }\n    }\n    // When childNode is not available during rendering client-side we need to fetch it from the server.\n    if (!childNode || childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED) {\n        /**\n     * Router state with refetch marker added\n     */ // TODO-APP: remove ''\n        const refetchTree = walkAddRefetch([\n            \"\",\n            ...segmentPath\n        ], fullTree);\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNodes.set(path, {\n            status: _appRouterContext.CacheStates.DATA_FETCH,\n            data: (0, _fetchServerResponse).fetchServerResponse(new URL(url, location.origin), refetchTree),\n            subTreeData: null,\n            head: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.head : undefined,\n            parallelRoutes: childNode && childNode.status === _appRouterContext.CacheStates.LAZY_INITIALIZED ? childNode.parallelRoutes : new Map()\n        });\n        // In the above case childNode was set on childNodes, so we have to get it from the cacheNodes again.\n        childNode = childNodes.get(path);\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (!childNode) {\n        throw new Error(\"Child node should always exist\");\n    }\n    // This case should never happen so it throws an error. It indicates there's a bug in the Next.js.\n    if (childNode.subTreeData && childNode.data) {\n        throw new Error(\"Child node should not have both subTreeData and data\");\n    }\n    // If cache node has a data request we have to unwrap response by `use` and update the cache.\n    if (childNode.data) {\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react).use(childNode.data);\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            window.location.href = url;\n            return null;\n        }\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.data = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            // @ts-ignore startTransition exists\n            _react.default.startTransition(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    // If cache node has no subTreeData and no data request we have to infinitely suspend as the data will likely flow in from another place.\n    // TODO-APP: double check users can't return null in a component that will kick in here.\n    if (!childNode.subTreeData) {\n        (0, _react).use((0, _infinitePromise).createInfinitePromise());\n    }\n    const subtree = /*#__PURE__*/ _react.default.createElement(_appRouterContext.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url,\n            headRenderedAboveThisLevel: true\n        }\n    }, head, childNode.subTreeData);\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return /*#__PURE__*/ _react.default.createElement(ScrollAndFocusHandler, {\n        focusAndScrollRef: focusAndScrollRef\n    }, subtree);\n}\n_s1(InnerLayoutRouter, \"OpwolAQA00OlgIeJ6o1Jogk7JPE=\");\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children , loading , loadingStyles , hasLoading  } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ _react.default.createElement(_react.default.Suspense, {\n            fallback: /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, loadingStyles, loading)\n        }, children);\n    }\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c2 = LoadingBoundary;\nfunction HandleRedirect(param) {\n    let { redirect  } = param;\n    _s2();\n    const router = (0, _navigation).useRouter();\n    (0, _react).useEffect(()=>{\n        router.replace(redirect, {});\n    }, [\n        redirect,\n        router\n    ]);\n    return null;\n}\n_s2(HandleRedirect, \"vQduR7x+OPXj6PSmJyFnf+hU7bg=\");\n_c3 = HandleRedirect;\nclass RedirectErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((0, _redirect).isRedirectError(error)) {\n            const url = (0, _redirect).getURLFromRedirectError(error);\n            return {\n                redirect: url\n            };\n        }\n        // Re-throw if error is not for redirect\n        throw error;\n    }\n    render() {\n        const redirect = this.state.redirect;\n        if (redirect !== null) {\n            return /*#__PURE__*/ _react.default.createElement(HandleRedirect, {\n                redirect: redirect\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            redirect: null\n        };\n    }\n}\nfunction RedirectBoundary(param) {\n    let { children  } = param;\n    _s3();\n    const router = (0, _navigation).useRouter();\n    return /*#__PURE__*/ _react.default.createElement(RedirectErrorBoundary, {\n        router: router\n    }, children);\n}\n_s3(RedirectBoundary, \"fN7XvhJ+p5oE6+Xlo0NJmXpxjC8=\");\n_c4 = RedirectBoundary;\nclass NotFoundErrorBoundary extends _react.default.Component {\n    static getDerivedStateFromError(error) {\n        if ((error == null ? void 0 : error.digest) === \"NEXT_NOT_FOUND\") {\n            return {\n                notFoundTriggered: true\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    render() {\n        if (this.state.notFoundTriggered) {\n            return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"meta\", {\n                name: \"robots\",\n                content: \"noindex\"\n            }), this.props.notFoundStyles, this.props.notFound);\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            notFoundTriggered: !!props.asNotFound\n        };\n    }\n}\nfunction NotFoundBoundary(param) {\n    let { notFound , notFoundStyles , asNotFound , children  } = param;\n    return notFound ? /*#__PURE__*/ _react.default.createElement(NotFoundErrorBoundary, {\n        notFound: notFound,\n        notFoundStyles: notFoundStyles,\n        asNotFound: asNotFound\n    }, children) : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_c5 = NotFoundBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3, _c4, _c5;\n$RefreshReg$(_c, \"OuterLayoutRouter\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"HandleRedirect\");\n$RefreshReg$(_c4, \"RedirectBoundary\");\n$RefreshReg$(_c5, \"NotFoundBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9sYXlvdXQtcm91dGVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQyxXQUFXQyxnSUFBK0M7QUFDOUQsSUFBSUMsMkJBQTJCRCxnS0FBK0Q7QUFDOUYsSUFBSUUsNEJBQTRCRixrS0FBZ0U7QUFDaEcsSUFBSUcsU0FBU0QsMEJBQTBCRixtQkFBT0EsQ0FBQyw0RUFBTztBQUN0RCxJQUFJSSxZQUFZSCx5QkFBeUJELG1CQUFPQSxDQUFDLG9GQUFXO0FBQzVELElBQUlLLG9CQUFvQkwsbUJBQU9BLENBQUMsbUhBQXFDO0FBQ3JFLElBQUlNLHVCQUF1Qk4sbUJBQU9BLENBQUMsK0lBQXdDO0FBQzNFLElBQUlPLG1CQUFtQlAsbUJBQU9BLENBQUMsdUdBQW9CO0FBQ25ELElBQUlRLGlCQUFpQlIsbUJBQU9BLENBQUMsbUdBQWtCO0FBQy9DLElBQUlTLGlCQUFpQlQsbUJBQU9BLENBQUMsbUdBQWtCO0FBQy9DLElBQUlVLGNBQWNWLG1CQUFPQSxDQUFDLDJGQUFjO0FBQ3hDLElBQUlXLHNCQUFzQlgsbUJBQU9BLENBQUMsaUpBQW9EO0FBQ3RGLElBQUlZLFlBQVlaLG1CQUFPQSxDQUFDLHVGQUFZO0FBQ3BDLElBQUlhLG1CQUFtQmIsbUJBQU9BLENBQUMsMkpBQThDO0FBQzdFLFNBQVNGLGtCQUFrQixLQUFrTCxFQUFFO1FBQXBMLEVBQUVnQixrQkFBaUIsRUFBR0MsWUFBVyxFQUFHQyxVQUFTLEVBQUdDLE1BQUssRUFBR0MsWUFBVyxFQUFHQyxlQUFjLEVBQUdDLFFBQU8sRUFBR0MsY0FBYSxFQUFHQyxXQUFVLEVBQUdDLFNBQVEsRUFBR0MsU0FBUSxFQUFHQyxlQUFjLEVBQUdDLFdBQVUsRUFBRyxHQUFsTDs7SUFDdkIsTUFBTUMsVUFB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aEJDLFlBQVlBO0lBQ2hCLEdBQUcyRSxZQUFZLFdBQVcsR0FBR2xHLE9BQU9OLE9BQU8sQ0FBQ2lELGFBQWEsQ0FBQzNDLE9BQU9OLE9BQU8sQ0FBQ2tELFFBQVEsRUFBRSxJQUFJLEVBQUVzRCxTQUFTO0FBQ3RHO01BTlM3QztBQVFULElBQUksQ0FBQyxPQUFPN0QsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDdUssVUFBVSxLQUFLLGFBQWE7SUFDckszSyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPNEssTUFBTSxDQUFDMUssUUFBUUUsT0FBTyxFQUFFRjtJQUMvQjJLLE9BQU8zSyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL2xheW91dC1yb3V0ZXIuanM/MGJmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gT3V0ZXJMYXlvdXRSb3V0ZXI7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbnZhciBfaW5maW5pdGVQcm9taXNlID0gcmVxdWlyZShcIi4vaW5maW5pdGUtcHJvbWlzZVwiKTtcbnZhciBfZXJyb3JCb3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xudmFyIF9tYXRjaFNlZ21lbnRzID0gcmVxdWlyZShcIi4vbWF0Y2gtc2VnbWVudHNcIik7XG52YXIgX25hdmlnYXRpb24gPSByZXF1aXJlKFwiLi9uYXZpZ2F0aW9uXCIpO1xudmFyIF9oYW5kbGVTbW9vdGhTY3JvbGwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG52YXIgX3JlZGlyZWN0ID0gcmVxdWlyZShcIi4vcmVkaXJlY3RcIik7XG52YXIgX2ZpbmRIZWFkSW5DYWNoZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2ZpbmQtaGVhZC1pbi1jYWNoZVwiKTtcbmZ1bmN0aW9uIE91dGVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCBzZWdtZW50UGF0aCAsIGNoaWxkUHJvcCAsIGVycm9yICwgZXJyb3JTdHlsZXMgLCB0ZW1wbGF0ZVN0eWxlcyAsIGxvYWRpbmcgLCBsb2FkaW5nU3R5bGVzICwgaGFzTG9hZGluZyAsIHRlbXBsYXRlICwgbm90Rm91bmQgLCBub3RGb3VuZFN0eWxlcyAsIGFzTm90Rm91bmQgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZXhwZWN0ZWQgbGF5b3V0IHJvdXRlciB0byBiZSBtb3VudGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGROb2RlcyAsIHRyZWUgLCB1cmwgLCBoZWFkUmVuZGVyZWRBYm92ZVRoaXNMZXZlbCAgfSA9IGNvbnRleHQ7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFsbGVsUm91dGVyIGNhY2hlIG5vZGVcbiAgICBsZXQgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIC8vIElmIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZSBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC5cbiAgICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICBpZiAoIWNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcikge1xuICAgICAgICBjaGlsZE5vZGVzLnNldChwYXJhbGxlbFJvdXRlcktleSwgbmV3IE1hcCgpKTtcbiAgICAgICAgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGFjdGl2ZSBzZWdtZW50IGluIHRoZSB0cmVlXG4gICAgLy8gVGhlIHJlYXNvbiBhcnJheXMgYXJlIHVzZWQgaW4gdGhlIGRhdGEgZm9ybWF0IGlzIHRoYXQgdGhlc2UgYXJlIHRyYW5zZmVycmVkIGZyb20gdGhlIHNlcnZlciB0byB0aGUgYnJvd3NlciBzbyBpdCdzIG9wdGltaXplZCB0byBzYXZlIGJ5dGVzLlxuICAgIGNvbnN0IHRyZWVTZWdtZW50ID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV1bMF07XG4gICAgY29uc3QgY2hpbGRQcm9wU2VnbWVudCA9IEFycmF5LmlzQXJyYXkoY2hpbGRQcm9wLnNlZ21lbnQpID8gY2hpbGRQcm9wLnNlZ21lbnRbMV0gOiBjaGlsZFByb3Auc2VnbWVudDtcbiAgICAvLyBJZiBzZWdtZW50IGlzIGFuIGFycmF5IGl0J3MgYSBkeW5hbWljIHJvdXRlIGFuZCB3ZSB3YW50IHRvIHJlYWQgdGhlIGR5bmFtaWMgcm91dGUgdmFsdWUgYXMgdGhlIHNlZ21lbnQgdG8gZ2V0IGZyb20gdGhlIGNhY2hlLlxuICAgIGNvbnN0IGN1cnJlbnRDaGlsZFNlZ21lbnQgPSBBcnJheS5pc0FycmF5KHRyZWVTZWdtZW50KSA/IHRyZWVTZWdtZW50WzFdIDogdHJlZVNlZ21lbnQ7XG4gICAgLyoqXG4gICAqIERlY2lkZXMgd2hpY2ggc2VnbWVudHMgdG8ga2VlcCByZW5kZXJpbmcsIGFsbCBzZWdtZW50cyB0aGF0IGFyZSBub3QgYWN0aXZlIHdpbGwgYmUgd3JhcHBlZCBpbiBgPE9mZnNjcmVlbj5gLlxuICAgKi8gLy8gVE9ETy1BUFA6IEFkZCBoYW5kbGluZyBvZiBgPE9mZnNjcmVlbj5gIHdoZW4gaXQncyBhdmFpbGFibGUuXG4gICAgY29uc3QgcHJlc2VydmVkU2VnbWVudHMgPSBbXG4gICAgICAgIGN1cnJlbnRDaGlsZFNlZ21lbnRcbiAgICBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIHByZXNlcnZlZFNlZ21lbnRzLm1hcCgocHJlc2VydmVkU2VnbWVudCk9PntcbiAgICAgICAgcmV0dXJuKC8qXG4gICAgICAgICAgICAtIEVycm9yIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIGVycm9yIGJvdW5kYXJ5IGlmIGVycm9yIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGVycm9yIHN0YXRlLlxuICAgICAgICAgICAgLSBMb2FkaW5nIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC0gT25seSByZW5kZXJzIHN1c3BlbnNlIGJvdW5kYXJ5IGlmIGxvYWRpbmcgY29tcG9uZW50cyBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLSBSZW5kZXJlZCBmb3IgZWFjaCBzZWdtZW50IHRvIGVuc3VyZSB0aGV5IGhhdmUgdGhlaXIgb3duIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgIC0gUGFzc2VkIHRvIHRoZSByb3V0ZXIgZHVyaW5nIHJlbmRlcmluZyB0byBlbnN1cmUgaXQgY2FuIGJlIGltbWVkaWF0ZWx5IHJlbmRlcmVkIHdoZW4gc3VzcGVuZGluZyBvbiBhIEZsaWdodCBmZXRjaC5cbiAgICAgICAgICAqLyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FwcFJvdXRlckNvbnRleHQuVGVtcGxhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICBrZXk6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICB2YWx1ZTogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9lcnJvckJvdW5kYXJ5LkVycm9yQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICBlcnJvckNvbXBvbmVudDogZXJyb3IsXG4gICAgICAgICAgICAgICAgZXJyb3JTdHlsZXM6IGVycm9yU3R5bGVzXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTG9hZGluZ0JvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgaGFzTG9hZGluZzogaGFzTG9hZGluZyxcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICAgICAgICAgIGxvYWRpbmdTdHlsZXM6IGxvYWRpbmdTdHlsZXNcbiAgICAgICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChOb3RGb3VuZEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmQ6IG5vdEZvdW5kLFxuICAgICAgICAgICAgICAgIG5vdEZvdW5kU3R5bGVzOiBub3RGb3VuZFN0eWxlcyxcbiAgICAgICAgICAgICAgICBhc05vdEZvdW5kOiBhc05vdEZvdW5kXG4gICAgICAgICAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RCb3VuZGFyeSwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KElubmVyTGF5b3V0Um91dGVyLCB7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXJLZXk6IHBhcmFsbGVsUm91dGVyS2V5LFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHRyZWU6IHRyZWUsXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyLFxuICAgICAgICAgICAgICAgIGNoaWxkUHJvcDogY2hpbGRQcm9wU2VnbWVudCA9PT0gcHJlc2VydmVkU2VnbWVudCA/IGNoaWxkUHJvcCA6IG51bGwsXG4gICAgICAgICAgICAgICAgc2VnbWVudFBhdGg6IHNlZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgIHBhdGg6IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmU6IGN1cnJlbnRDaGlsZFNlZ21lbnQgPT09IHByZXNlcnZlZFNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgICAgICAgICB9KSkpKSlcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCB0ZW1wbGF0ZVN0eWxlcywgdGVtcGxhdGUpKSk7XG4gICAgfSkpO1xufVxuXG4vKipcbiAqIEFkZCByZWZldGNoIG1hcmtlciB0byByb3V0ZXIgc3RhdGUgYXQgdGhlIHBvaW50IG9mIHRoZSBjdXJyZW50IGxheW91dCBzZWdtZW50LlxuICogVGhpcyBlbnN1cmVzIHRoZSByZXNwb25zZSByZXR1cm5lZCBpcyBub3QgZnVydGhlciBkb3duIHRoYW4gdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKi8gZnVuY3Rpb24gd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGssIHRyZWVUb1JlY3JlYXRlKSB7XG4gICAgaWYgKHNlZ21lbnRQYXRoVG9XYWxrKSB7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBwYXJhbGxlbFJvdXRlS2V5XSA9IHNlZ21lbnRQYXRoVG9XYWxrO1xuICAgICAgICBjb25zdCBpc0xhc3QgPSBzZWdtZW50UGF0aFRvV2Fsay5sZW5ndGggPT09IDI7XG4gICAgICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudCh0cmVlVG9SZWNyZWF0ZVswXSwgc2VnbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0cmVlVG9SZWNyZWF0ZVsxXS5oYXNPd25Qcm9wZXJ0eShwYXJhbGxlbFJvdXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHdhbGtBZGRSZWZldGNoKHVuZGVmaW5lZCwgdHJlZVRvUmVjcmVhdGVbMV1bcGFyYWxsZWxSb3V0ZUtleV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZVRvUmVjcmVhdGVbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZmV0Y2gnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kcyh7fSwgdHJlZVRvUmVjcmVhdGVbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9KSwgXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG4gICAgLy8gT25seSBhcHBseSBzdHJpY3QgbW9kZSB3YXJuaW5nIHdoZW4gbm90IGluIHByb2R1Y3Rpb25cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gKC4uLm1lc3NhZ2VzKT0+e1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzdHJpY3QgbW9kZSB3YXJuaW5nIGZvciB0aGUgZmluZERvbU5vZGUgY2FsbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZXNbMF0uaW5jbHVkZXMoJ1dhcm5pbmc6ICVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4nKSkge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbnNvbGVFcnJvciguLi5tZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBfcmVhY3REb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IgPSBvcmlnaW5hbENvbnNvbGVFcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3JlYWN0RG9tLmRlZmF1bHQuZmluZERPTU5vZGUoaW5zdGFuY2UpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIGNvcm5lciBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovIGZ1bmN0aW9uIHRvcE9mRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodDtcbn1cbi8qKlxuICogRmluZCB0aGUgRE9NIG5vZGUgZm9yIGEgaGFzaCBmcmFnbWVudC5cbiAqIElmIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS4gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyJ3MgYmVoYXZpb3IuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gKi8gZnVuY3Rpb24gZ2V0SGFzaEZyYWdtZW50RG9tTm9kZShoYXNoRnJhZ21lbnQpIHtcbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBgdG9wYCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuXG4gICAgaWYgKGhhc2hGcmFnbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gICAgfVxuICAgIHZhciByZWY7XG4gICAgLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYW4gaWQsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGVsZW1lbnQgd2l0aCB0aGF0IGlkLlxuICAgIHJldHVybiAocmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaEZyYWdtZW50KSkgIT0gbnVsbCA/IHJlZiA6IC8vIElmIHRoZSBoYXNoIGZyYWdtZW50IGlzIGEgbmFtZSwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoYXQgbmFtZS5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoRnJhZ21lbnQpWzBdO1xufVxuY2xhc3MgU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBCZWNhdXNlIHRoaXMgcHJvcGVydHkgaXMgb3ZlcndyaXR0ZW4gaW4gaGFuZGxlUG90ZW50aWFsU2Nyb2xsIGl0J3MgZmluZSB0byBhbHdheXMgcnVuIGl0IHdoZW4gdHJ1ZSBhcyBpdCdsbCBiZSBzZXQgdG8gZmFsc2UgZm9yIHN1YnNlcXVlbnQgcmVuZGVycy5cbiAgICAgICAgaWYgKHRoaXMucHJvcHMuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCA9ICgpPT57XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2Nyb2xsIGFuZCBmb2N1cywgaXQncyBvbmx5IGFwcGxpZWQgb25jZSBpbiB0aGUgZmlyc3QgdXNlRWZmZWN0IHRoYXQgdHJpZ2dlcnMgdGhhdCBjaGFuZ2VkLlxuICAgICAgICAgICAgY29uc3QgeyBmb2N1c0FuZFNjcm9sbFJlZiAgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAoZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaEZyYWdtZW50ID0gZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYGZpbmRET01Ob2RlYCBpcyB0cmlja3kgYmVjYXVzZSBpdCByZXR1cm5zIGp1c3QgdGhlIGZpcnN0IGNoaWxkIGlmIHRoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscmVhZHkgY2F1c2VkIGEgYnVnIHdoZXJlIHRoZSBmaXJzdCBjaGlsZCB3YXMgYSA8bGluay8+IGluIGhlYWQuXG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NTm9kZSB0aGlzIGxheW91dC1yb3V0ZXIgbGV2ZWwgaXMgc2tpcHBlZC4gSXQnbGwgYmUgaGFuZGxlZCBoaWdoZXItdXAgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgICAgICAgaWYgKCEoZG9tTm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIG11dGF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZvY3VzIGFuZCBzY3JvbGwgaXMgYXBwbGllZCBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAoMCwgX2hhbmRsZVNtb290aFNjcm9sbCkuaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGNhc2Ugb2YgaGFzaCBzY3JvbGwgd2UgbmVlZCB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgZG9tTm9kZS5vZmZzZXRUb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGhlaWdodCBiZWNhdXNlIHJlYWRpbmcgYGNsaWVudEhlaWdodGAgY2F1c2VzIGEgcmVmbG93LFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBodG1sRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50J3MgdG9wIGVkZ2UgaXMgYWxyZWFkeSBpbiB0aGUgdmlld3BvcnQsIGV4aXQgZWFybHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBjYWxsZWQgb24gYDxodG1sLz5gIGVsZW1lbnQgc2Nyb2xscyBob3Jpem9udGFsbHkgb24gY2hyb21lIGFuZCBmaXJlZm94ICh0aGF0IHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gZG9tTm9kZSBpZiBkb21Ob2RlIGlzIG5vdCBpbiB2aWV3cG9ydCB3aGVuIHNjcm9sbGVkIHRvIHRvcCBvZiBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgZm9yY2UgbGF5b3V0IGJ5IHF1ZXJ5aW5nIGRvbU5vZGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgZG9udEZvcmNlTGF5b3V0OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIG9uIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogSW5uZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyByZW5kZXJpbmcgdGhlIHByb3ZpZGVkIHNlZ21lbnQgYmFzZWQgb24gdGhlIGNhY2hlLlxuICovIGZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHsgcGFyYWxsZWxSb3V0ZXJLZXkgLCB1cmwgLCBjaGlsZE5vZGVzICwgY2hpbGRQcm9wICwgc2VnbWVudFBhdGggLCB0cmVlICwgLy8gVE9ETy1BUFA6IGltcGxlbWVudCBgPE9mZnNjcmVlbj5gIHdoZW4gYXZhaWxhYmxlLlxuLy8gaXNBY3RpdmUsXG5wYXRoICwgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWwgIH0pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYXBwUm91dGVyQ29udGV4dC5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlICwgdHJlZTogZnVsbFRyZWUgLCBmb2N1c0FuZFNjcm9sbFJlZiAgfSA9IGNvbnRleHQ7XG4gICAgY29uc3QgaGVhZCA9ICgwLCBfcmVhY3QpLnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIF9maW5kSGVhZEluQ2FjaGUpLmZpbmRIZWFkSW5DYWNoZShjaGlsZE5vZGVzLCB0cmVlWzFdKTtcbiAgICB9LCBbXG4gICAgICAgIGNoaWxkTm9kZXMsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIGhlYWRSZW5kZXJlZEFib3ZlVGhpc0xldmVsXG4gICAgXSk7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIC8vIElmIGNoaWxkUHJvcCBpcyBhdmFpbGFibGUgdGhpcyBtZWFucyBpdCdzIHRoZSBGbGlnaHQgLyBTU1IgY2FzZS5cbiAgICBpZiAoY2hpbGRQcm9wICYmIC8vIFRPRE8tQVBQOiB2ZXJpZnkgaWYgdGhpcyBjYW4gYmUgbnVsbCBiYXNlZCBvbiB1c2VyIGNvZGVcbiAgICBjaGlsZFByb3AuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETy1BUFA6IGhhbmRsZSBjaGFuZ2luZyBvZiB0aGUgdHlwZVxuICAgICAgICAgICAgY2hpbGROb2RlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPLUFQUDogaGFuZGxlIGNoYW5naW5nIG9mIHRoZSB0eXBlXG4gICAgICAgICAgICBjaGlsZE5vZGUuc3ViVHJlZURhdGEgPSBjaGlsZFByb3AuY3VycmVudDtcbiAgICAgICAgICAgIC8vIE11dGF0ZXMgdGhlIHByb3AgaW4gb3JkZXIgdG8gY2xlYW4gdXAgdGhlIG1lbW9yeSBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YlRyZWVEYXRhIGFzIGl0IGlzIG5vdyBwYXJ0IG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNoaWxkUHJvcC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgc2VnbWVudCdzIHN1YlRyZWVEYXRhIHRvIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIC8vIFRoaXMgd3JpdGVzIHRvIHRoZSBjYWNoZSB3aGVuIHRoZXJlIGlzIG5vIGl0ZW0gaW4gdGhlIGNhY2hlIHlldC4gSXQgbmV2ZXIgKm92ZXJ3cml0ZXMqIGV4aXN0aW5nIGNhY2hlIGl0ZW1zIHdoaWNoIGlzIHdoeSBpdCdzIHNhZmUgaW4gY29uY3VycmVudCBtb2RlLlxuICAgICAgICAgICAgY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRQcm9wLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBNdXRhdGVzIHRoZSBwcm9wIGluIG9yZGVyIHRvIGNsZWFuIHVwIHRoZSBtZW1vcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcyBpdCBpcyBub3cgcGFydCBvZiB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjaGlsZFByb3AuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBJbiB0aGUgYWJvdmUgY2FzZSBjaGlsZE5vZGUgd2FzIHNldCBvbiBjaGlsZE5vZGVzLCBzbyB3ZSBoYXZlIHRvIGdldCBpdCBmcm9tIHRoZSBjYWNoZU5vZGVzIGFnYWluLlxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5nZXQocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV2hlbiBjaGlsZE5vZGUgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgc2VydmVyLlxuICAgIGlmICghY2hpbGROb2RlIHx8IGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQpIHtcbiAgICAgICAgLyoqXG4gICAgICogUm91dGVyIHN0YXRlIHdpdGggcmVmZXRjaCBtYXJrZXIgYWRkZWRcbiAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICBjb25zdCByZWZldGNoVHJlZSA9IHdhbGtBZGRSZWZldGNoKFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgLi4uc2VnbWVudFBhdGhcbiAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAvKipcbiAgICAgKiBGbGlnaHQgZGF0YSBmZXRjaCBraWNrZWQgb2ZmIGR1cmluZyByZW5kZXIgYW5kIHB1dCBpbnRvIHRoZSBjYWNoZS5cbiAgICAgKi8gY2hpbGROb2Rlcy5zZXQocGF0aCwge1xuICAgICAgICAgICAgc3RhdHVzOiBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5EQVRBX0ZFVENILFxuICAgICAgICAgICAgZGF0YTogKDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKG5ldyBVUkwodXJsLCBsb2NhdGlvbi5vcmlnaW4pLCByZWZldGNoVHJlZSksXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIGhlYWQ6IGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuc3RhdHVzID09PSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5MQVpZX0lOSVRJQUxJWkVEID8gY2hpbGROb2RlLmhlYWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogY2hpbGROb2RlICYmIGNoaWxkTm9kZS5zdGF0dXMgPT09IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkxBWllfSU5JVElBTElaRUQgPyBjaGlsZE5vZGUucGFyYWxsZWxSb3V0ZXMgOiBuZXcgTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBhYm92ZSBjYXNlIGNoaWxkTm9kZSB3YXMgc2V0IG9uIGNoaWxkTm9kZXMsIHNvIHdlIGhhdmUgdG8gZ2V0IGl0IGZyb20gdGhlIGNhY2hlTm9kZXMgYWdhaW4uXG4gICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KHBhdGgpO1xuICAgIH1cbiAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGhhcHBlbiBzbyBpdCB0aHJvd3MgYW4gZXJyb3IuIEl0IGluZGljYXRlcyB0aGVyZSdzIGEgYnVnIGluIHRoZSBOZXh0LmpzLlxuICAgIGlmICghY2hpbGROb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgbm9kZSBzaG91bGQgYWx3YXlzIGV4aXN0Jyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY2FzZSBzaG91bGQgbmV2ZXIgaGFwcGVuIHNvIGl0IHRocm93cyBhbiBlcnJvci4gSXQgaW5kaWNhdGVzIHRoZXJlJ3MgYSBidWcgaW4gdGhlIE5leHQuanMuXG4gICAgaWYgKGNoaWxkTm9kZS5zdWJUcmVlRGF0YSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoaWxkIG5vZGUgc2hvdWxkIG5vdCBoYXZlIGJvdGggc3ViVHJlZURhdGEgYW5kIGRhdGEnKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgYSBkYXRhIHJlcXVlc3Qgd2UgaGF2ZSB0byB1bndyYXAgcmVzcG9uc2UgYnkgYHVzZWAgYW5kIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCByZXNwb25zZSBkYXRhXG4gICAgICovIC8vIFdoZW4gdGhlIGRhdGEgaGFzIG5vdCByZXNvbHZlZCB5ZXQgYHVzZWAgd2lsbCBzdXNwZW5kIGhlcmUuXG4gICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSAoMCwgX3JlYWN0KS51c2UoY2hpbGROb2RlLmRhdGEpO1xuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIG5hdmlnYXRpbmcgdG8gcGFnZSBpbiBgcGFnZXNgIGZyb20gYGFwcGBcbiAgICAgICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50UGF0aCBmcm9tIHRoZSBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGxheW91dCdzIHNlZ21lbnRQYXRoXG4gICAgICAgIGNoaWxkTm9kZS5kYXRhID0gbnVsbDtcbiAgICAgICAgLy8gc2V0VGltZW91dCBpcyB1c2VkIHRvIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyBpcyBhbiBpbnRlbnRpb25hbCBoYWNrIGFyb3VuZCBSZWFjdC5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBzdGFydFRyYW5zaXRpb24gZXhpc3RzXG4gICAgICAgICAgICBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb24oKCk9PntcbiAgICAgICAgICAgICAgICBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlKGZ1bGxUcmVlLCBmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN1c3BlbmQgaW5maW5pdGVseSBhcyBgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZWAgd2lsbCBjYXVzZSBhIGRpZmZlcmVudCBwYXJ0IG9mIHRoZSB0cmVlIHRvIGJlIHJlbmRlcmVkLlxuICAgICAgICAoMCwgX3JlYWN0KS51c2UoKDAsIF9pbmZpbml0ZVByb21pc2UpLmNyZWF0ZUluZmluaXRlUHJvbWlzZSgpKTtcbiAgICB9XG4gICAgLy8gSWYgY2FjaGUgbm9kZSBoYXMgbm8gc3ViVHJlZURhdGEgYW5kIG5vIGRhdGEgcmVxdWVzdCB3ZSBoYXZlIHRvIGluZmluaXRlbHkgc3VzcGVuZCBhcyB0aGUgZGF0YSB3aWxsIGxpa2VseSBmbG93IGluIGZyb20gYW5vdGhlciBwbGFjZS5cbiAgICAvLyBUT0RPLUFQUDogZG91YmxlIGNoZWNrIHVzZXJzIGNhbid0IHJldHVybiBudWxsIGluIGEgY29tcG9uZW50IHRoYXQgd2lsbCBraWNrIGluIGhlcmUuXG4gICAgaWYgKCFjaGlsZE5vZGUuc3ViVHJlZURhdGEpIHtcbiAgICAgICAgKDAsIF9yZWFjdCkudXNlKCgwLCBfaW5maW5pdGVQcm9taXNlKS5jcmVhdGVJbmZpbml0ZVByb21pc2UoKSk7XG4gICAgfVxuICAgIGNvbnN0IHN1YnRyZWUgPSAvLyBUaGUgbGF5b3V0IHJvdXRlciBjb250ZXh0IG5hcnJvd3MgZG93biB0cmVlIGFuZCBjaGlsZE5vZGVzIGF0IGVhY2ggbGV2ZWwuXG4gICAgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkxheW91dFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRyZWU6IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZXJLZXldLFxuICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2RlLnBhcmFsbGVsUm91dGVzLFxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IG92ZXJyaWRpbmcgb2YgdXJsIGZvciBwYXJhbGxlbCByb3V0ZXNcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgaGVhZFJlbmRlcmVkQWJvdmVUaGlzTGV2ZWw6IHRydWVcbiAgICAgICAgfVxuICAgIH0sIGhlYWQsIGNoaWxkTm9kZS5zdWJUcmVlRGF0YSk7XG4gICAgLy8gRW5zdXJlIHJvb3QgbGF5b3V0IGlzIG5vdCB3cmFwcGVkIGluIGEgZGl2IGFzIHRoZSByb290IGxheW91dCByZW5kZXJzIGA8aHRtbD5gXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChTY3JvbGxBbmRGb2N1c0hhbmRsZXIsIHtcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IGZvY3VzQW5kU2Nyb2xsUmVmXG4gICAgfSwgc3VidHJlZSk7XG59XG4vKipcbiAqIFJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgd2l0aCB0aGUgcHJvdmlkZWQgXCJsb2FkaW5nXCIgcHJvcGVydHkgYXMgdGhlIGZhbGxiYWNrLlxuICogSWYgbm8gbG9hZGluZyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBpdCByZW5kZXJzIHRoZSBjaGlsZHJlbiB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gKi8gZnVuY3Rpb24gTG9hZGluZ0JvdW5kYXJ5KHsgY2hpbGRyZW4gLCBsb2FkaW5nICwgbG9hZGluZ1N0eWxlcyAsIGhhc0xvYWRpbmcgIH0pIHtcbiAgICBpZiAoaGFzTG9hZGluZykge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LlN1c3BlbnNlLCB7XG4gICAgICAgICAgICBmYWxsYmFjazogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBsb2FkaW5nU3R5bGVzLCBsb2FkaW5nKVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIEhhbmRsZVJlZGlyZWN0KHsgcmVkaXJlY3QgIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICByb3V0ZXIucmVwbGFjZShyZWRpcmVjdCwge30pO1xuICAgIH0sIFtcbiAgICAgICAgcmVkaXJlY3QsXG4gICAgICAgIHJvdXRlclxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY2xhc3MgUmVkaXJlY3RFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoMCwgX3JlZGlyZWN0KS5pc1JlZGlyZWN0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAoMCwgX3JlZGlyZWN0KS5nZXRVUkxGcm9tUmVkaXJlY3RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiB1cmxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciByZWRpcmVjdFxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCByZWRpcmVjdCA9IHRoaXMuc3RhdGUucmVkaXJlY3Q7XG4gICAgICAgIGlmIChyZWRpcmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChIYW5kbGVSZWRpcmVjdCwge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0OiByZWRpcmVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcmVkaXJlY3Q6IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBSZWRpcmVjdEJvdW5kYXJ5KHsgY2hpbGRyZW4gIH0pIHtcbiAgICBjb25zdCByb3V0ZXIgPSAoMCwgX25hdmlnYXRpb24pLnVzZVJvdXRlcigpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVkaXJlY3RFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHJvdXRlcjogcm91dGVyXG4gICAgfSwgY2hpbGRyZW4pO1xufVxuY2xhc3MgTm90Rm91bmRFcnJvckJvdW5kYXJ5IGV4dGVuZHMgX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgICAgIGlmICgoZXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IGVycm9yLmRpZ2VzdCkgPT09ICdORVhUX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJub2luZGV4XCJcbiAgICAgICAgICAgIH0pLCB0aGlzLnByb3BzLm5vdEZvdW5kU3R5bGVzLCB0aGlzLnByb3BzLm5vdEZvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogISFwcm9wcy5hc05vdEZvdW5kXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gTm90Rm91bmRCb3VuZGFyeSh7IG5vdEZvdW5kICwgbm90Rm91bmRTdHlsZXMgLCBhc05vdEZvdW5kICwgY2hpbGRyZW4gIH0pIHtcbiAgICByZXR1cm4gbm90Rm91bmQgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTm90Rm91bmRFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzLFxuICAgICAgICBhc05vdEZvdW5kOiBhc05vdEZvdW5kXG4gICAgfSwgY2hpbGRyZW4pIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIk91dGVyTGF5b3V0Um91dGVyIiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9yZWFjdERvbSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJfaW5maW5pdGVQcm9taXNlIiwiX2Vycm9yQm91bmRhcnkiLCJfbWF0Y2hTZWdtZW50cyIsIl9uYXZpZ2F0aW9uIiwiX2hhbmRsZVNtb290aFNjcm9sbCIsIl9yZWRpcmVjdCIsIl9maW5kSGVhZEluQ2FjaGUiLCJwYXJhbGxlbFJvdXRlcktleSIsInNlZ21lbnRQYXRoIiwiY2hpbGRQcm9wIiwiZXJyb3IiLCJlcnJvclN0eWxlcyIsInRlbXBsYXRlU3R5bGVzIiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJoYXNMb2FkaW5nIiwidGVtcGxhdGUiLCJub3RGb3VuZCIsIm5vdEZvdW5kU3R5bGVzIiwiYXNOb3RGb3VuZCIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsIkVycm9yIiwiY2hpbGROb2RlcyIsInRyZWUiLCJ1cmwiLCJoZWFkUmVuZGVyZWRBYm92ZVRoaXNMZXZlbCIsImNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciIsImdldCIsInNldCIsIk1hcCIsInRyZWVTZWdtZW50IiwiY2hpbGRQcm9wU2VnbWVudCIsIkFycmF5IiwiaXNBcnJheSIsInNlZ21lbnQiLCJjdXJyZW50Q2hpbGRTZWdtZW50IiwicHJlc2VydmVkU2VnbWVudHMiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJtYXAiLCJwcmVzZXJ2ZWRTZWdtZW50IiwiVGVtcGxhdGVDb250ZXh0IiwiUHJvdmlkZXIiLCJrZXkiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJMb2FkaW5nQm91bmRhcnkiLCJOb3RGb3VuZEJvdW5kYXJ5IiwiUmVkaXJlY3RCb3VuZGFyeSIsIklubmVyTGF5b3V0Um91dGVyIiwicGF0aCIsImlzQWN0aXZlIiwid2Fsa0FkZFJlZmV0Y2giLCJzZWdtZW50UGF0aFRvV2FsayIsInRyZWVUb1JlY3JlYXRlIiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsInByb2Nlc3MiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlcyIsImluY2x1ZGVzIiwidG9wT2ZFbGVtZW50SW5WaWV3cG9ydCIsImVsZW1lbnQiLCJ2aWV3cG9ydEhlaWdodCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0b3AiLCJnZXRIYXNoRnJhZ21lbnREb21Ob2RlIiwiaGFzaEZyYWdtZW50IiwiZG9jdW1lbnQiLCJib2R5IiwicmVmIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsIlNjcm9sbEFuZEZvY3VzSGFuZGxlciIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiaGFuZGxlUG90ZW50aWFsU2Nyb2xsIiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJvcHMiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwicmVuZGVyIiwiY2hpbGRyZW4iLCJjb25zdHJ1Y3RvciIsImFyZ3MiLCJkb21Ob2RlIiwiSFRNTEVsZW1lbnQiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJ3aW5kb3ciLCJzY3JvbGxUbyIsIm9mZnNldFRvcCIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsSW50b1ZpZXciLCJkb250Rm9yY2VMYXlvdXQiLCJmb2N1cyIsIkdsb2JhbExheW91dFJvdXRlckNvbnRleHQiLCJjaGFuZ2VCeVNlcnZlclJlc3BvbnNlIiwiZnVsbFRyZWUiLCJoZWFkIiwidXNlTWVtbyIsImZpbmRIZWFkSW5DYWNoZSIsImNoaWxkTm9kZSIsImN1cnJlbnQiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIkxBWllfSU5JVElBTElaRUQiLCJSRUFEWSIsInN1YlRyZWVEYXRhIiwiZGF0YSIsInBhcmFsbGVsUm91dGVzIiwicmVmZXRjaFRyZWUiLCJEQVRBX0ZFVENIIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwiZmxpZ2h0RGF0YSIsIm92ZXJyaWRlQ2Fub25pY2FsVXJsIiwidXNlIiwiaHJlZiIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJzdWJ0cmVlIiwiU3VzcGVuc2UiLCJmYWxsYmFjayIsIkhhbmRsZVJlZGlyZWN0IiwicmVkaXJlY3QiLCJyb3V0ZXIiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJyZXBsYWNlIiwiUmVkaXJlY3RFcnJvckJvdW5kYXJ5IiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiaXNSZWRpcmVjdEVycm9yIiwiZ2V0VVJMRnJvbVJlZGlyZWN0RXJyb3IiLCJzdGF0ZSIsIk5vdEZvdW5kRXJyb3JCb3VuZGFyeSIsImRpZ2VzdCIsIm5vdEZvdW5kVHJpZ2dlcmVkIiwibmFtZSIsImNvbnRlbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/match-segments.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/match-segments.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchSegment = void 0;\nconst matchSegment = (existingSegment, segment)=>{\n    // Common case: segment is just a string\n    if (typeof existingSegment === \"string\" && typeof segment === \"string\") {\n        return existingSegment === segment;\n    }\n    // Dynamic parameter case: segment is an array with param/value. Both param and value are compared.\n    if (Array.isArray(existingSegment) && Array.isArray(segment)) {\n        return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n    }\n    return false;\n};\nexports.matchSegment = matchSegment;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9tYXRjaC1zZWdtZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxvQkFBb0IsR0FBRyxLQUFLO0FBQzVCLE1BQU1FLGVBQWUsQ0FBQ0MsaUJBQWlCQyxVQUFVO0lBQzdDLHdDQUF3QztJQUN4QyxJQUFJLE9BQU9ELG9CQUFvQixZQUFZLE9BQU9DLFlBQVksVUFBVTtRQUNwRSxPQUFPRCxvQkFBb0JDO0lBQy9CLENBQUM7SUFDRCxtR0FBbUc7SUFDbkcsSUFBSUMsTUFBTUMsT0FBTyxDQUFDSCxvQkFBb0JFLE1BQU1DLE9BQU8sQ0FBQ0YsVUFBVTtRQUMxRCxPQUFPRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRSxJQUFJRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRTtJQUNqRixDQUFDO0lBQ0QsT0FBTyxLQUFLO0FBQ2hCO0FBQ0FKLG9CQUFvQixHQUFHRTtBQUV2QixJQUFJLENBQUMsT0FBT0YsUUFBUU8sT0FBTyxLQUFLLGNBQWUsT0FBT1AsUUFBUU8sT0FBTyxLQUFLLFlBQVlQLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1AsUUFBUU8sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTyxPQUFPLEVBQUUsY0FBYztRQUFFTixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1csTUFBTSxDQUFDVCxRQUFRTyxPQUFPLEVBQUVQO0lBQy9CVSxPQUFPVixPQUFPLEdBQUdBLFFBQVFPLE9BQU87QUFDbEMsQ0FBQyxDQUVELDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzP2JjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoU2VnbWVudCA9IHZvaWQgMDtcbmNvbnN0IG1hdGNoU2VnbWVudCA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgLy8gQ29tbW9uIGNhc2U6IHNlZ21lbnQgaXMganVzdCBhIHN0cmluZ1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTZWdtZW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc2VnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudCA9PT0gc2VnbWVudDtcbiAgICB9XG4gICAgLy8gRHluYW1pYyBwYXJhbWV0ZXIgY2FzZTogc2VnbWVudCBpcyBhbiBhcnJheSB3aXRoIHBhcmFtL3ZhbHVlLiBCb3RoIHBhcmFtIGFuZCB2YWx1ZSBhcmUgY29tcGFyZWQuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdTZWdtZW50KSAmJiBBcnJheS5pc0FycmF5KHNlZ21lbnQpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1NlZ21lbnRbMF0gPT09IHNlZ21lbnRbMF0gJiYgZXhpc3RpbmdTZWdtZW50WzFdID09PSBzZWdtZW50WzFdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0cy5tYXRjaFNlZ21lbnQgPSBtYXRjaFNlZ21lbnQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoU2VnbWVudCIsImV4aXN0aW5nU2VnbWVudCIsInNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/render-from-template-context.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = RenderFromTemplateContext;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\"));\nvar _appRouterContext = __webpack_require__(/*! ../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction RenderFromTemplateContext() {\n    _s();\n    const children = (0, _react).useContext(_appRouterContext.TemplateContext);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, children);\n}\n_s(RenderFromTemplateContext, \"Fd1ieM0FAzMq7OA5+LlfYPV5S7Y=\");\n_c = RenderFromTemplateContext;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=render-from-template-context.js.map\nvar _c;\n$RefreshReg$(_c, \"RenderFromTemplateContext\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yZW5kZXItZnJvbS10ZW1wbGF0ZS1jb250ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUNhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQyw0QkFBNEJDLGtLQUFnRTtBQUNoRyxJQUFJQyxTQUFTRiwwQkFBMEJDLG1CQUFPQSxDQUFDLDRFQUFPO0FBQ3RELElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUMsbUhBQXFDO0FBQ3JFLFNBQVNGLDRCQUE0Qjs7SUFDakMsTUFBTUssV0FBVyxDQUFDLEdBQUdGLE1BQU0sRUFBRUcsVUFBVSxDQUFDRixrQkFBa0JHLGVBQWU7SUFDekUsT0FBTyxXQUFXLEdBQUdKLE9BQU9KLE9BQU8sQ0FBQ1MsYUFBYSxDQUFDTCxPQUFPSixPQUFPLENBQUNVLFFBQVEsRUFBRSxJQUFJLEVBQUVKO0FBQ3JGO0dBSFNMO0tBQUFBO0FBTVQsSUFBSSxDQUFDLE9BQU9ILFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ1csVUFBVSxLQUFLLGFBQWE7SUFDcktmLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUUsT0FBTyxFQUFFLGNBQWM7UUFBRUQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9nQixNQUFNLENBQUNkLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JlLE9BQU9mLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsd0RBQXdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcz84ZWU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJGcm9tVGVtcGxhdGVDb250ZXh0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9hcHBSb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0XCIpO1xuZnVuY3Rpb24gUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2FwcFJvdXRlckNvbnRleHQuVGVtcGxhdGVDb250ZXh0KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59XG5cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLWZyb20tdGVtcGxhdGUtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUmVuZGVyRnJvbVRlbXBsYXRlQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX2FwcFJvdXRlckNvbnRleHQiLCJjaGlsZHJlbiIsInVzZUNvbnRleHQiLCJUZW1wbGF0ZUNvbnRleHQiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/render-from-template-context.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js ***!
  \*****************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.applyRouterStatePatchToTree = applyRouterStatePatchToTree;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */ function applyPatch(initialTree, patchTree) {\n    const [segment, parallelRoutes] = initialTree;\n    if ((0, _matchSegments).matchSegment(segment, patchTree[0])) {\n        const newParallelRoutes = {};\n        for(const key in parallelRoutes){\n            const isInPatchTreeParallelRoutes = typeof patchTree[1][key] !== \"undefined\";\n            if (isInPatchTreeParallelRoutes) {\n                newParallelRoutes[key] = applyPatch(parallelRoutes[key], patchTree[1][key]);\n            } else {\n                newParallelRoutes[key] = parallelRoutes[key];\n            }\n        }\n        for(const key1 in patchTree[1]){\n            if (newParallelRoutes[key1]) {\n                continue;\n            }\n            newParallelRoutes[key1] = patchTree[1][key1];\n        }\n        const tree = [\n            segment,\n            newParallelRoutes\n        ];\n        if (initialTree[2]) {\n            tree[2] = initialTree[2];\n        }\n        if (initialTree[3]) {\n            tree[3] = initialTree[3];\n        }\n        if (initialTree[4]) {\n            tree[4] = initialTree[4];\n        }\n        return tree;\n    }\n    return patchTree;\n}\nfunction applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch) {\n    const [segment, parallelRoutes, , , isRootLayout] = flightRouterState;\n    // Root refresh\n    if (flightSegmentPath.length === 1) {\n        const tree = applyPatch(flightRouterState, treePatch);\n        return tree;\n    }\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Tree path returned from the server should always match up with the current tree in the browser\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        return null;\n    }\n    const lastSegment = flightSegmentPath.length === 2;\n    let parallelRoutePatch;\n    if (lastSegment) {\n        parallelRoutePatch = treePatch;\n    } else {\n        parallelRoutePatch = applyRouterStatePatchToTree(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey], treePatch);\n        if (parallelRoutePatch === null) {\n            return null;\n        }\n    }\n    const tree = [\n        flightSegmentPath[0],\n        _extends({}, parallelRoutes, {\n            [parallelRouteKey]: parallelRoutePatch\n        })\n    ];\n    // Current segment is the root layout\n    if (isRootLayout) {\n        tree[4] = true;\n    }\n    return tree;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=apply-router-state-patch-to-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9hcHBseS1yb3V0ZXItc3RhdGUtcGF0Y2gtdG8tdHJlZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQ0FBbUMsR0FBR0U7QUFDdEMsSUFBSUMsV0FBV0MsZ0lBQStDO0FBQzlELElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsb0dBQW1CO0FBQ2hEOztDQUVDLEdBQUcsU0FBU0csV0FBV0MsV0FBVyxFQUFFQyxTQUFTLEVBQUU7SUFDNUMsTUFBTSxDQUFDQyxTQUFTQyxlQUFlLEdBQUdIO0lBQ2xDLElBQUksQ0FBQyxHQUFHRixjQUFjLEVBQUVNLFlBQVksQ0FBQ0YsU0FBU0QsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN6RCxNQUFNSSxvQkFBb0IsQ0FBQztRQUMzQixJQUFJLE1BQU1DLE9BQU9ILGVBQWU7WUFDNUIsTUFBTUksOEJBQThCLE9BQU9OLFNBQVMsQ0FBQyxFQUFFLENBQUNLLElBQUksS0FBSztZQUNqRSxJQUFJQyw2QkFBNkI7Z0JBQzdCRixpQkFBaUIsQ0FBQ0MsSUFBSSxHQUFHUCxXQUFXSSxjQUFjLENBQUNHLElBQUksRUFBRUwsU0FBUyxDQUFDLEVBQUUsQ0FBQ0ssSUFBSTtZQUM5RSxPQUFPO2dCQUNIRCxpQkFBaUIsQ0FBQ0MsSUFBSSxHQUFHSCxjQUFjLENBQUNHLElBQUk7WUFDaEQsQ0FBQztRQUNMO1FBQ0EsSUFBSSxNQUFNRSxRQUFRUCxTQUFTLENBQUMsRUFBRSxDQUFDO1lBQzNCLElBQUlJLGlCQUFpQixDQUFDRyxLQUFLLEVBQUU7Z0JBQ3pCLFFBQVM7WUFDYixDQUFDO1lBQ0RILGlCQUFpQixDQUFDRyxLQUFLLEdBQUdQLFNBQVMsQ0FBQyxFQUFFLENBQUNPLEtBQUs7UUFDaEQ7UUFDQSxNQUFNQyxPQUFPO1lBQ1RQO1lBQ0FHO1NBQ0g7UUFDRCxJQUFJTCxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ2hCUyxJQUFJLENBQUMsRUFBRSxHQUFHVCxXQUFXLENBQUMsRUFBRTtRQUM1QixDQUFDO1FBQ0QsSUFBSUEsV0FBVyxDQUFDLEVBQUUsRUFBRTtZQUNoQlMsSUFBSSxDQUFDLEVBQUUsR0FBR1QsV0FBVyxDQUFDLEVBQUU7UUFDNUIsQ0FBQztRQUNELElBQUlBLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDaEJTLElBQUksQ0FBQyxFQUFFLEdBQUdULFdBQVcsQ0FBQyxFQUFFO1FBQzVCLENBQUM7UUFDRCxPQUFPUztJQUNYLENBQUM7SUFDRCxPQUFPUjtBQUNYO0FBQ0EsU0FBU1AsNEJBQTRCZ0IsaUJBQWlCLEVBQUVDLGlCQUFpQixFQUFFQyxTQUFTLEVBQUU7SUFDbEYsTUFBTSxDQUFDVixTQUFTQyxvQkFBb0JVLGFBQWEsR0FBR0Y7SUFDcEQsZUFBZTtJQUNmLElBQUlELGtCQUFrQkksTUFBTSxLQUFLLEdBQUc7UUFDaEMsTUFBTUwsT0FBT1YsV0FBV1ksbUJBQW1CQztRQUMzQyxPQUFPSDtJQUNYLENBQUM7SUFDRCxNQUFNLENBQUNNLGdCQUFnQkMsaUJBQWlCLEdBQUdOO0lBQzNDLGlHQUFpRztJQUNqRyxJQUFJLENBQUMsQ0FBQyxHQUFHWixjQUFjLEVBQUVNLFlBQVksQ0FBQ1csZ0JBQWdCYixVQUFVO1FBQzVELE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxNQUFNZSxjQUFjUCxrQkFBa0JJLE1BQU0sS0FBSztJQUNqRCxJQUFJSTtJQUNKLElBQUlELGFBQWE7UUFDYkMscUJBQXFCTjtJQUN6QixPQUFPO1FBQ0hNLHFCQUFxQnhCLDRCQUE0QmdCLGtCQUFrQlMsS0FBSyxDQUFDLElBQUloQixjQUFjLENBQUNhLGlCQUFpQixFQUFFSjtRQUMvRyxJQUFJTSx1QkFBdUIsSUFBSSxFQUFFO1lBQzdCLE9BQU8sSUFBSTtRQUNmLENBQUM7SUFDTCxDQUFDO0lBQ0QsTUFBTVQsT0FBTztRQUNUQyxpQkFBaUIsQ0FBQyxFQUFFO1FBQ3BCZixTQUFTLENBQUMsR0FBR1EsZ0JBQWdCO1lBQ3pCLENBQUNhLGlCQUFpQixFQUFFRTtRQUN4QjtLQUNIO0lBQ0QscUNBQXFDO0lBQ3JDLElBQUlMLGNBQWM7UUFDZEosSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJO0lBQ2xCLENBQUM7SUFDRCxPQUFPQTtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9qQixRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUN1QixVQUFVLEtBQUssYUFBYTtJQUNySzlCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8rQixNQUFNLENBQUM3QixRQUFRSyxPQUFPLEVBQUVMO0lBQy9COEIsT0FBTzlCLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsNERBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWUuanM/ZjdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlID0gYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfbWF0Y2hTZWdtZW50cyA9IHJlcXVpcmUoXCIuLi9tYXRjaC1zZWdtZW50c1wiKTtcbi8qKlxuICogRGVlcCBtZXJnZSBvZiB0aGUgdHdvIHJvdXRlciBzdGF0ZXMuIFBhcmFsbGVsIHJvdXRlIGtleXMgYXJlIHByZXNlcnZlZCBpZiB0aGUgcGF0Y2ggZG9lc24ndCBoYXZlIHRoZW0uXG4gKi8gZnVuY3Rpb24gYXBwbHlQYXRjaChpbml0aWFsVHJlZSwgcGF0Y2hUcmVlKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IGluaXRpYWxUcmVlO1xuICAgIGlmICgoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudChzZWdtZW50LCBwYXRjaFRyZWVbMF0pKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcmFsbGVsUm91dGVzID0ge307XG4gICAgICAgIGZvcihjb25zdCBrZXkgaW4gcGFyYWxsZWxSb3V0ZXMpe1xuICAgICAgICAgICAgY29uc3QgaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzID0gdHlwZW9mIHBhdGNoVHJlZVsxXVtrZXldICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIGlmIChpc0luUGF0Y2hUcmVlUGFyYWxsZWxSb3V0ZXMpIHtcbiAgICAgICAgICAgICAgICBuZXdQYXJhbGxlbFJvdXRlc1trZXldID0gYXBwbHlQYXRjaChwYXJhbGxlbFJvdXRlc1trZXldLCBwYXRjaFRyZWVbMV1ba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleV0gPSBwYXJhbGxlbFJvdXRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcihjb25zdCBrZXkxIGluIHBhdGNoVHJlZVsxXSl7XG4gICAgICAgICAgICBpZiAobmV3UGFyYWxsZWxSb3V0ZXNba2V5MV0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1BhcmFsbGVsUm91dGVzW2tleTFdID0gcGF0Y2hUcmVlWzFdW2tleTFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyZWUgPSBbXG4gICAgICAgICAgICBzZWdtZW50LFxuICAgICAgICAgICAgbmV3UGFyYWxsZWxSb3V0ZXNcbiAgICAgICAgXTtcbiAgICAgICAgaWYgKGluaXRpYWxUcmVlWzJdKSB7XG4gICAgICAgICAgICB0cmVlWzJdID0gaW5pdGlhbFRyZWVbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxUcmVlWzNdKSB7XG4gICAgICAgICAgICB0cmVlWzNdID0gaW5pdGlhbFRyZWVbM107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluaXRpYWxUcmVlWzRdKSB7XG4gICAgICAgICAgICB0cmVlWzRdID0gaW5pdGlhbFRyZWVbNF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIHJldHVybiBwYXRjaFRyZWU7XG59XG5mdW5jdGlvbiBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoZmxpZ2h0U2VnbWVudFBhdGgsIGZsaWdodFJvdXRlclN0YXRlLCB0cmVlUGF0Y2gpIHtcbiAgICBjb25zdCBbc2VnbWVudCwgcGFyYWxsZWxSb3V0ZXMsICwgLCBpc1Jvb3RMYXlvdXRdID0gZmxpZ2h0Um91dGVyU3RhdGU7XG4gICAgLy8gUm9vdCByZWZyZXNoXG4gICAgaWYgKGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCB0cmVlID0gYXBwbHlQYXRjaChmbGlnaHRSb3V0ZXJTdGF0ZSwgdHJlZVBhdGNoKTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIGNvbnN0IFtjdXJyZW50U2VnbWVudCwgcGFyYWxsZWxSb3V0ZUtleV0gPSBmbGlnaHRTZWdtZW50UGF0aDtcbiAgICAvLyBUcmVlIHBhdGggcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIHNob3VsZCBhbHdheXMgbWF0Y2ggdXAgd2l0aCB0aGUgY3VycmVudCB0cmVlIGluIHRoZSBicm93c2VyXG4gICAgaWYgKCEoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudChjdXJyZW50U2VnbWVudCwgc2VnbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gZmxpZ2h0U2VnbWVudFBhdGgubGVuZ3RoID09PSAyO1xuICAgIGxldCBwYXJhbGxlbFJvdXRlUGF0Y2g7XG4gICAgaWYgKGxhc3RTZWdtZW50KSB7XG4gICAgICAgIHBhcmFsbGVsUm91dGVQYXRjaCA9IHRyZWVQYXRjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbGxlbFJvdXRlUGF0Y2ggPSBhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoZmxpZ2h0U2VnbWVudFBhdGguc2xpY2UoMiksIHBhcmFsbGVsUm91dGVzW3BhcmFsbGVsUm91dGVLZXldLCB0cmVlUGF0Y2gpO1xuICAgICAgICBpZiAocGFyYWxsZWxSb3V0ZVBhdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0cmVlID0gW1xuICAgICAgICBmbGlnaHRTZWdtZW50UGF0aFswXSxcbiAgICAgICAgX2V4dGVuZHMoe30sIHBhcmFsbGVsUm91dGVzLCB7XG4gICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IHBhcmFsbGVsUm91dGVQYXRjaFxuICAgICAgICB9KSwgXG4gICAgXTtcbiAgICAvLyBDdXJyZW50IHNlZ21lbnQgaXMgdGhlIHJvb3QgbGF5b3V0XG4gICAgaWYgKGlzUm9vdExheW91dCkge1xuICAgICAgICB0cmVlWzRdID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWU7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSIsIl9leHRlbmRzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfbWF0Y2hTZWdtZW50cyIsImFwcGx5UGF0Y2giLCJpbml0aWFsVHJlZSIsInBhdGNoVHJlZSIsInNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlcyIsIm1hdGNoU2VnbWVudCIsIm5ld1BhcmFsbGVsUm91dGVzIiwia2V5IiwiaXNJblBhdGNoVHJlZVBhcmFsbGVsUm91dGVzIiwia2V5MSIsInRyZWUiLCJmbGlnaHRTZWdtZW50UGF0aCIsImZsaWdodFJvdXRlclN0YXRlIiwidHJlZVBhdGNoIiwiaXNSb290TGF5b3V0IiwibGVuZ3RoIiwiY3VycmVudFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlS2V5IiwibGFzdFNlZ21lbnQiLCJwYXJhbGxlbFJvdXRlUGF0Y2giLCJzbGljZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createHrefFromUrl = createHrefFromUrl;\nfunction createHrefFromUrl(url) {\n    return url.pathname + url.search + url.hash;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-href-from-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaHJlZi1mcm9tLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUIsU0FBU0Esa0JBQWtCQyxHQUFHLEVBQUU7SUFDNUIsT0FBT0EsSUFBSUMsUUFBUSxHQUFHRCxJQUFJRSxNQUFNLEdBQUdGLElBQUlHLElBQUk7QUFDL0M7QUFFQSxJQUFJLENBQUMsT0FBT04sUUFBUU8sT0FBTyxLQUFLLGNBQWUsT0FBT1AsUUFBUU8sT0FBTyxLQUFLLFlBQVlQLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1AsUUFBUU8sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTyxPQUFPLEVBQUUsY0FBYztRQUFFTixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1csTUFBTSxDQUFDVCxRQUFRTyxPQUFPLEVBQUVQO0lBQy9CVSxPQUFPVixPQUFPLEdBQUdBLFFBQVFPLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1ocmVmLWZyb20tdXJsLmpzP2E3NzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUhyZWZGcm9tVXJsID0gY3JlYXRlSHJlZkZyb21Vcmw7XG5mdW5jdGlvbiBjcmVhdGVIcmVmRnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaCArIHVybC5oYXNoO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtaHJlZi1mcm9tLXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVybCIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js ***!
  \************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createInitialRouterState = createInitialRouterState;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ./create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nfunction createInitialRouterState(param) {\n    let { initialTree , children , initialCanonicalUrl , initialParallelRoutes , isServer , location , initialHead  } = param;\n    const cache = {\n        status: _appRouterContext.CacheStates.READY,\n        data: null,\n        subTreeData: children,\n        // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n        parallelRoutes: isServer ? new Map() : initialParallelRoutes\n    };\n    // When the cache hasn't been seeded yet we fill the cache with the head.\n    if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n        (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(cache, undefined, initialTree, initialHead);\n    }\n    return {\n        tree: initialTree,\n        cache,\n        prefetchCache: new Map(),\n        pushRef: {\n            pendingPush: false,\n            mpaNavigation: false\n        },\n        focusAndScrollRef: {\n            apply: false,\n            hashFragment: null\n        },\n        canonicalUrl: // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n        location ? (0, _createHrefFromUrl).createHrefFromUrl(location) : initialCanonicalUrl\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-initial-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtaW5pdGlhbC1yb3V0ZXItc3RhdGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0NBQWdDLEdBQUdFO0FBQ25DLElBQUlDLG9CQUFvQkMsbUJBQU9BLENBQUMsc0hBQXdDO0FBQ3hFLElBQUlDLHFCQUFxQkQsbUJBQU9BLENBQUMsOEhBQXdCO0FBQ3pELElBQUlFLGlDQUFpQ0YsbUJBQU9BLENBQUMsNEpBQXVDO0FBQ3BGLFNBQVNGLHlCQUF5QixLQUE2RyxFQUFFO1FBQS9HLEVBQUVLLFlBQVcsRUFBR0MsU0FBUSxFQUFHQyxvQkFBbUIsRUFBR0Msc0JBQXFCLEVBQUdDLFNBQVEsRUFBR0MsU0FBUSxFQUFHQyxZQUFXLEVBQUcsR0FBN0c7SUFDOUIsTUFBTUMsUUFBUTtRQUNWQyxRQUFRWixrQkFBa0JhLFdBQVcsQ0FBQ0MsS0FBSztRQUMzQ0MsTUFBTSxJQUFJO1FBQ1ZDLGFBQWFYO1FBQ2Isb0pBQW9KO1FBQ3BKWSxnQkFBZ0JULFdBQVcsSUFBSVUsUUFBUVgscUJBQXFCO0lBQ2hFO0lBQ0EseUVBQXlFO0lBQ3pFLElBQUlBLDBCQUEwQixJQUFJLElBQUlBLHNCQUFzQlksSUFBSSxLQUFLLEdBQUc7UUFDbkUsSUFBR2hCLDhCQUE4QixFQUFFaUIsNkJBQTZCLENBQUNULE9BQU9VLFdBQVdqQixhQUFhTTtJQUNyRyxDQUFDO0lBQ0QsT0FBTztRQUNIWSxNQUFNbEI7UUFDTk87UUFDQVksZUFBZSxJQUFJTDtRQUNuQk0sU0FBUztZQUNMQyxhQUFhLEtBQUs7WUFDbEJDLGVBQWUsS0FBSztRQUN4QjtRQUNBQyxtQkFBbUI7WUFDZkMsT0FBTyxLQUFLO1lBQ1pDLGNBQWMsSUFBSTtRQUN0QjtRQUNBQyxjQUNBLGtKQUFrSjtRQUNsSnJCLFdBQVcsQ0FBQyxHQUFHUCxrQkFBa0IsRUFBRTZCLGlCQUFpQixDQUFDdEIsWUFBWUgsbUJBQW1CO0lBQ3hGO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1QsUUFBUW1DLE9BQU8sS0FBSyxjQUFlLE9BQU9uQyxRQUFRbUMsT0FBTyxLQUFLLFlBQVluQyxRQUFRbUMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkMsUUFBUW1DLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QyxPQUFPQyxjQUFjLENBQUNDLFFBQVFtQyxPQUFPLEVBQUUsY0FBYztRQUFFbEMsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU91QyxNQUFNLENBQUNyQyxRQUFRbUMsT0FBTyxFQUFFbkM7SUFDL0JzQyxPQUFPdEMsT0FBTyxHQUFHQSxRQUFRbUMsT0FBTztBQUNsQyxDQUFDLENBRUQsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzP2RjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSA9IGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfY3JlYXRlSHJlZkZyb21VcmwgPSByZXF1aXJlKFwiLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbnZhciBfZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgPSByZXF1aXJlKFwiLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSh7IGluaXRpYWxUcmVlICwgY2hpbGRyZW4gLCBpbml0aWFsQ2Fub25pY2FsVXJsICwgaW5pdGlhbFBhcmFsbGVsUm91dGVzICwgaXNTZXJ2ZXIgLCBsb2NhdGlvbiAsIGluaXRpYWxIZWFkICB9KSB7XG4gICAgY29uc3QgY2FjaGUgPSB7XG4gICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIHN1YlRyZWVEYXRhOiBjaGlsZHJlbixcbiAgICAgICAgLy8gVGhlIGNhY2hlIGdldHMgc2VlZGVkIGR1cmluZyB0aGUgZmlyc3QgcmVuZGVyLiBgaW5pdGlhbFBhcmFsbGVsUm91dGVzYCBlbnN1cmVzIHRoZSBjYWNoZSBmcm9tIHRoZSBmaXJzdCByZW5kZXIgaXMgdGhlcmUgZHVyaW5nIHRoZSBzZWNvbmQgcmVuZGVyLlxuICAgICAgICBwYXJhbGxlbFJvdXRlczogaXNTZXJ2ZXIgPyBuZXcgTWFwKCkgOiBpbml0aWFsUGFyYWxsZWxSb3V0ZXNcbiAgICB9O1xuICAgIC8vIFdoZW4gdGhlIGNhY2hlIGhhc24ndCBiZWVuIHNlZWRlZCB5ZXQgd2UgZmlsbCB0aGUgY2FjaGUgd2l0aCB0aGUgaGVhZC5cbiAgICBpZiAoaW5pdGlhbFBhcmFsbGVsUm91dGVzID09PSBudWxsIHx8IGluaXRpYWxQYXJhbGxlbFJvdXRlcy5zaXplID09PSAwKSB7XG4gICAgICAgICgwLCBfZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQpLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKGNhY2hlLCB1bmRlZmluZWQsIGluaXRpYWxUcmVlLCBpbml0aWFsSGVhZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRyZWU6IGluaXRpYWxUcmVlLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgcHJlZmV0Y2hDYWNoZTogbmV3IE1hcCgpLFxuICAgICAgICBwdXNoUmVmOiB7XG4gICAgICAgICAgICBwZW5kaW5nUHVzaDogZmFsc2UsXG4gICAgICAgICAgICBtcGFOYXZpZ2F0aW9uOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgYXBwbHk6IGZhbHNlLFxuICAgICAgICAgICAgaGFzaEZyYWdtZW50OiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIGNhbm9uaWNhbFVybDogLy8gbG9jYXRpb24uaHJlZiBpcyByZWFkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciBjYW5vbmljYWxVcmwgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgLy8gVGhpcyBpcyBzYWZlIHRvIGRvIGFzIGNhbm9uaWNhbFVybCBjYW4ndCBiZSByZW5kZXJlZCwgaXQncyBvbmx5IHVzZWQgdG8gY29udHJvbCB0aGUgaGlzdG9yeSB1cGRhdGVzIGluIHRoZSB1c2VFZmZlY3QgZnVydGhlciBkb3duIGluIHRoaXMgZmlsZS5cbiAgICAgICAgbG9jYXRpb24gPyAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChsb2NhdGlvbikgOiBpbml0aWFsQ2Fub25pY2FsVXJsXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLWluaXRpYWwtcm91dGVyLXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZUluaXRpYWxSb3V0ZXJTdGF0ZSIsIl9hcHBSb3V0ZXJDb250ZXh0IiwicmVxdWlyZSIsIl9jcmVhdGVIcmVmRnJvbVVybCIsIl9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsImluaXRpYWxUcmVlIiwiY2hpbGRyZW4iLCJpbml0aWFsQ2Fub25pY2FsVXJsIiwiaW5pdGlhbFBhcmFsbGVsUm91dGVzIiwiaXNTZXJ2ZXIiLCJsb2NhdGlvbiIsImluaXRpYWxIZWFkIiwiY2FjaGUiLCJzdGF0dXMiLCJDYWNoZVN0YXRlcyIsIlJFQURZIiwiZGF0YSIsInN1YlRyZWVEYXRhIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJzaXplIiwiZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQiLCJ1bmRlZmluZWQiLCJ0cmVlIiwicHJlZmV0Y2hDYWNoZSIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsIm1wYU5hdmlnYXRpb24iLCJmb2N1c0FuZFNjcm9sbFJlZiIsImFwcGx5IiwiaGFzaEZyYWdtZW50IiwiY2Fub25pY2FsVXJsIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js ***!
  \*******************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createOptimisticTree = createOptimisticTree;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction createOptimisticTree(segments, flightRouterState, parentRefetch) {\n    const [existingSegment, existingParallelRoutes, url, refresh, isRootLayout] = flightRouterState || [\n        null,\n        {}\n    ];\n    const segment = segments[0];\n    const isLastSegment = segments.length === 1;\n    const segmentMatches = existingSegment !== null && (0, _matchSegments).matchSegment(existingSegment, segment);\n    const shouldRefetchThisLevel = !flightRouterState || !segmentMatches;\n    let parallelRoutes = {};\n    if (existingSegment !== null && segmentMatches) {\n        parallelRoutes = existingParallelRoutes;\n    }\n    let childTree;\n    if (!isLastSegment) {\n        const childItem = createOptimisticTree(segments.slice(1), parallelRoutes ? parallelRoutes.children : null, parentRefetch || shouldRefetchThisLevel);\n        childTree = childItem;\n    }\n    const result = [\n        segment,\n        _extends({}, parallelRoutes, childTree ? {\n            children: childTree\n        } : {})\n    ];\n    if (url) {\n        result[2] = url;\n    }\n    if (!parentRefetch && shouldRefetchThisLevel) {\n        result[3] = \"refetch\";\n    } else if (segmentMatches && refresh) {\n        result[3] = refresh;\n    }\n    if (segmentMatches && isRootLayout) {\n        result[4] = isRootLayout;\n    }\n    return result;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-optimistic-tree.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtb3B0aW1pc3RpYy10cmVlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDRCQUE0QixHQUFHRTtBQUMvQixJQUFJQyxXQUFXQyxnSUFBK0M7QUFDOUQsSUFBSUUsaUJBQWlCRixtQkFBT0EsQ0FBQyxvR0FBbUI7QUFDaEQsU0FBU0YscUJBQXFCSyxRQUFRLEVBQUVDLGlCQUFpQixFQUFFQyxhQUFhLEVBQUU7SUFDdEUsTUFBTSxDQUFDQyxpQkFBaUJDLHdCQUF3QkMsS0FBS0MsU0FBU0MsYUFBYSxHQUFHTixxQkFBcUI7UUFDL0YsSUFBSTtRQUNKLENBQUM7S0FDSjtJQUNELE1BQU1PLFVBQVVSLFFBQVEsQ0FBQyxFQUFFO0lBQzNCLE1BQU1TLGdCQUFnQlQsU0FBU1UsTUFBTSxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQlIsb0JBQW9CLElBQUksSUFBSSxDQUFDLEdBQUdKLGNBQWMsRUFBRWEsWUFBWSxDQUFDVCxpQkFBaUJLO0lBQ3JHLE1BQU1LLHlCQUF5QixDQUFDWixxQkFBcUIsQ0FBQ1U7SUFDdEQsSUFBSUcsaUJBQWlCLENBQUM7SUFDdEIsSUFBSVgsb0JBQW9CLElBQUksSUFBSVEsZ0JBQWdCO1FBQzVDRyxpQkFBaUJWO0lBQ3JCLENBQUM7SUFDRCxJQUFJVztJQUNKLElBQUksQ0FBQ04sZUFBZTtRQUNoQixNQUFNTyxZQUFZckIscUJBQXFCSyxTQUFTaUIsS0FBSyxDQUFDLElBQUlILGlCQUFpQkEsZUFBZUksUUFBUSxHQUFHLElBQUksRUFBRWhCLGlCQUFpQlc7UUFDNUhFLFlBQVlDO0lBQ2hCLENBQUM7SUFDRCxNQUFNRyxTQUFTO1FBQ1hYO1FBQ0FaLFNBQVMsQ0FBQyxHQUFHa0IsZ0JBQWdCQyxZQUFZO1lBQ3JDRyxVQUFVSDtRQUNkLElBQUksQ0FBQyxDQUFDO0tBQ1Q7SUFDRCxJQUFJVixLQUFLO1FBQ0xjLE1BQU0sQ0FBQyxFQUFFLEdBQUdkO0lBQ2hCLENBQUM7SUFDRCxJQUFJLENBQUNILGlCQUFpQlcsd0JBQXdCO1FBQzFDTSxNQUFNLENBQUMsRUFBRSxHQUFHO0lBQ2hCLE9BQU8sSUFBSVIsa0JBQWtCTCxTQUFTO1FBQ2xDYSxNQUFNLENBQUMsRUFBRSxHQUFHYjtJQUNoQixDQUFDO0lBQ0QsSUFBSUssa0JBQWtCSixjQUFjO1FBQ2hDWSxNQUFNLENBQUMsRUFBRSxHQUFHWjtJQUNoQixDQUFDO0lBQ0QsT0FBT1k7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPMUIsUUFBUUssT0FBTyxLQUFLLGNBQWUsT0FBT0wsUUFBUUssT0FBTyxLQUFLLFlBQVlMLFFBQVFLLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0wsUUFBUUssT0FBTyxDQUFDc0IsVUFBVSxLQUFLLGFBQWE7SUFDcks3QixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPOEIsTUFBTSxDQUFDNUIsUUFBUUssT0FBTyxFQUFFTDtJQUMvQjZCLE9BQU83QixPQUFPLEdBQUdBLFFBQVFLLE9BQU87QUFDbEMsQ0FBQyxDQUVELGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2NyZWF0ZS1vcHRpbWlzdGljLXRyZWUuanM/ZGQwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY3JlYXRlT3B0aW1pc3RpY1RyZWUgPSBjcmVhdGVPcHRpbWlzdGljVHJlZTtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi4vbWF0Y2gtc2VnbWVudHNcIik7XG5mdW5jdGlvbiBjcmVhdGVPcHRpbWlzdGljVHJlZShzZWdtZW50cywgZmxpZ2h0Um91dGVyU3RhdGUsIHBhcmVudFJlZmV0Y2gpIHtcbiAgICBjb25zdCBbZXhpc3RpbmdTZWdtZW50LCBleGlzdGluZ1BhcmFsbGVsUm91dGVzLCB1cmwsIHJlZnJlc2gsIGlzUm9vdExheW91dF0gPSBmbGlnaHRSb3V0ZXJTdGF0ZSB8fCBbXG4gICAgICAgIG51bGwsXG4gICAgICAgIHt9XG4gICAgXTtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbMF07XG4gICAgY29uc3QgaXNMYXN0U2VnbWVudCA9IHNlZ21lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBzZWdtZW50TWF0Y2hlcyA9IGV4aXN0aW5nU2VnbWVudCAhPT0gbnVsbCAmJiAoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpO1xuICAgIGNvbnN0IHNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwgPSAhZmxpZ2h0Um91dGVyU3RhdGUgfHwgIXNlZ21lbnRNYXRjaGVzO1xuICAgIGxldCBwYXJhbGxlbFJvdXRlcyA9IHt9O1xuICAgIGlmIChleGlzdGluZ1NlZ21lbnQgIT09IG51bGwgJiYgc2VnbWVudE1hdGNoZXMpIHtcbiAgICAgICAgcGFyYWxsZWxSb3V0ZXMgPSBleGlzdGluZ1BhcmFsbGVsUm91dGVzO1xuICAgIH1cbiAgICBsZXQgY2hpbGRUcmVlO1xuICAgIGlmICghaXNMYXN0U2VnbWVudCkge1xuICAgICAgICBjb25zdCBjaGlsZEl0ZW0gPSBjcmVhdGVPcHRpbWlzdGljVHJlZShzZWdtZW50cy5zbGljZSgxKSwgcGFyYWxsZWxSb3V0ZXMgPyBwYXJhbGxlbFJvdXRlcy5jaGlsZHJlbiA6IG51bGwsIHBhcmVudFJlZmV0Y2ggfHwgc2hvdWxkUmVmZXRjaFRoaXNMZXZlbCk7XG4gICAgICAgIGNoaWxkVHJlZSA9IGNoaWxkSXRlbTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICBzZWdtZW50LFxuICAgICAgICBfZXh0ZW5kcyh7fSwgcGFyYWxsZWxSb3V0ZXMsIGNoaWxkVHJlZSA/IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZFRyZWVcbiAgICAgICAgfSA6IHt9KSwgXG4gICAgXTtcbiAgICBpZiAodXJsKSB7XG4gICAgICAgIHJlc3VsdFsyXSA9IHVybDtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRSZWZldGNoICYmIHNob3VsZFJlZmV0Y2hUaGlzTGV2ZWwpIHtcbiAgICAgICAgcmVzdWx0WzNdID0gJ3JlZmV0Y2gnO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudE1hdGNoZXMgJiYgcmVmcmVzaCkge1xuICAgICAgICByZXN1bHRbM10gPSByZWZyZXNoO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudE1hdGNoZXMgJiYgaXNSb290TGF5b3V0KSB7XG4gICAgICAgIHJlc3VsdFs0XSA9IGlzUm9vdExheW91dDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLW9wdGltaXN0aWMtdHJlZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjcmVhdGVPcHRpbWlzdGljVHJlZSIsIl9leHRlbmRzIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfbWF0Y2hTZWdtZW50cyIsInNlZ21lbnRzIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJwYXJlbnRSZWZldGNoIiwiZXhpc3RpbmdTZWdtZW50IiwiZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyIsInVybCIsInJlZnJlc2giLCJpc1Jvb3RMYXlvdXQiLCJzZWdtZW50IiwiaXNMYXN0U2VnbWVudCIsImxlbmd0aCIsInNlZ21lbnRNYXRjaGVzIiwibWF0Y2hTZWdtZW50Iiwic2hvdWxkUmVmZXRjaFRoaXNMZXZlbCIsInBhcmFsbGVsUm91dGVzIiwiY2hpbGRUcmVlIiwiY2hpbGRJdGVtIiwic2xpY2UiLCJjaGlsZHJlbiIsInJlc3VsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js ***!
  \************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.createRecordFromThenable = createRecordFromThenable;\nfunction createRecordFromThenable(thenable) {\n    thenable.status = \"pending\";\n    thenable.then((value)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"fulfilled\";\n            thenable.value = value;\n        }\n    }, (err)=>{\n        if (thenable.status === \"pending\") {\n            thenable.status = \"rejected\";\n            thenable.value = err;\n        }\n    });\n    return thenable;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=create-record-from-thenable.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcmVjb3JkLWZyb20tdGhlbmFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0NBQWdDLEdBQUdFO0FBQ25DLFNBQVNBLHlCQUF5QkMsUUFBUSxFQUFFO0lBQ3hDQSxTQUFTQyxNQUFNLEdBQUc7SUFDbEJELFNBQVNFLElBQUksQ0FBQyxDQUFDSixRQUFRO1FBQ25CLElBQUlFLFNBQVNDLE1BQU0sS0FBSyxXQUFXO1lBQy9CRCxTQUFTQyxNQUFNLEdBQUc7WUFDbEJELFNBQVNGLEtBQUssR0FBR0E7UUFDckIsQ0FBQztJQUNMLEdBQUcsQ0FBQ0ssTUFBTTtRQUNOLElBQUlILFNBQVNDLE1BQU0sS0FBSyxXQUFXO1lBQy9CRCxTQUFTQyxNQUFNLEdBQUc7WUFDbEJELFNBQVNGLEtBQUssR0FBR0s7UUFDckIsQ0FBQztJQUNMO0lBQ0EsT0FBT0g7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPSCxRQUFRTyxPQUFPLEtBQUssY0FBZSxPQUFPUCxRQUFRTyxPQUFPLEtBQUssWUFBWVAsUUFBUU8sT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUCxRQUFRTyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVixPQUFPQyxjQUFjLENBQUNDLFFBQVFPLE9BQU8sRUFBRSxjQUFjO1FBQUVOLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVyxNQUFNLENBQUNULFFBQVFPLE9BQU8sRUFBRVA7SUFDL0JVLE9BQU9WLE9BQU8sR0FBR0EsUUFBUU8sT0FBTztBQUNsQyxDQUFDLENBRUQsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvY3JlYXRlLXJlY29yZC1mcm9tLXRoZW5hYmxlLmpzPzNhMzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSA9IGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZTtcbmZ1bmN0aW9uIGNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSh0aGVuYWJsZSkge1xuICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICB0aGVuYWJsZS50aGVuKCh2YWx1ZSk9PntcbiAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICB0aGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIHRoZW5hYmxlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCAoZXJyKT0+e1xuICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgIHRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICB0aGVuYWJsZS52YWx1ZSA9IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGVuYWJsZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlLXJlY29yZC1mcm9tLXRoZW5hYmxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSIsInRoZW5hYmxlIiwic3RhdHVzIiwidGhlbiIsImVyciIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js ***!
  \******************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fetchServerResponse = fetchServerResponse;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"(app-client)/./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _client = __webpack_require__(/*! next/dist/compiled/react-server-dom-webpack/client */ \"(app-client)/./node_modules/next/dist/compiled/react-server-dom-webpack/client.js\");\nvar _appRouterHeaders = __webpack_require__(/*! ../app-router-headers */ \"(app-client)/./node_modules/next/dist/client/components/app-router-headers.js\");\nvar _appRouter = __webpack_require__(/*! ../app-router */ \"(app-client)/./node_modules/next/dist/client/components/app-router.js\");\nfunction fetchServerResponse(url, flightRouterState, prefetch) {\n    return _fetchServerResponse.apply(this, arguments);\n}\nfunction _fetchServerResponse() {\n    _fetchServerResponse = _async_to_generator(function*(url, flightRouterState, prefetch) {\n        const headers = {\n            // Enable flight response\n            [_appRouterHeaders.RSC]: \"1\",\n            // Provide the current router state\n            [_appRouterHeaders.NEXT_ROUTER_STATE_TREE]: JSON.stringify(flightRouterState)\n        };\n        if (prefetch) {\n            // Enable prefetch response\n            headers[_appRouterHeaders.NEXT_ROUTER_PREFETCH] = \"1\";\n        }\n        try {\n            let fetchUrl = url;\n            if (false) {}\n            const res = yield fetch(fetchUrl, {\n                // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n                credentials: \"same-origin\",\n                headers\n            });\n            const canonicalUrl = res.redirected ? (0, _appRouter).urlToUrlWithoutFlightMarker(res.url) : undefined;\n            const contentType = res.headers.get(\"content-type\") || \"\";\n            let isFlightResponse = contentType === _appRouterHeaders.RSC_CONTENT_TYPE_HEADER;\n            if (false) {}\n            // If fetch returns something different than flight response handle it like a mpa navigation\n            if (!isFlightResponse) {\n                return [\n                    res.url,\n                    undefined\n                ];\n            }\n            // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n            const flightData = yield (0, _client).createFromFetch(Promise.resolve(res));\n            return [\n                flightData,\n                canonicalUrl\n            ];\n        } catch (err) {\n            console.error(\"Failed to fetch RSC payload. Falling back to browser navigation.\", err);\n            // If fetch fails handle it like a mpa navigation\n            // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n            // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n            return [\n                url.toString(),\n                undefined\n            ];\n        }\n    });\n    return _fetchServerResponse.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fetch-server-response.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUdFO0FBQzlCLElBQUlDLHNCQUFzQkMsc0pBQTBEO0FBQ3BGLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDLDZJQUFvRDtBQUMxRSxJQUFJRyxvQkFBb0JILG1CQUFPQSxDQUFDLDRHQUF1QjtBQUN2RCxJQUFJSSxhQUFhSixtQkFBT0EsQ0FBQyw0RkFBZTtBQUV4QyxTQUFTRixvQkFBb0JPLEdBQUcsRUFBRUMsaUJBQWlCLEVBQUVDLFFBQVEsRUFBRTtJQUMzRCxPQUFPQyxxQkFBcUJDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQzVDO0FBQ0EsU0FBU0YsdUJBQXVCO0lBQzVCQSx1QkFBdUJULG9CQUFvQixVQUFVTSxHQUFHLEVBQUVDLGlCQUFpQixFQUFFQyxRQUFRLEVBQUU7UUFDbkYsTUFBTUksVUFBVTtZQUNaLHlCQUF5QjtZQUN6QixDQUFDUixrQkFBa0JTLEdBQUcsQ0FBQyxFQUFFO1lBQ3pCLG1DQUFtQztZQUNuQyxDQUFDVCxrQkFBa0JVLHNCQUFzQixDQUFDLEVBQUVDLEtBQUtDLFNBQVMsQ0FBQ1Q7UUFDL0Q7UUFDQSxJQUFJQyxVQUFVO1lBQ1YsMkJBQTJCO1lBQzNCSSxPQUFPLENBQUNSLGtCQUFrQmEsb0JBQW9CLENBQUMsR0FBRztRQUN0RCxDQUFDO1FBQ0QsSUFBSTtZQUNBLElBQUlDLFdBQVdaO1lBQ2YsSUFBSWEsS0FBcUMsRUFBVSxFQVFsRDtZQUNELE1BQU1NLE1BQU0sTUFBTUMsTUFBTVIsVUFBVTtnQkFDOUIsd0ZBQXdGO2dCQUN4RlMsYUFBYTtnQkFDYmY7WUFDSjtZQUNBLE1BQU1nQixlQUFlSCxJQUFJSSxVQUFVLEdBQUcsQ0FBQyxHQUFHeEIsVUFBVSxFQUFFeUIsMkJBQTJCLENBQUNMLElBQUluQixHQUFHLElBQUl5QixTQUFTO1lBQ3RHLE1BQU1DLGNBQWNQLElBQUliLE9BQU8sQ0FBQ3FCLEdBQUcsQ0FBQyxtQkFBbUI7WUFDdkQsSUFBSUMsbUJBQW1CRixnQkFBZ0I1QixrQkFBa0IrQix1QkFBdUI7WUFDaEYsSUFBSWhCLEtBQXFDLEVBQVUsRUFJbEQ7WUFDRCw0RkFBNEY7WUFDNUYsSUFBSSxDQUFDZSxrQkFBa0I7Z0JBQ25CLE9BQU87b0JBQ0hULElBQUluQixHQUFHO29CQUNQeUI7aUJBQ0g7WUFDTCxDQUFDO1lBQ0QsMkVBQTJFO1lBQzNFLE1BQU1NLGFBQWEsTUFBTSxDQUFDLEdBQUdsQyxPQUFPLEVBQUVtQyxlQUFlLENBQUNDLFFBQVFDLE9BQU8sQ0FBQ2Y7WUFDdEUsT0FBTztnQkFDSFk7Z0JBQ0FUO2FBQ0g7UUFDTCxFQUFFLE9BQU9hLEtBQUs7WUFDVkMsUUFBUUMsS0FBSyxDQUFDLG9FQUFvRUY7WUFDbEYsaURBQWlEO1lBQ2pELHFIQUFxSDtZQUNySCxpR0FBaUc7WUFDakcsT0FBTztnQkFDSG5DLElBQUlzQyxRQUFRO2dCQUNaYjthQUNIO1FBQ0w7SUFDSjtJQUNBLE9BQU90QixxQkFBcUJDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQzVDO0FBRUEsSUFBSSxDQUFDLE9BQU9kLFFBQVFLLE9BQU8sS0FBSyxjQUFlLE9BQU9MLFFBQVFLLE9BQU8sS0FBSyxZQUFZTCxRQUFRSyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9MLFFBQVFLLE9BQU8sQ0FBQzJDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLbEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRSyxPQUFPLEVBQUUsY0FBYztRQUFFSixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT21ELE1BQU0sQ0FBQ2pELFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JrRCxPQUFPbEQsT0FBTyxHQUFHQSxRQUFRSyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9mZXRjaC1zZXJ2ZXItcmVzcG9uc2UuanM/ZmE3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mZXRjaFNlcnZlclJlc3BvbnNlID0gZmV0Y2hTZXJ2ZXJSZXNwb25zZTtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9jbGllbnQgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LXNlcnZlci1kb20td2VicGFjay9jbGllbnRcIik7XG52YXIgX2FwcFJvdXRlckhlYWRlcnMgPSByZXF1aXJlKFwiLi4vYXBwLXJvdXRlci1oZWFkZXJzXCIpO1xudmFyIF9hcHBSb3V0ZXIgPSByZXF1aXJlKFwiLi4vYXBwLXJvdXRlclwiKTtcblxuZnVuY3Rpb24gZmV0Y2hTZXJ2ZXJSZXNwb25zZSh1cmwsIGZsaWdodFJvdXRlclN0YXRlLCBwcmVmZXRjaCkge1xuICAgIHJldHVybiBfZmV0Y2hTZXJ2ZXJSZXNwb25zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2ZldGNoU2VydmVyUmVzcG9uc2UoKSB7XG4gICAgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKih1cmwsIGZsaWdodFJvdXRlclN0YXRlLCBwcmVmZXRjaCkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gRW5hYmxlIGZsaWdodCByZXNwb25zZVxuICAgICAgICAgICAgW19hcHBSb3V0ZXJIZWFkZXJzLlJTQ106ICcxJyxcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgcm91dGVyIHN0YXRlXG4gICAgICAgICAgICBbX2FwcFJvdXRlckhlYWRlcnMuTkVYVF9ST1VURVJfU1RBVEVfVFJFRV06IEpTT04uc3RyaW5naWZ5KGZsaWdodFJvdXRlclN0YXRlKVxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIC8vIEVuYWJsZSBwcmVmZXRjaCByZXNwb25zZVxuICAgICAgICAgICAgaGVhZGVyc1tfYXBwUm91dGVySGVhZGVycy5ORVhUX1JPVVRFUl9QUkVGRVRDSF0gPSAnMSc7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBmZXRjaFVybCA9IHVybDtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaFVybCA9IG5ldyBVUkwodXJsKSAvLyBjbG9uZVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFVybC5wYXRobmFtZSArPSAnaW5kZXgudHh0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZXRjaFVybC5wYXRobmFtZSArPSAnLnR4dCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzID0geWllbGQgZmV0Y2goZmV0Y2hVcmwsIHtcbiAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBvbGRlciBicm93c2Vycy4gYHNhbWUtb3JpZ2luYCBpcyB0aGUgZGVmYXVsdCBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYW5vbmljYWxVcmwgPSByZXMucmVkaXJlY3RlZCA/ICgwLCBfYXBwUm91dGVyKS51cmxUb1VybFdpdGhvdXRGbGlnaHRNYXJrZXIocmVzLnVybCkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG4gICAgICAgICAgICBsZXQgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlID09PSBfYXBwUm91dGVySGVhZGVycy5SU0NfQ09OVEVOVF9UWVBFX0hFQURFUjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ09ORklHX09VVFBVVCA9PT0gJ2V4cG9ydCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRmxpZ2h0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNGbGlnaHRSZXNwb25zZSA9IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoJ3RleHQvcGxhaW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmZXRjaCByZXR1cm5zIHNvbWV0aGluZyBkaWZmZXJlbnQgdGhhbiBmbGlnaHQgcmVzcG9uc2UgaGFuZGxlIGl0IGxpa2UgYSBtcGEgbmF2aWdhdGlvblxuICAgICAgICAgICAgaWYgKCFpc0ZsaWdodFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnVybCxcbiAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgYGZldGNoYCByZWFkYWJsZSBzdHJlYW0gdGhhdCBjYW4gYmUgdW53cmFwcGVkIGJ5IGBSZWFjdC51c2VgLlxuICAgICAgICAgICAgY29uc3QgZmxpZ2h0RGF0YSA9IHlpZWxkICgwLCBfY2xpZW50KS5jcmVhdGVGcm9tRmV0Y2goUHJvbWlzZS5yZXNvbHZlKHJlcykpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBmbGlnaHREYXRhLFxuICAgICAgICAgICAgICAgIGNhbm9uaWNhbFVybFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggUlNDIHBheWxvYWQuIEZhbGxpbmcgYmFjayB0byBicm93c2VyIG5hdmlnYXRpb24uJywgZXJyKTtcbiAgICAgICAgICAgIC8vIElmIGZldGNoIGZhaWxzIGhhbmRsZSBpdCBsaWtlIGEgbXBhIG5hdmlnYXRpb25cbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBBZGQgYSB0ZXN0IGZvciB0aGUgY2FzZSB3aGVyZSBhIENPUlMgcmVxdWVzdCBmYWlscywgZS5nLiBleHRlcm5hbCB1cmwgcmVkaXJlY3QgY29taW5nIGZyb20gdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvNDM2MDUjaXNzdWVjb21tZW50LTE0NTE2MTc1MjEgZm9yIGEgcmVwcm9kdWN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB1cmwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWRcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX2ZldGNoU2VydmVyUmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtc2VydmVyLXJlc3BvbnNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfY2xpZW50IiwiX2FwcFJvdXRlckhlYWRlcnMiLCJfYXBwUm91dGVyIiwidXJsIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJwcmVmZXRjaCIsIl9mZXRjaFNlcnZlclJlc3BvbnNlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJoZWFkZXJzIiwiUlNDIiwiTkVYVF9ST1VURVJfU1RBVEVfVFJFRSIsIkpTT04iLCJzdHJpbmdpZnkiLCJORVhUX1JPVVRFUl9QUkVGRVRDSCIsImZldGNoVXJsIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9DT05GSUdfT1VUUFVUIiwiVVJMIiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsInJlcyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJjYW5vbmljYWxVcmwiLCJyZWRpcmVjdGVkIiwidXJsVG9VcmxXaXRob3V0RmxpZ2h0TWFya2VyIiwidW5kZWZpbmVkIiwiY29udGVudFR5cGUiLCJnZXQiLCJpc0ZsaWdodFJlc3BvbnNlIiwiUlNDX0NPTlRFTlRfVFlQRV9IRUFERVIiLCJzdGFydHNXaXRoIiwiZmxpZ2h0RGF0YSIsImNyZWF0ZUZyb21GZXRjaCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwidG9TdHJpbmciLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillCacheWithDataProperty = fillCacheWithDataProperty;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction fillCacheWithDataProperty(newCache, existingCache, segments, fetchResponse) {\n    const isLastEntry = segments.length === 1;\n    const parallelRouteKey = \"children\";\n    const [segment] = segments;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return {\n            bailOptimistic: true\n        };\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segment);\n    let childCacheNode = childSegmentMap.get(segment);\n    // In case of last segment start off the fetch at this level and don't copy further down.\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Start fetch in the place where the existing cache doesn't have the data yet.\n        if (!childCacheNode) {\n            childSegmentMap.set(segment, {\n                status: _appRouterContext.CacheStates.DATA_FETCH,\n                data: fetchResponse(),\n                subTreeData: null,\n                parallelRoutes: new Map()\n            });\n        }\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segment, childCacheNode);\n    }\n    return fillCacheWithDataProperty(childCacheNode, existingChildCacheNode, segments.slice(1), fetchResponse);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-data-property.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWNhY2hlLXdpdGgtZGF0YS1wcm9wZXJ0eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxpQ0FBaUMsR0FBR0U7QUFDcEMsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQyxzSEFBd0M7QUFDeEUsU0FBU0YsMEJBQTBCRyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsUUFBUSxFQUFFQyxhQUFhLEVBQUU7SUFDakYsTUFBTUMsY0FBY0YsU0FBU0csTUFBTSxLQUFLO0lBQ3hDLE1BQU1DLG1CQUFtQjtJQUN6QixNQUFNLENBQUNDLFFBQVEsR0FBR0w7SUFDbEIsTUFBTU0sMEJBQTBCUCxjQUFjUSxjQUFjLENBQUNDLEdBQUcsQ0FBQ0o7SUFDakUsSUFBSSxDQUFDRSx5QkFBeUI7UUFDMUIsNkVBQTZFO1FBQzdFLHNFQUFzRTtRQUN0RSxPQUFPO1lBQ0hHLGdCQUFnQixJQUFJO1FBQ3hCO0lBQ0osQ0FBQztJQUNELElBQUlDLGtCQUFrQlosU0FBU1MsY0FBYyxDQUFDQyxHQUFHLENBQUNKO0lBQ2xELElBQUksQ0FBQ00sbUJBQW1CQSxvQkFBb0JKLHlCQUF5QjtRQUNqRUksa0JBQWtCLElBQUlDLElBQUlMO1FBQzFCUixTQUFTUyxjQUFjLENBQUNLLEdBQUcsQ0FBQ1Isa0JBQWtCTTtJQUNsRCxDQUFDO0lBQ0QsTUFBTUcseUJBQXlCUCx3QkFBd0JFLEdBQUcsQ0FBQ0g7SUFDM0QsSUFBSVMsaUJBQWlCSixnQkFBZ0JGLEdBQUcsQ0FBQ0g7SUFDekMseUZBQXlGO0lBQ3pGLElBQUlILGFBQWE7UUFDYixJQUFJLENBQUNZLGtCQUFrQixDQUFDQSxlQUFlQyxJQUFJLElBQUlELG1CQUFtQkQsd0JBQXdCO1lBQ3RGSCxnQkFBZ0JFLEdBQUcsQ0FBQ1AsU0FBUztnQkFDekJXLFFBQVFwQixrQkFBa0JxQixXQUFXLENBQUNDLFVBQVU7Z0JBQ2hESCxNQUFNZDtnQkFDTmtCLGFBQWEsSUFBSTtnQkFDakJaLGdCQUFnQixJQUFJSTtZQUN4QjtRQUNKLENBQUM7UUFDRDtJQUNKLENBQUM7SUFDRCxJQUFJLENBQUNHLGtCQUFrQixDQUFDRCx3QkFBd0I7UUFDNUMsK0VBQStFO1FBQy9FLElBQUksQ0FBQ0MsZ0JBQWdCO1lBQ2pCSixnQkFBZ0JFLEdBQUcsQ0FBQ1AsU0FBUztnQkFDekJXLFFBQVFwQixrQkFBa0JxQixXQUFXLENBQUNDLFVBQVU7Z0JBQ2hESCxNQUFNZDtnQkFDTmtCLGFBQWEsSUFBSTtnQkFDakJaLGdCQUFnQixJQUFJSTtZQUN4QjtRQUNKLENBQUM7UUFDRDtJQUNKLENBQUM7SUFDRCxJQUFJRyxtQkFBbUJELHdCQUF3QjtRQUMzQ0MsaUJBQWlCO1lBQ2JFLFFBQVFGLGVBQWVFLE1BQU07WUFDN0JELE1BQU1ELGVBQWVDLElBQUk7WUFDekJJLGFBQWFMLGVBQWVLLFdBQVc7WUFDdkNaLGdCQUFnQixJQUFJSSxJQUFJRyxlQUFlUCxjQUFjO1FBQ3pEO1FBQ0FHLGdCQUFnQkUsR0FBRyxDQUFDUCxTQUFTUztJQUNqQyxDQUFDO0lBQ0QsT0FBT25CLDBCQUEwQm1CLGdCQUFnQkQsd0JBQXdCYixTQUFTb0IsS0FBSyxDQUFDLElBQUluQjtBQUNoRztBQUVBLElBQUksQ0FBQyxPQUFPUixRQUFRNEIsT0FBTyxLQUFLLGNBQWUsT0FBTzVCLFFBQVE0QixPQUFPLEtBQUssWUFBWTVCLFFBQVE0QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU81QixRQUFRNEIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySy9CLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTRCLE9BQU8sRUFBRSxjQUFjO1FBQUUzQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2dDLE1BQU0sQ0FBQzlCLFFBQVE0QixPQUFPLEVBQUU1QjtJQUMvQitCLE9BQU8vQixPQUFPLEdBQUdBLFFBQVE0QixPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5REFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWNhY2hlLXdpdGgtZGF0YS1wcm9wZXJ0eS5qcz9mNTUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5ID0gZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eTtcbnZhciBfYXBwUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkobmV3Q2FjaGUsIGV4aXN0aW5nQ2FjaGUsIHNlZ21lbnRzLCBmZXRjaFJlc3BvbnNlKSB7XG4gICAgY29uc3QgaXNMYXN0RW50cnkgPSBzZWdtZW50cy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgcGFyYWxsZWxSb3V0ZUtleSA9ICdjaGlsZHJlbic7XG4gICAgY29uc3QgW3NlZ21lbnRdID0gc2VnbWVudHM7XG4gICAgY29uc3QgZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoIWV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKSB7XG4gICAgICAgIC8vIEJhaWxvdXQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgY2FjaGUgZG9lcyBub3QgaGF2ZSB0aGUgcGF0aCB0byB0aGUgbGVhZiBub2RlXG4gICAgICAgIC8vIFdpbGwgdHJpZ2dlciBsYXp5IGZldGNoIGluIGxheW91dC1yb3V0ZXIgYmVjYXVzZSBvZiBtaXNzaW5nIHNlZ21lbnRcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJhaWxPcHRpbWlzdGljOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudCk7XG4gICAgbGV0IGNoaWxkQ2FjaGVOb2RlID0gY2hpbGRTZWdtZW50TWFwLmdldChzZWdtZW50KTtcbiAgICAvLyBJbiBjYXNlIG9mIGxhc3Qgc2VnbWVudCBzdGFydCBvZmYgdGhlIGZldGNoIGF0IHRoaXMgbGV2ZWwgYW5kIGRvbid0IGNvcHkgZnVydGhlciBkb3duLlxuICAgIGlmIChpc0xhc3RFbnRyeSkge1xuICAgICAgICBpZiAoIWNoaWxkQ2FjaGVOb2RlIHx8ICFjaGlsZENhY2hlTm9kZS5kYXRhIHx8IGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnQsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLkRBVEFfRkVUQ0gsXG4gICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hSZXNwb25zZSgpLFxuICAgICAgICAgICAgICAgIHN1YlRyZWVEYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBTdGFydCBmZXRjaCBpbiB0aGUgcGxhY2Ugd2hlcmUgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXNuJ3QgaGF2ZSB0aGUgZGF0YSB5ZXQuXG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudCwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuREFUQV9GRVRDSCxcbiAgICAgICAgICAgICAgICBkYXRhOiBmZXRjaFJlc3BvbnNlKCksXG4gICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgY2hpbGRDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IGNoaWxkQ2FjaGVOb2RlLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IGNoaWxkQ2FjaGVOb2RlLmRhdGEsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogY2hpbGRDYWNoZU5vZGUuc3ViVHJlZURhdGEsXG4gICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogbmV3IE1hcChjaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLnNldChzZWdtZW50LCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBmaWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5KGNoaWxkQ2FjaGVOb2RlLCBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlLCBzZWdtZW50cy5zbGljZSgxKSwgZmV0Y2hSZXNwb25zZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGwtY2FjaGUtd2l0aC1kYXRhLXByb3BlcnR5LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkiLCJfYXBwUm91dGVyQ29udGV4dCIsInJlcXVpcmUiLCJuZXdDYWNoZSIsImV4aXN0aW5nQ2FjaGUiLCJzZWdtZW50cyIsImZldGNoUmVzcG9uc2UiLCJpc0xhc3RFbnRyeSIsImxlbmd0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJzZWdtZW50IiwiZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXAiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsImJhaWxPcHRpbWlzdGljIiwiY2hpbGRTZWdtZW50TWFwIiwiTWFwIiwic2V0IiwiZXhpc3RpbmdDaGlsZENhY2hlTm9kZSIsImNoaWxkQ2FjaGVOb2RlIiwiZGF0YSIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiREFUQV9GRVRDSCIsInN1YlRyZWVEYXRhIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js ***!
  \*****************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillCacheWithNewSubTreeData = fillCacheWithNewSubTreeData;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _invalidateCacheByRouterState = __webpack_require__(/*! ./invalidate-cache-by-router-state */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ./fill-lazy-items-till-leaf-with-head */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nfunction fillCacheWithNewSubTreeData(newCache, existingCache, flightDataPath) {\n    const isLastEntry = flightDataPath.length <= 5;\n    const [parallelRouteKey, segment] = flightDataPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (isLastEntry) {\n        if (!childCacheNode || !childCacheNode.data || childCacheNode === existingChildCacheNode) {\n            childCacheNode = {\n                status: _appRouterContext.CacheStates.READY,\n                data: null,\n                subTreeData: flightDataPath[3],\n                // Ensure segments other than the one we got data for are preserved.\n                parallelRoutes: existingChildCacheNode ? new Map(existingChildCacheNode.parallelRoutes) : new Map()\n            };\n            if (existingChildCacheNode) {\n                (0, _invalidateCacheByRouterState).invalidateCacheByRouterState(childCacheNode, existingChildCacheNode, flightDataPath[2]);\n            }\n            (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(childCacheNode, existingChildCacheNode, flightDataPath[2], flightDataPath[4]);\n            childSegmentMap.set(segmentForCache, childCacheNode);\n        }\n        return;\n    }\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    fillCacheWithNewSubTreeData(childCacheNode, existingChildCacheNode, flightDataPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-cache-with-new-subtree-data.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQ0FBbUMsR0FBR0U7QUFDdEMsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQyxzSEFBd0M7QUFDeEUsSUFBSUMsZ0NBQWdDRCxtQkFBT0EsQ0FBQyxzSkFBb0M7QUFDaEYsSUFBSUUsaUNBQWlDRixtQkFBT0EsQ0FBQyw0SkFBdUM7QUFDcEYsU0FBU0YsNEJBQTRCSyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsY0FBYyxFQUFFO0lBQzFFLE1BQU1DLGNBQWNELGVBQWVFLE1BQU0sSUFBSTtJQUM3QyxNQUFNLENBQUNDLGtCQUFrQkMsUUFBUSxHQUFHSjtJQUNwQyxNQUFNSyxrQkFBa0JDLE1BQU1DLE9BQU8sQ0FBQ0gsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTztJQUNyRSxNQUFNSSwwQkFBMEJULGNBQWNVLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtJQUNqRSxJQUFJLENBQUNLLHlCQUF5QjtRQUMxQiw2RUFBNkU7UUFDN0Usc0VBQXNFO1FBQ3RFO0lBQ0osQ0FBQztJQUNELElBQUlHLGtCQUFrQmIsU0FBU1csY0FBYyxDQUFDQyxHQUFHLENBQUNQO0lBQ2xELElBQUksQ0FBQ1EsbUJBQW1CQSxvQkFBb0JILHlCQUF5QjtRQUNqRUcsa0JBQWtCLElBQUlDLElBQUlKO1FBQzFCVixTQUFTVyxjQUFjLENBQUNJLEdBQUcsQ0FBQ1Ysa0JBQWtCUTtJQUNsRCxDQUFDO0lBQ0QsTUFBTUcseUJBQXlCTix3QkFBd0JFLEdBQUcsQ0FBQ0w7SUFDM0QsSUFBSVUsaUJBQWlCSixnQkFBZ0JELEdBQUcsQ0FBQ0w7SUFDekMsSUFBSUosYUFBYTtRQUNiLElBQUksQ0FBQ2Msa0JBQWtCLENBQUNBLGVBQWVDLElBQUksSUFBSUQsbUJBQW1CRCx3QkFBd0I7WUFDdEZDLGlCQUFpQjtnQkFDYkUsUUFBUXZCLGtCQUFrQndCLFdBQVcsQ0FBQ0MsS0FBSztnQkFDM0NILE1BQU0sSUFBSTtnQkFDVkksYUFBYXBCLGNBQWMsQ0FBQyxFQUFFO2dCQUM5QixvRUFBb0U7Z0JBQ3BFUyxnQkFBZ0JLLHlCQUF5QixJQUFJRixJQUFJRSx1QkFBdUJMLGNBQWMsSUFBSSxJQUFJRyxLQUFLO1lBQ3ZHO1lBQ0EsSUFBSUUsd0JBQXdCO2dCQUN2QixJQUFHbEIsNkJBQTZCLEVBQUV5Qiw0QkFBNEIsQ0FBQ04sZ0JBQWdCRCx3QkFBd0JkLGNBQWMsQ0FBQyxFQUFFO1lBQzdILENBQUM7WUFDQSxJQUFHSCw4QkFBOEIsRUFBRXlCLDZCQUE2QixDQUFDUCxnQkFBZ0JELHdCQUF3QmQsY0FBYyxDQUFDLEVBQUUsRUFBRUEsY0FBYyxDQUFDLEVBQUU7WUFDOUlXLGdCQUFnQkUsR0FBRyxDQUFDUixpQkFBaUJVO1FBQ3pDLENBQUM7UUFDRDtJQUNKLENBQUM7SUFDRCxJQUFJLENBQUNBLGtCQUFrQixDQUFDRCx3QkFBd0I7UUFDNUMsNkVBQTZFO1FBQzdFLHNFQUFzRTtRQUN0RTtJQUNKLENBQUM7SUFDRCxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUMzQ0MsaUJBQWlCO1lBQ2JFLFFBQVFGLGVBQWVFLE1BQU07WUFDN0JELE1BQU1ELGVBQWVDLElBQUk7WUFDekJJLGFBQWFMLGVBQWVLLFdBQVc7WUFDdkNYLGdCQUFnQixJQUFJRyxJQUFJRyxlQUFlTixjQUFjO1FBQ3pEO1FBQ0FFLGdCQUFnQkUsR0FBRyxDQUFDUixpQkFBaUJVO0lBQ3pDLENBQUM7SUFDRHRCLDRCQUE0QnNCLGdCQUFnQkQsd0JBQXdCZCxlQUFldUIsS0FBSyxDQUFDO0FBQzdGO0FBRUEsSUFBSSxDQUFDLE9BQU9oQyxRQUFRaUMsT0FBTyxLQUFLLGNBQWUsT0FBT2pDLFFBQVFpQyxPQUFPLEtBQUssWUFBWWpDLFFBQVFpQyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9qQyxRQUFRaUMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3BDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWlDLE9BQU8sRUFBRSxjQUFjO1FBQUVoQyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3FDLE1BQU0sQ0FBQ25DLFFBQVFpQyxPQUFPLEVBQUVqQztJQUMvQm9DLE9BQU9wQyxPQUFPLEdBQUdBLFFBQVFpQyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YS5qcz85ZmU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5maWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEgPSBmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGE7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2ludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUgPSByZXF1aXJlKFwiLi9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZVwiKTtcbnZhciBfZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQgPSByZXF1aXJlKFwiLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbmZ1bmN0aW9uIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodERhdGFQYXRoLmxlbmd0aCA8PSA1O1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodERhdGFQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKGlzTGFzdEVudHJ5KSB7XG4gICAgICAgIGlmICghY2hpbGRDYWNoZU5vZGUgfHwgIWNoaWxkQ2FjaGVOb2RlLmRhdGEgfHwgY2hpbGRDYWNoZU5vZGUgPT09IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFksXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBzdWJUcmVlRGF0YTogZmxpZ2h0RGF0YVBhdGhbM10sXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHNlZ21lbnRzIG90aGVyIHRoYW4gdGhlIG9uZSB3ZSBnb3QgZGF0YSBmb3IgYXJlIHByZXNlcnZlZC5cbiAgICAgICAgICAgICAgICBwYXJhbGxlbFJvdXRlczogZXhpc3RpbmdDaGlsZENhY2hlTm9kZSA/IG5ldyBNYXAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcykgOiBuZXcgTWFwKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAgICAgICAgICgwLCBfaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSkuaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGhbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIF9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCkuZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodERhdGFQYXRoWzJdLCBmbGlnaHREYXRhUGF0aFs0XSk7XG4gICAgICAgICAgICBjaGlsZFNlZ21lbnRNYXAuc2V0KHNlZ21lbnRGb3JDYWNoZSwgY2hpbGRDYWNoZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGZpbGxDYWNoZVdpdGhOZXdTdWJUcmVlRGF0YShjaGlsZENhY2hlTm9kZSwgZXhpc3RpbmdDaGlsZENhY2hlTm9kZSwgZmxpZ2h0RGF0YVBhdGguc2xpY2UoMikpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxsLWNhY2hlLXdpdGgtbmV3LXN1YnRyZWUtZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaWxsQ2FjaGVXaXRoTmV3U3ViVHJlZURhdGEiLCJfYXBwUm91dGVyQ29udGV4dCIsInJlcXVpcmUiLCJfaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsIl9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodERhdGFQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsInNlZ21lbnRGb3JDYWNoZSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJkYXRhIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJSRUFEWSIsInN1YlRyZWVEYXRhIiwiaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwic2xpY2UiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js ***!
  \********************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.fillLazyItemsTillLeafWithHead = fillLazyItemsTillLeafWithHead;\nvar _appRouterContext = __webpack_require__(/*! ../../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nfunction fillLazyItemsTillLeafWithHead(newCache, existingCache, routerState, head) {\n    const isLastSegment = Object.keys(routerState[1]).length === 0;\n    if (isLastSegment) {\n        newCache.head = head;\n        return;\n    }\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const parallelRouteState = routerState[1][key];\n        const segmentForParallelRoute = parallelRouteState[0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        if (existingCache) {\n            const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n            if (existingParallelRoutesCacheNode) {\n                let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n                const existingCacheNode = parallelRouteCacheNode.get(cacheKey);\n                parallelRouteCacheNode.delete(cacheKey);\n                const newCacheNode = {\n                    status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n                    data: null,\n                    subTreeData: null,\n                    parallelRoutes: new Map(existingCacheNode == null ? void 0 : existingCacheNode.parallelRoutes)\n                };\n                parallelRouteCacheNode.set(cacheKey, newCacheNode);\n                fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n                newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n                continue;\n            }\n        }\n        const newCacheNode = {\n            status: _appRouterContext.CacheStates.LAZY_INITIALIZED,\n            data: null,\n            subTreeData: null,\n            parallelRoutes: new Map()\n        };\n        const existingParallelRoutes = newCache.parallelRoutes.get(key);\n        if (existingParallelRoutes) {\n            existingParallelRoutes.set(cacheKey, newCacheNode);\n        } else {\n            newCache.parallelRoutes.set(key, new Map([\n                [\n                    cacheKey,\n                    newCacheNode\n                ]\n            ]));\n        }\n        fillLazyItemsTillLeafWithHead(newCacheNode, undefined, parallelRouteState, head);\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxxQ0FBcUMsR0FBR0U7QUFDeEMsSUFBSUMsb0JBQW9CQyxtQkFBT0EsQ0FBQyxzSEFBd0M7QUFDeEUsU0FBU0YsOEJBQThCRyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUU7SUFDL0UsTUFBTUMsZ0JBQWdCWCxPQUFPWSxJQUFJLENBQUNILFdBQVcsQ0FBQyxFQUFFLEVBQUVJLE1BQU0sS0FBSztJQUM3RCxJQUFJRixlQUFlO1FBQ2ZKLFNBQVNHLElBQUksR0FBR0E7UUFDaEI7SUFDSixDQUFDO0lBQ0QsK0ZBQStGO0lBQy9GLElBQUksTUFBTUksT0FBT0wsV0FBVyxDQUFDLEVBQUUsQ0FBQztRQUM1QixNQUFNTSxxQkFBcUJOLFdBQVcsQ0FBQyxFQUFFLENBQUNLLElBQUk7UUFDOUMsTUFBTUUsMEJBQTBCRCxrQkFBa0IsQ0FBQyxFQUFFO1FBQ3JELE1BQU1FLFdBQVdDLE1BQU1DLE9BQU8sQ0FBQ0gsMkJBQTJCQSx1QkFBdUIsQ0FBQyxFQUFFLEdBQUdBLHVCQUF1QjtRQUM5RyxJQUFJUixlQUFlO1lBQ2YsTUFBTVksa0NBQWtDWixjQUFjYSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1I7WUFDekUsSUFBSU0saUNBQWlDO2dCQUNqQyxJQUFJRyx5QkFBeUIsSUFBSUMsSUFBSUo7Z0JBQ3JDLE1BQU1LLG9CQUFvQkYsdUJBQXVCRCxHQUFHLENBQUNMO2dCQUNyRE0sdUJBQXVCRyxNQUFNLENBQUNUO2dCQUM5QixNQUFNVSxlQUFlO29CQUNqQkMsUUFBUXZCLGtCQUFrQndCLFdBQVcsQ0FBQ0MsZ0JBQWdCO29CQUN0REMsTUFBTSxJQUFJO29CQUNWQyxhQUFhLElBQUk7b0JBQ2pCWCxnQkFBZ0IsSUFBSUcsSUFBSUMscUJBQXFCLElBQUksR0FBRyxLQUFLLElBQUlBLGtCQUFrQkosY0FBYztnQkFDakc7Z0JBQ0FFLHVCQUF1QlUsR0FBRyxDQUFDaEIsVUFBVVU7Z0JBQ3JDdkIsOEJBQThCdUIsY0FBY08sV0FBV25CLG9CQUFvQkw7Z0JBQzNFSCxTQUFTYyxjQUFjLENBQUNZLEdBQUcsQ0FBQ25CLEtBQUtTO2dCQUNqQyxRQUFTO1lBQ2IsQ0FBQztRQUNMLENBQUM7UUFDRCxNQUFNSSxlQUFlO1lBQ2pCQyxRQUFRdkIsa0JBQWtCd0IsV0FBVyxDQUFDQyxnQkFBZ0I7WUFDdERDLE1BQU0sSUFBSTtZQUNWQyxhQUFhLElBQUk7WUFDakJYLGdCQUFnQixJQUFJRztRQUN4QjtRQUNBLE1BQU1XLHlCQUF5QjVCLFNBQVNjLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUjtRQUMzRCxJQUFJcUIsd0JBQXdCO1lBQ3hCQSx1QkFBdUJGLEdBQUcsQ0FBQ2hCLFVBQVVVO1FBQ3pDLE9BQU87WUFDSHBCLFNBQVNjLGNBQWMsQ0FBQ1ksR0FBRyxDQUFDbkIsS0FBSyxJQUFJVSxJQUFJO2dCQUNyQztvQkFDSVA7b0JBQ0FVO2lCQUNIO2FBQ0o7UUFDTCxDQUFDO1FBQ0R2Qiw4QkFBOEJ1QixjQUFjTyxXQUFXbkIsb0JBQW9CTDtJQUMvRTtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU9SLFFBQVFrQyxPQUFPLEtBQUssY0FBZSxPQUFPbEMsUUFBUWtDLE9BQU8sS0FBSyxZQUFZbEMsUUFBUWtDLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xDLFFBQVFrQyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckMsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0MsT0FBTyxFQUFFLGNBQWM7UUFBRWpDLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0MsTUFBTSxDQUFDcEMsUUFBUWtDLE9BQU8sRUFBRWxDO0lBQy9CcUMsT0FBT3JDLE9BQU8sR0FBR0EsUUFBUWtDLE9BQU87QUFDbEMsQ0FBQyxDQUVELCtEQUErRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ZpbGwtbGF6eS1pdGVtcy10aWxsLWxlYWYtd2l0aC1oZWFkLmpzPzZjOWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkID0gZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQ7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG5mdW5jdGlvbiBmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgcm91dGVyU3RhdGUsIGhlYWQpIHtcbiAgICBjb25zdCBpc0xhc3RTZWdtZW50ID0gT2JqZWN0LmtleXMocm91dGVyU3RhdGVbMV0pLmxlbmd0aCA9PT0gMDtcbiAgICBpZiAoaXNMYXN0U2VnbWVudCkge1xuICAgICAgICBuZXdDYWNoZS5oZWFkID0gaGVhZDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VnbWVudCB0aGF0IHdlIGdvdCBkYXRhIGZvciBzbyB0aGF0IGl0IGlzIGZpbGxlZCBpbiBkdXJpbmcgcmVuZGVyaW5nIG9mIHN1YlRyZWVEYXRhLlxuICAgIGZvcihjb25zdCBrZXkgaW4gcm91dGVyU3RhdGVbMV0pe1xuICAgICAgICBjb25zdCBwYXJhbGxlbFJvdXRlU3RhdGUgPSByb3V0ZXJTdGF0ZVsxXVtrZXldO1xuICAgICAgICBjb25zdCBzZWdtZW50Rm9yUGFyYWxsZWxSb3V0ZSA9IHBhcmFsbGVsUm91dGVTdGF0ZVswXTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKSA/IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlWzFdIDogc2VnbWVudEZvclBhcmFsbGVsUm91dGU7XG4gICAgICAgIGlmIChleGlzdGluZ0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlID0gZXhpc3RpbmdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFsbGVsUm91dGVDYWNoZU5vZGUgPSBuZXcgTWFwKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ2FjaGVOb2RlID0gcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViVHJlZURhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKGV4aXN0aW5nQ2FjaGVOb2RlID09IG51bGwgPyB2b2lkIDAgOiBleGlzdGluZ0NhY2hlTm9kZS5wYXJhbGxlbFJvdXRlcylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUuc2V0KGNhY2hlS2V5LCBuZXdDYWNoZU5vZGUpO1xuICAgICAgICAgICAgICAgIGZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKG5ld0NhY2hlTm9kZSwgdW5kZWZpbmVkLCBwYXJhbGxlbFJvdXRlU3RhdGUsIGhlYWQpO1xuICAgICAgICAgICAgICAgIG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLnNldChrZXksIHBhcmFsbGVsUm91dGVDYWNoZU5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NhY2hlTm9kZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuTEFaWV9JTklUSUFMSVpFRCxcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBzdWJUcmVlRGF0YTogbnVsbCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcyA9IG5ld0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlcykge1xuICAgICAgICAgICAgZXhpc3RpbmdQYXJhbGxlbFJvdXRlcy5zZXQoY2FjaGVLZXksIG5ld0NhY2hlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5zZXQoa2V5LCBuZXcgTWFwKFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICBuZXdDYWNoZU5vZGVcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbExhenlJdGVtc1RpbGxMZWFmV2l0aEhlYWQobmV3Q2FjaGVOb2RlLCB1bmRlZmluZWQsIHBhcmFsbGVsUm91dGVTdGF0ZSwgaGVhZCk7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmaWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwicmVxdWlyZSIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsInJvdXRlclN0YXRlIiwiaGVhZCIsImlzTGFzdFNlZ21lbnQiLCJrZXlzIiwibGVuZ3RoIiwia2V5IiwicGFyYWxsZWxSb3V0ZVN0YXRlIiwic2VnbWVudEZvclBhcmFsbGVsUm91dGUiLCJjYWNoZUtleSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUiLCJwYXJhbGxlbFJvdXRlcyIsImdldCIsInBhcmFsbGVsUm91dGVDYWNoZU5vZGUiLCJNYXAiLCJleGlzdGluZ0NhY2hlTm9kZSIsImRlbGV0ZSIsIm5ld0NhY2hlTm9kZSIsInN0YXR1cyIsIkNhY2hlU3RhdGVzIiwiTEFaWV9JTklUSUFMSVpFRCIsImRhdGEiLCJzdWJUcmVlRGF0YSIsInNldCIsInVuZGVmaW5lZCIsImV4aXN0aW5nUGFyYWxsZWxSb3V0ZXMiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js ***!
  \**************************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.invalidateCacheBelowFlightSegmentPath = invalidateCacheBelowFlightSegmentPath;\nfunction invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {\n    const isLastEntry = flightSegmentPath.length <= 2;\n    const [parallelRouteKey, segment] = flightSegmentPath;\n    const segmentForCache = Array.isArray(segment) ? segment[1] : segment;\n    const existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);\n    if (!existingChildSegmentMap) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n        childSegmentMap = new Map(existingChildSegmentMap);\n        newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);\n    }\n    // In case of last entry don't copy further down.\n    if (isLastEntry) {\n        childSegmentMap.delete(segmentForCache);\n        return;\n    }\n    const existingChildCacheNode = existingChildSegmentMap.get(segmentForCache);\n    let childCacheNode = childSegmentMap.get(segmentForCache);\n    if (!childCacheNode || !existingChildCacheNode) {\n        // Bailout because the existing cache does not have the path to the leaf node\n        // Will trigger lazy fetch in layout-router because of missing segment\n        return;\n    }\n    if (childCacheNode === existingChildCacheNode) {\n        childCacheNode = {\n            status: childCacheNode.status,\n            data: childCacheNode.data,\n            subTreeData: childCacheNode.subTreeData,\n            parallelRoutes: new Map(childCacheNode.parallelRoutes)\n        };\n        childSegmentMap.set(segmentForCache, childCacheNode);\n    }\n    invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, flightSegmentPath.slice(2));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJlbG93LWZsaWdodC1zZWdtZW50cGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCw2Q0FBNkMsR0FBR0U7QUFDaEQsU0FBU0Esc0NBQXNDQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsaUJBQWlCLEVBQUU7SUFDdkYsTUFBTUMsY0FBY0Qsa0JBQWtCRSxNQUFNLElBQUk7SUFDaEQsTUFBTSxDQUFDQyxrQkFBa0JDLFFBQVEsR0FBR0o7SUFDcEMsTUFBTUssa0JBQWtCQyxNQUFNQyxPQUFPLENBQUNILFdBQVdBLE9BQU8sQ0FBQyxFQUFFLEdBQUdBLE9BQU87SUFDckUsTUFBTUksMEJBQTBCVCxjQUFjVSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1A7SUFDakUsSUFBSSxDQUFDSyx5QkFBeUI7UUFDMUIsNkVBQTZFO1FBQzdFLHNFQUFzRTtRQUN0RTtJQUNKLENBQUM7SUFDRCxJQUFJRyxrQkFBa0JiLFNBQVNXLGNBQWMsQ0FBQ0MsR0FBRyxDQUFDUDtJQUNsRCxJQUFJLENBQUNRLG1CQUFtQkEsb0JBQW9CSCx5QkFBeUI7UUFDakVHLGtCQUFrQixJQUFJQyxJQUFJSjtRQUMxQlYsU0FBU1csY0FBYyxDQUFDSSxHQUFHLENBQUNWLGtCQUFrQlE7SUFDbEQsQ0FBQztJQUNELGlEQUFpRDtJQUNqRCxJQUFJVixhQUFhO1FBQ2JVLGdCQUFnQkcsTUFBTSxDQUFDVDtRQUN2QjtJQUNKLENBQUM7SUFDRCxNQUFNVSx5QkFBeUJQLHdCQUF3QkUsR0FBRyxDQUFDTDtJQUMzRCxJQUFJVyxpQkFBaUJMLGdCQUFnQkQsR0FBRyxDQUFDTDtJQUN6QyxJQUFJLENBQUNXLGtCQUFrQixDQUFDRCx3QkFBd0I7UUFDNUMsNkVBQTZFO1FBQzdFLHNFQUFzRTtRQUN0RTtJQUNKLENBQUM7SUFDRCxJQUFJQyxtQkFBbUJELHdCQUF3QjtRQUMzQ0MsaUJBQWlCO1lBQ2JDLFFBQVFELGVBQWVDLE1BQU07WUFDN0JDLE1BQU1GLGVBQWVFLElBQUk7WUFDekJDLGFBQWFILGVBQWVHLFdBQVc7WUFDdkNWLGdCQUFnQixJQUFJRyxJQUFJSSxlQUFlUCxjQUFjO1FBQ3pEO1FBQ0FFLGdCQUFnQkUsR0FBRyxDQUFDUixpQkFBaUJXO0lBQ3pDLENBQUM7SUFDRG5CLHNDQUFzQ21CLGdCQUFnQkQsd0JBQXdCZixrQkFBa0JvQixLQUFLLENBQUM7QUFDMUc7QUFFQSxJQUFJLENBQUMsT0FBT3pCLFFBQVEwQixPQUFPLEtBQUssY0FBZSxPQUFPMUIsUUFBUTBCLE9BQU8sS0FBSyxZQUFZMUIsUUFBUTBCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzFCLFFBQVEwQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLN0IsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMEIsT0FBTyxFQUFFLGNBQWM7UUFBRXpCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPOEIsTUFBTSxDQUFDNUIsUUFBUTBCLE9BQU8sRUFBRTFCO0lBQy9CNkIsT0FBTzdCLE9BQU8sR0FBR0EsUUFBUTBCLE9BQU87QUFDbEMsQ0FBQyxDQUVELHFFQUFxRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoLmpzPzhmZTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGggPSBpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoO1xuZnVuY3Rpb24gaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChuZXdDYWNoZSwgZXhpc3RpbmdDYWNoZSwgZmxpZ2h0U2VnbWVudFBhdGgpIHtcbiAgICBjb25zdCBpc0xhc3RFbnRyeSA9IGZsaWdodFNlZ21lbnRQYXRoLmxlbmd0aCA8PSAyO1xuICAgIGNvbnN0IFtwYXJhbGxlbFJvdXRlS2V5LCBzZWdtZW50XSA9IGZsaWdodFNlZ21lbnRQYXRoO1xuICAgIGNvbnN0IHNlZ21lbnRGb3JDYWNoZSA9IEFycmF5LmlzQXJyYXkoc2VnbWVudCkgPyBzZWdtZW50WzFdIDogc2VnbWVudDtcbiAgICBjb25zdCBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCA9IGV4aXN0aW5nQ2FjaGUucGFyYWxsZWxSb3V0ZXMuZ2V0KHBhcmFsbGVsUm91dGVLZXkpO1xuICAgIGlmICghZXhpc3RpbmdDaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgLy8gQmFpbG91dCBiZWNhdXNlIHRoZSBleGlzdGluZyBjYWNoZSBkb2VzIG5vdCBoYXZlIHRoZSBwYXRoIHRvIHRoZSBsZWFmIG5vZGVcbiAgICAgICAgLy8gV2lsbCB0cmlnZ2VyIGxhenkgZmV0Y2ggaW4gbGF5b3V0LXJvdXRlciBiZWNhdXNlIG9mIG1pc3Npbmcgc2VnbWVudFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjaGlsZFNlZ21lbnRNYXAgPSBuZXdDYWNoZS5wYXJhbGxlbFJvdXRlcy5nZXQocGFyYWxsZWxSb3V0ZUtleSk7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXAgfHwgY2hpbGRTZWdtZW50TWFwID09PSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcCkge1xuICAgICAgICBjaGlsZFNlZ21lbnRNYXAgPSBuZXcgTWFwKGV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwKTtcbiAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KHBhcmFsbGVsUm91dGVLZXksIGNoaWxkU2VnbWVudE1hcCk7XG4gICAgfVxuICAgIC8vIEluIGNhc2Ugb2YgbGFzdCBlbnRyeSBkb24ndCBjb3B5IGZ1cnRoZXIgZG93bi5cbiAgICBpZiAoaXNMYXN0RW50cnkpIHtcbiAgICAgICAgY2hpbGRTZWdtZW50TWFwLmRlbGV0ZShzZWdtZW50Rm9yQ2FjaGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUgPSBleGlzdGluZ0NoaWxkU2VnbWVudE1hcC5nZXQoc2VnbWVudEZvckNhY2hlKTtcbiAgICBsZXQgY2hpbGRDYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KHNlZ21lbnRGb3JDYWNoZSk7XG4gICAgaWYgKCFjaGlsZENhY2hlTm9kZSB8fCAhZXhpc3RpbmdDaGlsZENhY2hlTm9kZSkge1xuICAgICAgICAvLyBCYWlsb3V0IGJlY2F1c2UgdGhlIGV4aXN0aW5nIGNhY2hlIGRvZXMgbm90IGhhdmUgdGhlIHBhdGggdG8gdGhlIGxlYWYgbm9kZVxuICAgICAgICAvLyBXaWxsIHRyaWdnZXIgbGF6eSBmZXRjaCBpbiBsYXlvdXQtcm91dGVyIGJlY2F1c2Ugb2YgbWlzc2luZyBzZWdtZW50XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoaWxkQ2FjaGVOb2RlID09PSBleGlzdGluZ0NoaWxkQ2FjaGVOb2RlKSB7XG4gICAgICAgIGNoaWxkQ2FjaGVOb2RlID0ge1xuICAgICAgICAgICAgc3RhdHVzOiBjaGlsZENhY2hlTm9kZS5zdGF0dXMsXG4gICAgICAgICAgICBkYXRhOiBjaGlsZENhY2hlTm9kZS5kYXRhLFxuICAgICAgICAgICAgc3ViVHJlZURhdGE6IGNoaWxkQ2FjaGVOb2RlLnN1YlRyZWVEYXRhLFxuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXM6IG5ldyBNYXAoY2hpbGRDYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMpXG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU2VnbWVudE1hcC5zZXQoc2VnbWVudEZvckNhY2hlLCBjaGlsZENhY2hlTm9kZSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVDYWNoZUJlbG93RmxpZ2h0U2VnbWVudFBhdGgoY2hpbGRDYWNoZU5vZGUsIGV4aXN0aW5nQ2hpbGRDYWNoZU5vZGUsIGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52YWxpZGF0ZS1jYWNoZS1iZWxvdy1mbGlnaHQtc2VnbWVudHBhdGguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aCIsIm5ld0NhY2hlIiwiZXhpc3RpbmdDYWNoZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiaXNMYXN0RW50cnkiLCJsZW5ndGgiLCJwYXJhbGxlbFJvdXRlS2V5Iiwic2VnbWVudCIsInNlZ21lbnRGb3JDYWNoZSIsIkFycmF5IiwiaXNBcnJheSIsImV4aXN0aW5nQ2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJjaGlsZFNlZ21lbnRNYXAiLCJNYXAiLCJzZXQiLCJkZWxldGUiLCJleGlzdGluZ0NoaWxkQ2FjaGVOb2RlIiwiY2hpbGRDYWNoZU5vZGUiLCJzdGF0dXMiLCJkYXRhIiwic3ViVHJlZURhdGEiLCJzbGljZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js ***!
  \*****************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.invalidateCacheByRouterState = invalidateCacheByRouterState;\nfunction invalidateCacheByRouterState(newCache, existingCache, routerState) {\n    // Remove segment that we got data for so that it is filled in during rendering of subTreeData.\n    for(const key in routerState[1]){\n        const segmentForParallelRoute = routerState[1][key][0];\n        const cacheKey = Array.isArray(segmentForParallelRoute) ? segmentForParallelRoute[1] : segmentForParallelRoute;\n        const existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);\n        if (existingParallelRoutesCacheNode) {\n            let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode);\n            parallelRouteCacheNode.delete(cacheKey);\n            newCache.parallelRoutes.set(key, parallelRouteCacheNode);\n        }\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=invalidate-cache-by-router-state.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pbnZhbGlkYXRlLWNhY2hlLWJ5LXJvdXRlci1zdGF0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxvQ0FBb0MsR0FBR0U7QUFDdkMsU0FBU0EsNkJBQTZCQyxRQUFRLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFO0lBQ3hFLCtGQUErRjtJQUMvRixJQUFJLE1BQU1DLE9BQU9ELFdBQVcsQ0FBQyxFQUFFLENBQUM7UUFDNUIsTUFBTUUsMEJBQTBCRixXQUFXLENBQUMsRUFBRSxDQUFDQyxJQUFJLENBQUMsRUFBRTtRQUN0RCxNQUFNRSxXQUFXQyxNQUFNQyxPQUFPLENBQUNILDJCQUEyQkEsdUJBQXVCLENBQUMsRUFBRSxHQUFHQSx1QkFBdUI7UUFDOUcsTUFBTUksa0NBQWtDUCxjQUFjUSxjQUFjLENBQUNDLEdBQUcsQ0FBQ1A7UUFDekUsSUFBSUssaUNBQWlDO1lBQ2pDLElBQUlHLHlCQUF5QixJQUFJQyxJQUFJSjtZQUNyQ0csdUJBQXVCRSxNQUFNLENBQUNSO1lBQzlCTCxTQUFTUyxjQUFjLENBQUNLLEdBQUcsQ0FBQ1gsS0FBS1E7UUFDckMsQ0FBQztJQUNMO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT2QsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQsNERBQTREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvaW52YWxpZGF0ZS1jYWNoZS1ieS1yb3V0ZXItc3RhdGUuanM/MDY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaW52YWxpZGF0ZUNhY2hlQnlSb3V0ZXJTdGF0ZSA9IGludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGU7XG5mdW5jdGlvbiBpbnZhbGlkYXRlQ2FjaGVCeVJvdXRlclN0YXRlKG5ld0NhY2hlLCBleGlzdGluZ0NhY2hlLCByb3V0ZXJTdGF0ZSkge1xuICAgIC8vIFJlbW92ZSBzZWdtZW50IHRoYXQgd2UgZ290IGRhdGEgZm9yIHNvIHRoYXQgaXQgaXMgZmlsbGVkIGluIGR1cmluZyByZW5kZXJpbmcgb2Ygc3ViVHJlZURhdGEuXG4gICAgZm9yKGNvbnN0IGtleSBpbiByb3V0ZXJTdGF0ZVsxXSl7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlID0gcm91dGVyU3RhdGVbMV1ba2V5XVswXTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBBcnJheS5pc0FycmF5KHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlKSA/IHNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlWzFdIDogc2VnbWVudEZvclBhcmFsbGVsUm91dGU7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUgPSBleGlzdGluZ0NhY2hlLnBhcmFsbGVsUm91dGVzLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdQYXJhbGxlbFJvdXRlc0NhY2hlTm9kZSkge1xuICAgICAgICAgICAgbGV0IHBhcmFsbGVsUm91dGVDYWNoZU5vZGUgPSBuZXcgTWFwKGV4aXN0aW5nUGFyYWxsZWxSb3V0ZXNDYWNoZU5vZGUpO1xuICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZS5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICAgICAgbmV3Q2FjaGUucGFyYWxsZWxSb3V0ZXMuc2V0KGtleSwgcGFyYWxsZWxSb3V0ZUNhY2hlTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludmFsaWRhdGUtY2FjaGUtYnktcm91dGVyLXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImludmFsaWRhdGVDYWNoZUJ5Um91dGVyU3RhdGUiLCJuZXdDYWNoZSIsImV4aXN0aW5nQ2FjaGUiLCJyb3V0ZXJTdGF0ZSIsImtleSIsInNlZ21lbnRGb3JQYXJhbGxlbFJvdXRlIiwiY2FjaGVLZXkiLCJBcnJheSIsImlzQXJyYXkiLCJleGlzdGluZ1BhcmFsbGVsUm91dGVzQ2FjaGVOb2RlIiwicGFyYWxsZWxSb3V0ZXMiLCJnZXQiLCJwYXJhbGxlbFJvdXRlQ2FjaGVOb2RlIiwiTWFwIiwiZGVsZXRlIiwic2V0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js ***!
  \*****************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isNavigatingToNewRootLayout = isNavigatingToNewRootLayout;\nfunction isNavigatingToNewRootLayout(currentTree, nextTree) {\n    // Compare segments\n    const currentTreeSegment = currentTree[0];\n    const nextTreeSegment = nextTree[0];\n    // If any segment is different before we find the root layout, the root layout has changed.\n    // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n    // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n    if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n        // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n        // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n        if (currentTreeSegment[0] !== nextTreeSegment[0] || currentTreeSegment[2] !== nextTreeSegment[2]) {\n            return true;\n        }\n    } else if (currentTreeSegment !== nextTreeSegment) {\n        return true;\n    }\n    // Current tree root layout found\n    if (currentTree[4]) {\n        // If the next tree doesn't have the root layout flag, it must have changed.\n        return !nextTree[4];\n    }\n    // Current tree  didn't have its root layout here, must have changed.\n    if (nextTree[4]) {\n        return true;\n    }\n    // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n    // But it's not possible to be more than one parallelRoutes before the root layout is found\n    // TODO-APP: change to traverse all parallel routes\n    const currentTreeChild = Object.values(currentTree[1])[0];\n    const nextTreeChild = Object.values(nextTree[1])[0];\n    if (!currentTreeChild || !nextTreeChild) return true;\n    return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=is-navigating-to-new-root-layout.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQ0FBbUMsR0FBR0U7QUFDdEMsU0FBU0EsNEJBQTRCQyxXQUFXLEVBQUVDLFFBQVEsRUFBRTtJQUN4RCxtQkFBbUI7SUFDbkIsTUFBTUMscUJBQXFCRixXQUFXLENBQUMsRUFBRTtJQUN6QyxNQUFNRyxrQkFBa0JGLFFBQVEsQ0FBQyxFQUFFO0lBQ25DLDJGQUEyRjtJQUMzRiw0REFBNEQ7SUFDNUQsdUlBQXVJO0lBQ3ZJLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0gsdUJBQXVCRSxNQUFNQyxPQUFPLENBQUNGLGtCQUFrQjtRQUNyRSxzSEFBc0g7UUFDdEgsdUdBQXVHO1FBQ3ZHLElBQUlELGtCQUFrQixDQUFDLEVBQUUsS0FBS0MsZUFBZSxDQUFDLEVBQUUsSUFBSUQsa0JBQWtCLENBQUMsRUFBRSxLQUFLQyxlQUFlLENBQUMsRUFBRSxFQUFFO1lBQzlGLE9BQU8sSUFBSTtRQUNmLENBQUM7SUFDTCxPQUFPLElBQUlELHVCQUF1QkMsaUJBQWlCO1FBQy9DLE9BQU8sSUFBSTtJQUNmLENBQUM7SUFDRCxpQ0FBaUM7SUFDakMsSUFBSUgsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUNoQiw0RUFBNEU7UUFDNUUsT0FBTyxDQUFDQyxRQUFRLENBQUMsRUFBRTtJQUN2QixDQUFDO0lBQ0QscUVBQXFFO0lBQ3JFLElBQUlBLFFBQVEsQ0FBQyxFQUFFLEVBQUU7UUFDYixPQUFPLElBQUk7SUFDZixDQUFDO0lBQ0QsNEdBQTRHO0lBQzVHLDJGQUEyRjtJQUMzRixtREFBbUQ7SUFDbkQsTUFBTUssbUJBQW1CWCxPQUFPWSxNQUFNLENBQUNQLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFO0lBQ3pELE1BQU1RLGdCQUFnQmIsT0FBT1ksTUFBTSxDQUFDTixRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtJQUNuRCxJQUFJLENBQUNLLG9CQUFvQixDQUFDRSxlQUFlLE9BQU8sSUFBSTtJQUNwRCxPQUFPVCw0QkFBNEJPLGtCQUFrQkU7QUFDekQ7QUFFQSxJQUFJLENBQUMsT0FBT1gsUUFBUVksT0FBTyxLQUFLLGNBQWUsT0FBT1osUUFBUVksT0FBTyxLQUFLLFlBQVlaLFFBQVFZLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1osUUFBUVksT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRWSxPQUFPLEVBQUUsY0FBYztRQUFFWCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2dCLE1BQU0sQ0FBQ2QsUUFBUVksT0FBTyxFQUFFWjtJQUMvQmUsT0FBT2YsT0FBTyxHQUFHQSxRQUFRWSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0REFBNEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcz9jYzU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgPSBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQ7XG5mdW5jdGlvbiBpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoY3VycmVudFRyZWUsIG5leHRUcmVlKSB7XG4gICAgLy8gQ29tcGFyZSBzZWdtZW50c1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlU2VnbWVudCA9IGN1cnJlbnRUcmVlWzBdO1xuICAgIGNvbnN0IG5leHRUcmVlU2VnbWVudCA9IG5leHRUcmVlWzBdO1xuICAgIC8vIElmIGFueSBzZWdtZW50IGlzIGRpZmZlcmVudCBiZWZvcmUgd2UgZmluZCB0aGUgcm9vdCBsYXlvdXQsIHRoZSByb290IGxheW91dCBoYXMgY2hhbmdlZC5cbiAgICAvLyBFLmcuIC9zYW1lLyhncm91cDEpL2xheW91dC5qcyAtPiAvc2FtZS8oZ3JvdXAyKS9sYXlvdXQuanNcbiAgICAvLyBGaXJzdCBzZWdtZW50IGlzICdzYW1lJyBmb3IgYm90aCwga2VlcCBsb29raW5nLiAoZ3JvdXAxKSBjaGFuZ2VkIHRvIChncm91cDIpIGJlZm9yZSB0aGUgcm9vdCBsYXlvdXQgd2FzIGZvdW5kLCBpdCBtdXN0IGhhdmUgY2hhbmdlZC5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VHJlZVNlZ21lbnQpICYmIEFycmF5LmlzQXJyYXkobmV4dFRyZWVTZWdtZW50KSkge1xuICAgICAgICAvLyBDb21wYXJlIGR5bmFtaWMgcGFyYW0gbmFtZSBhbmQgdHlwZSBidXQgaWdub3JlIHRoZSB2YWx1ZSwgZGlmZmVyZW50IHZhbHVlcyB3b3VsZCBub3QgYWZmZWN0IHRoZSBjdXJyZW50IHJvb3QgbGF5b3V0XG4gICAgICAgIC8vIC9bbmFtZV0gLSAvc2x1ZzEgYW5kIC9zbHVnMiwgYm90aCB2YWx1ZXMgKHNsdWcxICYgc2x1ZzIpIHN0aWxsIGhhcyB0aGUgc2FtZSBsYXlvdXQgL1tuYW1lXS9sYXlvdXQuanNcbiAgICAgICAgaWYgKGN1cnJlbnRUcmVlU2VnbWVudFswXSAhPT0gbmV4dFRyZWVTZWdtZW50WzBdIHx8IGN1cnJlbnRUcmVlU2VnbWVudFsyXSAhPT0gbmV4dFRyZWVTZWdtZW50WzJdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudFRyZWVTZWdtZW50ICE9PSBuZXh0VHJlZVNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSByb290IGxheW91dCBmb3VuZFxuICAgIGlmIChjdXJyZW50VHJlZVs0XSkge1xuICAgICAgICAvLyBJZiB0aGUgbmV4dCB0cmVlIGRvZXNuJ3QgaGF2ZSB0aGUgcm9vdCBsYXlvdXQgZmxhZywgaXQgbXVzdCBoYXZlIGNoYW5nZWQuXG4gICAgICAgIHJldHVybiAhbmV4dFRyZWVbNF07XG4gICAgfVxuICAgIC8vIEN1cnJlbnQgdHJlZSAgZGlkbid0IGhhdmUgaXRzIHJvb3QgbGF5b3V0IGhlcmUsIG11c3QgaGF2ZSBjaGFuZ2VkLlxuICAgIGlmIChuZXh0VHJlZVs0XSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gV2UgY2FuJ3QgYXNzdW1lIGl0J3MgYHBhcmFsbGVsUm91dGVzLmNoaWxkcmVuYCBoZXJlIGluIGNhc2UgdGhlIHJvb3QgbGF5b3V0IGlzIGBhcHAvQHNvbWV0aGluZy9sYXlvdXQuanNgXG4gICAgLy8gQnV0IGl0J3Mgbm90IHBvc3NpYmxlIHRvIGJlIG1vcmUgdGhhbiBvbmUgcGFyYWxsZWxSb3V0ZXMgYmVmb3JlIHRoZSByb290IGxheW91dCBpcyBmb3VuZFxuICAgIC8vIFRPRE8tQVBQOiBjaGFuZ2UgdG8gdHJhdmVyc2UgYWxsIHBhcmFsbGVsIHJvdXRlc1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlQ2hpbGQgPSBPYmplY3QudmFsdWVzKGN1cnJlbnRUcmVlWzFdKVswXTtcbiAgICBjb25zdCBuZXh0VHJlZUNoaWxkID0gT2JqZWN0LnZhbHVlcyhuZXh0VHJlZVsxXSlbMF07XG4gICAgaWYgKCFjdXJyZW50VHJlZUNoaWxkIHx8ICFuZXh0VHJlZUNoaWxkKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KGN1cnJlbnRUcmVlQ2hpbGQsIG5leHRUcmVlQ2hpbGQpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjdXJyZW50VHJlZSIsIm5leHRUcmVlIiwiY3VycmVudFRyZWVTZWdtZW50IiwibmV4dFRyZWVTZWdtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiY3VycmVudFRyZWVDaGlsZCIsInZhbHVlcyIsIm5leHRUcmVlQ2hpbGQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/read-record-value.js ***!
  \**************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.readRecordValue = readRecordValue;\nfunction readRecordValue(thenable) {\n    // @ts-expect-error TODO: fix type\n    if (thenable.status === \"fulfilled\") {\n        // @ts-expect-error TODO: fix type\n        return thenable.value;\n    } else {\n        throw thenable;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=read-record-value.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWFkLXJlY29yZC12YWx1ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0U7QUFDMUIsU0FBU0EsZ0JBQWdCQyxRQUFRLEVBQUU7SUFDL0Isa0NBQWtDO0lBQ2xDLElBQUlBLFNBQVNDLE1BQU0sS0FBSyxhQUFhO1FBQ2pDLGtDQUFrQztRQUNsQyxPQUFPRCxTQUFTRixLQUFLO0lBQ3pCLE9BQU87UUFDSCxNQUFNRSxTQUFTO0lBQ25CLENBQUM7QUFDTDtBQUVBLElBQUksQ0FBQyxPQUFPSCxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLUixPQUFPQyxjQUFjLENBQUNDLFFBQVFLLE9BQU8sRUFBRSxjQUFjO1FBQUVKLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPUyxNQUFNLENBQUNQLFFBQVFLLE9BQU8sRUFBRUw7SUFDL0JRLE9BQU9SLE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsNkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVhZC1yZWNvcmQtdmFsdWUuanM/ZTdjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVhZFJlY29yZFZhbHVlID0gcmVhZFJlY29yZFZhbHVlO1xuZnVuY3Rpb24gcmVhZFJlY29yZFZhbHVlKHRoZW5hYmxlKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoZW5hYmxlO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhZC1yZWNvcmQtdmFsdWUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVhZFJlY29yZFZhbHVlIiwidGhlbmFibGUiLCJzdGF0dXMiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js ***!
  \************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.findHeadInCache = findHeadInCache;\nfunction findHeadInCache(childSegmentMap, parallelRoutes) {\n    if (!childSegmentMap) {\n        return undefined;\n    }\n    for(const key in parallelRoutes){\n        const [segment, childParallelRoutes] = parallelRoutes[key];\n        const isLastItem = Object.keys(childParallelRoutes).length === 0;\n        const cacheKey = Array.isArray(segment) ? segment[1] : segment;\n        const cacheNode = childSegmentMap.get(cacheKey);\n        if (!cacheNode) {\n            continue;\n        }\n        if (isLastItem && cacheNode.head) return cacheNode.head;\n        const segmentMap = cacheNode.parallelRoutes.get(key);\n        if (segmentMap) {\n            const item = findHeadInCache(segmentMap, childParallelRoutes);\n            if (item) {\n                return item;\n            }\n        }\n    }\n    return undefined;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=find-head-in-cache.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9maW5kLWhlYWQtaW4tY2FjaGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLFNBQVNBLGdCQUFnQkMsZUFBZSxFQUFFQyxjQUFjLEVBQUU7SUFDdEQsSUFBSSxDQUFDRCxpQkFBaUI7UUFDbEIsT0FBT0U7SUFDWCxDQUFDO0lBQ0QsSUFBSSxNQUFNQyxPQUFPRixlQUFlO1FBQzVCLE1BQU0sQ0FBQ0csU0FBU0Msb0JBQW9CLEdBQUdKLGNBQWMsQ0FBQ0UsSUFBSTtRQUMxRCxNQUFNRyxhQUFhWCxPQUFPWSxJQUFJLENBQUNGLHFCQUFxQkcsTUFBTSxLQUFLO1FBQy9ELE1BQU1DLFdBQVdDLE1BQU1DLE9BQU8sQ0FBQ1AsV0FBV0EsT0FBTyxDQUFDLEVBQUUsR0FBR0EsT0FBTztRQUM5RCxNQUFNUSxZQUFZWixnQkFBZ0JhLEdBQUcsQ0FBQ0o7UUFDdEMsSUFBSSxDQUFDRyxXQUFXO1lBQ1osUUFBUztRQUNiLENBQUM7UUFDRCxJQUFJTixjQUFjTSxVQUFVRSxJQUFJLEVBQUUsT0FBT0YsVUFBVUUsSUFBSTtRQUN2RCxNQUFNQyxhQUFhSCxVQUFVWCxjQUFjLENBQUNZLEdBQUcsQ0FBQ1Y7UUFDaEQsSUFBSVksWUFBWTtZQUNaLE1BQU1DLE9BQU9qQixnQkFBZ0JnQixZQUFZVjtZQUN6QyxJQUFJVyxNQUFNO2dCQUNOLE9BQU9BO1lBQ1gsQ0FBQztRQUNMLENBQUM7SUFDTDtJQUNBLE9BQU9kO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUW9CLE9BQU8sS0FBSyxjQUFlLE9BQU9wQixRQUFRb0IsT0FBTyxLQUFLLFlBQVlwQixRQUFRb0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPcEIsUUFBUW9CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt2QixPQUFPQyxjQUFjLENBQUNDLFFBQVFvQixPQUFPLEVBQUUsY0FBYztRQUFFbkIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU93QixNQUFNLENBQUN0QixRQUFRb0IsT0FBTyxFQUFFcEI7SUFDL0J1QixPQUFPdkIsT0FBTyxHQUFHQSxRQUFRb0IsT0FBTztBQUNsQyxDQUFDLENBRUQsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZmluZC1oZWFkLWluLWNhY2hlLmpzPzc1YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmRIZWFkSW5DYWNoZSA9IGZpbmRIZWFkSW5DYWNoZTtcbmZ1bmN0aW9uIGZpbmRIZWFkSW5DYWNoZShjaGlsZFNlZ21lbnRNYXAsIHBhcmFsbGVsUm91dGVzKSB7XG4gICAgaWYgKCFjaGlsZFNlZ21lbnRNYXApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yKGNvbnN0IGtleSBpbiBwYXJhbGxlbFJvdXRlcyl7XG4gICAgICAgIGNvbnN0IFtzZWdtZW50LCBjaGlsZFBhcmFsbGVsUm91dGVzXSA9IHBhcmFsbGVsUm91dGVzW2tleV07XG4gICAgICAgIGNvbnN0IGlzTGFzdEl0ZW0gPSBPYmplY3Qua2V5cyhjaGlsZFBhcmFsbGVsUm91dGVzKS5sZW5ndGggPT09IDA7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gQXJyYXkuaXNBcnJheShzZWdtZW50KSA/IHNlZ21lbnRbMV0gOiBzZWdtZW50O1xuICAgICAgICBjb25zdCBjYWNoZU5vZGUgPSBjaGlsZFNlZ21lbnRNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFjYWNoZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhc3RJdGVtICYmIGNhY2hlTm9kZS5oZWFkKSByZXR1cm4gY2FjaGVOb2RlLmhlYWQ7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNYXAgPSBjYWNoZU5vZGUucGFyYWxsZWxSb3V0ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChzZWdtZW50TWFwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZmluZEhlYWRJbkNhY2hlKHNlZ21lbnRNYXAsIGNoaWxkUGFyYWxsZWxSb3V0ZXMpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kLWhlYWQtaW4tY2FjaGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZmluZEhlYWRJbkNhY2hlIiwiY2hpbGRTZWdtZW50TWFwIiwicGFyYWxsZWxSb3V0ZXMiLCJ1bmRlZmluZWQiLCJrZXkiLCJzZWdtZW50IiwiY2hpbGRQYXJhbGxlbFJvdXRlcyIsImlzTGFzdEl0ZW0iLCJrZXlzIiwibGVuZ3RoIiwiY2FjaGVLZXkiLCJBcnJheSIsImlzQXJyYXkiLCJjYWNoZU5vZGUiLCJnZXQiLCJoZWFkIiwic2VnbWVudE1hcCIsIml0ZW0iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js ***!
  \**********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleMutable = handleMutable;\nexports.applyFlightData = applyFlightData;\nexports.handleExternalUrl = handleExternalUrl;\nexports.navigateReducer = navigateReducer;\nvar _appRouterContext = __webpack_require__(/*! ../../../../shared/lib/app-router-context */ \"(app-client)/./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _fetchServerResponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _createRecordFromThenable = __webpack_require__(/*! ../create-record-from-thenable */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\");\nvar _readRecordValue = __webpack_require__(/*! ../read-record-value */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _fillLazyItemsTillLeafWithHead = __webpack_require__(/*! ../fill-lazy-items-till-leaf-with-head */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js\");\nvar _fillCacheWithNewSubtreeData = __webpack_require__(/*! ../fill-cache-with-new-subtree-data */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js\");\nvar _invalidateCacheBelowFlightSegmentpath = __webpack_require__(/*! ../invalidate-cache-below-flight-segmentpath */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js\");\nvar _fillCacheWithDataProperty = __webpack_require__(/*! ../fill-cache-with-data-property */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fill-cache-with-data-property.js\");\nvar _createOptimisticTree = __webpack_require__(/*! ../create-optimistic-tree */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-optimistic-tree.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _shouldHardNavigate = __webpack_require__(/*! ../should-hard-navigate */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nfunction handleMutable(state, mutable) {\n    return {\n        // Set href.\n        canonicalUrl: typeof mutable.canonicalUrl !== \"undefined\" ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,\n        pushRef: {\n            pendingPush: typeof mutable.pendingPush !== \"undefined\" ? mutable.pendingPush : state.pushRef.pendingPush,\n            mpaNavigation: typeof mutable.mpaNavigation !== \"undefined\" ? mutable.mpaNavigation : state.pushRef.mpaNavigation\n        },\n        // All navigation requires scroll and focus management to trigger.\n        focusAndScrollRef: {\n            apply: typeof mutable.applyFocusAndScroll !== \"undefined\" ? mutable.applyFocusAndScroll : state.focusAndScrollRef.apply,\n            hashFragment: // #top is handled in layout-router.\n            mutable.hashFragment && mutable.hashFragment !== \"\" ? decodeURIComponent(mutable.hashFragment.slice(1)) : null\n        },\n        // Apply cache.\n        cache: mutable.cache ? mutable.cache : state.cache,\n        prefetchCache: state.prefetchCache,\n        // Apply patched router state.\n        tree: typeof mutable.patchedTree !== \"undefined\" ? mutable.patchedTree : state.tree\n    };\n}\nfunction applyFlightData(state, cache, flightDataPath) {\n    // The one before last item is the router state tree patch\n    const [treePatch, subTreeData, head] = flightDataPath.slice(-3);\n    // Handles case where prefetch only returns the router tree patch without rendered components.\n    if (subTreeData === null) {\n        return false;\n    }\n    if (flightDataPath.length === 3) {\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = subTreeData;\n        (0, _fillLazyItemsTillLeafWithHead).fillLazyItemsTillLeafWithHead(cache, state.cache, treePatch, head);\n    } else {\n        // Copy subTreeData for the root node of the cache.\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = state.cache.subTreeData;\n        // Create a copy of the existing cache with the subTreeData applied.\n        (0, _fillCacheWithNewSubtreeData).fillCacheWithNewSubTreeData(cache, state.cache, flightDataPath);\n    }\n    return true;\n}\nfunction handleExternalUrl(state, mutable, url, pendingPush) {\n    mutable.previousTree = state.tree;\n    mutable.mpaNavigation = true;\n    mutable.canonicalUrl = url;\n    mutable.pendingPush = pendingPush;\n    mutable.applyFocusAndScroll = false;\n    return handleMutable(state, mutable);\n}\nfunction navigateReducer(state, action) {\n    const { url , isExternalUrl , locationSearch , navigateType , cache , mutable , forceOptimisticNavigation  } = action;\n    const { pathname , search , hash  } = url;\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    const pendingPush = navigateType === \"push\";\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return handleMutable(state, mutable);\n    }\n    if (isExternalUrl) {\n        return handleExternalUrl(state, mutable, url.toString(), pendingPush);\n    }\n    const prefetchValues = state.prefetchCache.get(href);\n    if (prefetchValues) {\n        // The one before last item is the router state tree patch\n        const { flightData , tree: newTree , canonicalUrlOverride  } = prefetchValues;\n        // Handle case when navigating to page in `pages` from `app`\n        if (typeof flightData === \"string\") {\n            return handleExternalUrl(state, mutable, flightData, pendingPush);\n        }\n        if (newTree !== null) {\n            if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n                return handleExternalUrl(state, mutable, href, pendingPush);\n            }\n            // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n            const flightDataPath = flightData[0];\n            const flightSegmentPath = flightDataPath.slice(0, -3);\n            const applied = applyFlightData(state, cache, flightDataPath);\n            const hardNavigate = search !== locationSearch || (0, _shouldHardNavigate).shouldHardNavigate([\n                \"\",\n                ...flightSegmentPath\n            ], state.tree);\n            if (hardNavigate) {\n                cache.status = _appRouterContext.CacheStates.READY;\n                // Copy subTreeData for the root node of the cache.\n                cache.subTreeData = state.cache.subTreeData;\n                (0, _invalidateCacheBelowFlightSegmentpath).invalidateCacheBelowFlightSegmentPath(cache, state.cache, flightSegmentPath);\n                // Ensure the existing cache value is used when the cache was not invalidated.\n                mutable.cache = cache;\n            } else if (applied) {\n                mutable.cache = cache;\n            }\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = newTree;\n            mutable.applyFocusAndScroll = true;\n            mutable.canonicalUrl = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : href;\n            mutable.pendingPush = pendingPush;\n            mutable.hashFragment = hash;\n            return handleMutable(state, mutable);\n        }\n    }\n    // When doing a hard push there can be two cases: with optimistic tree and without\n    // The with optimistic tree case only happens when the layouts have a loading state (loading.js)\n    // The without optimistic tree case happens when there is no loading state, in that case we suspend in this reducer\n    // forceOptimisticNavigation is used for links that have `prefetch={false}`.\n    if (forceOptimisticNavigation) {\n        const segments = pathname.split(\"/\");\n        // TODO-APP: figure out something better for index pages\n        segments.push(\"\");\n        // Optimistic tree case.\n        // If the optimistic tree is deeper than the current state leave that deeper part out of the fetch\n        const optimisticTree = (0, _createOptimisticTree).createOptimisticTree(segments, state.tree, false);\n        // Copy subTreeData for the root node of the cache.\n        cache.status = _appRouterContext.CacheStates.READY;\n        cache.subTreeData = state.cache.subTreeData;\n        // Copy existing cache nodes as far as possible and fill in `data` property with the started data fetch.\n        // The `data` property is used to suspend in layout-router during render if it hasn't resolved yet by the time it renders.\n        const res = (0, _fillCacheWithDataProperty).fillCacheWithDataProperty(cache, state.cache, segments.slice(1), ()=>(0, _fetchServerResponse).fetchServerResponse(url, optimisticTree));\n        // If optimistic fetch couldn't happen it falls back to the non-optimistic case.\n        if (!(res == null ? void 0 : res.bailOptimistic)) {\n            mutable.previousTree = state.tree;\n            mutable.patchedTree = optimisticTree;\n            mutable.pendingPush = pendingPush;\n            mutable.hashFragment = hash;\n            mutable.applyFocusAndScroll = true;\n            mutable.cache = cache;\n            mutable.canonicalUrl = href;\n            return handleMutable(state, mutable);\n        }\n    }\n    // Below is the not-optimistic case. Data is fetched at the root and suspended there without a suspense boundary.\n    // If no in-flight fetch at the top, start it.\n    if (!cache.data) {\n        cache.data = (0, _createRecordFromThenable).createRecordFromThenable((0, _fetchServerResponse).fetchServerResponse(url, state.tree));\n    }\n    // Unwrap cache data with `use` to suspend here (in the reducer) until the fetch resolves.\n    const [flightData, canonicalUrlOverride] = (0, _readRecordValue).readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return handleExternalUrl(state, mutable, flightData, pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // The one before last item is the router state tree patch\n    const [treePatch] = flightDataPath.slice(-3, -2);\n    // Path without the last segment, router state, and the subTreeData\n    const flightSegmentPath = flightDataPath.slice(0, -4);\n    // Create new tree based on the flightSegmentPath and router state patch\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return handleExternalUrl(state, mutable, href, pendingPush);\n    }\n    mutable.canonicalUrl = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : href;\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.applyFocusAndScroll = true;\n    mutable.pendingPush = pendingPush;\n    mutable.hashFragment = hash;\n    const applied = applyFlightData(state, cache, flightDataPath);\n    if (applied) {\n        mutable.cache = cache;\n    }\n    return handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigate-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHRTtBQUN4QkYsdUJBQXVCLEdBQUdHO0FBQzFCSCx5QkFBeUIsR0FBR0k7QUFDNUJKLHVCQUF1QixHQUFHSztBQUMxQixJQUFJQyxvQkFBb0JDLG1CQUFPQSxDQUFDLHlIQUEyQztBQUMzRSxJQUFJQyx1QkFBdUJELG1CQUFPQSxDQUFDLGlJQUEwQjtBQUM3RCxJQUFJRSw0QkFBNEJGLG1CQUFPQSxDQUFDLDZJQUFnQztBQUN4RSxJQUFJRyxtQkFBbUJILG1CQUFPQSxDQUFDLHlIQUFzQjtBQUNyRCxJQUFJSSxxQkFBcUJKLG1CQUFPQSxDQUFDLCtIQUF5QjtBQUMxRCxJQUFJSyxpQ0FBaUNMLG1CQUFPQSxDQUFDLDZKQUF3QztBQUNyRixJQUFJTSwrQkFBK0JOLG1CQUFPQSxDQUFDLHVKQUFxQztBQUNoRixJQUFJTyx5Q0FBeUNQLG1CQUFPQSxDQUFDLHlLQUE4QztBQUNuRyxJQUFJUSw2QkFBNkJSLG1CQUFPQSxDQUFDLGlKQUFrQztBQUMzRSxJQUFJUyx3QkFBd0JULG1CQUFPQSxDQUFDLG1JQUEyQjtBQUMvRCxJQUFJVSwrQkFBK0JWLG1CQUFPQSxDQUFDLHVKQUFxQztBQUNoRixJQUFJVyxzQkFBc0JYLG1CQUFPQSxDQUFDLCtIQUF5QjtBQUMzRCxJQUFJWSwrQkFBK0JaLG1CQUFPQSxDQUFDLHVKQUFxQztBQUNoRixTQUFTTCxjQUFja0IsS0FBSyxFQUFFQyxPQUFPLEVBQUU7SUFDbkMsT0FBTztRQUNILFlBQVk7UUFDWkMsY0FBYyxPQUFPRCxRQUFRQyxZQUFZLEtBQUssY0FBY0QsUUFBUUMsWUFBWSxLQUFLRixNQUFNRSxZQUFZ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T0FBTyxLQUFLLElBQUksS0FBTSxPQUFPdkYsUUFBUXVGLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcksxRixPQUFPQyxjQUFjLENBQUNDLFFBQVF1RixPQUFPLEVBQUUsY0FBYztRQUFFdEYsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU8yRixNQUFNLENBQUN6RixRQUFRdUYsT0FBTyxFQUFFdkY7SUFDL0IwRixPQUFPMUYsT0FBTyxHQUFHQSxRQUFRdUYsT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvbmF2aWdhdGUtcmVkdWNlci5qcz9kODE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYW5kbGVNdXRhYmxlID0gaGFuZGxlTXV0YWJsZTtcbmV4cG9ydHMuYXBwbHlGbGlnaHREYXRhID0gYXBwbHlGbGlnaHREYXRhO1xuZXhwb3J0cy5oYW5kbGVFeHRlcm5hbFVybCA9IGhhbmRsZUV4dGVybmFsVXJsO1xuZXhwb3J0cy5uYXZpZ2F0ZVJlZHVjZXIgPSBuYXZpZ2F0ZVJlZHVjZXI7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2ZldGNoU2VydmVyUmVzcG9uc2UgPSByZXF1aXJlKFwiLi4vZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xudmFyIF9jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUgPSByZXF1aXJlKFwiLi4vY3JlYXRlLXJlY29yZC1mcm9tLXRoZW5hYmxlXCIpO1xudmFyIF9yZWFkUmVjb3JkVmFsdWUgPSByZXF1aXJlKFwiLi4vcmVhZC1yZWNvcmQtdmFsdWVcIik7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xudmFyIF9maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZCA9IHJlcXVpcmUoXCIuLi9maWxsLWxhenktaXRlbXMtdGlsbC1sZWFmLXdpdGgtaGVhZFwiKTtcbnZhciBfZmlsbENhY2hlV2l0aE5ld1N1YnRyZWVEYXRhID0gcmVxdWlyZShcIi4uL2ZpbGwtY2FjaGUtd2l0aC1uZXctc3VidHJlZS1kYXRhXCIpO1xudmFyIF9pbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRwYXRoID0gcmVxdWlyZShcIi4uL2ludmFsaWRhdGUtY2FjaGUtYmVsb3ctZmxpZ2h0LXNlZ21lbnRwYXRoXCIpO1xudmFyIF9maWxsQ2FjaGVXaXRoRGF0YVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2ZpbGwtY2FjaGUtd2l0aC1kYXRhLXByb3BlcnR5XCIpO1xudmFyIF9jcmVhdGVPcHRpbWlzdGljVHJlZSA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtb3B0aW1pc3RpYy10cmVlXCIpO1xudmFyIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG52YXIgX3Nob3VsZEhhcmROYXZpZ2F0ZSA9IHJlcXVpcmUoXCIuLi9zaG91bGQtaGFyZC1uYXZpZ2F0ZVwiKTtcbnZhciBfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0ID0gcmVxdWlyZShcIi4uL2lzLW5hdmlnYXRpbmctdG8tbmV3LXJvb3QtbGF5b3V0XCIpO1xuZnVuY3Rpb24gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNldCBocmVmLlxuICAgICAgICBjYW5vbmljYWxVcmw6IHR5cGVvZiBtdXRhYmxlLmNhbm9uaWNhbFVybCAhPT0gJ3VuZGVmaW5lZCcgPyBtdXRhYmxlLmNhbm9uaWNhbFVybCA9PT0gc3RhdGUuY2Fub25pY2FsVXJsID8gc3RhdGUuY2Fub25pY2FsVXJsIDogbXV0YWJsZS5jYW5vbmljYWxVcmwgOiBzdGF0ZS5jYW5vbmljYWxVcmwsXG4gICAgICAgIHB1c2hSZWY6IHtcbiAgICAgICAgICAgIHBlbmRpbmdQdXNoOiB0eXBlb2YgbXV0YWJsZS5wZW5kaW5nUHVzaCAhPT0gJ3VuZGVmaW5lZCcgPyBtdXRhYmxlLnBlbmRpbmdQdXNoIDogc3RhdGUucHVzaFJlZi5wZW5kaW5nUHVzaCxcbiAgICAgICAgICAgIG1wYU5hdmlnYXRpb246IHR5cGVvZiBtdXRhYmxlLm1wYU5hdmlnYXRpb24gIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5tcGFOYXZpZ2F0aW9uIDogc3RhdGUucHVzaFJlZi5tcGFOYXZpZ2F0aW9uXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFsbCBuYXZpZ2F0aW9uIHJlcXVpcmVzIHNjcm9sbCBhbmQgZm9jdXMgbWFuYWdlbWVudCB0byB0cmlnZ2VyLlxuICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZjoge1xuICAgICAgICAgICAgYXBwbHk6IHR5cGVvZiBtdXRhYmxlLmFwcGx5Rm9jdXNBbmRTY3JvbGwgIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5hcHBseUZvY3VzQW5kU2Nyb2xsIDogc3RhdGUuZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHksXG4gICAgICAgICAgICBoYXNoRnJhZ21lbnQ6IC8vIEVtcHR5IGhhc2ggc2hvdWxkIHRyaWdnZXIgZGVmYXVsdCBiZWhhdmlvciBvZiBzY3JvbGxpbmcgbGF5b3V0IGludG8gdmlldy5cbiAgICAgICAgICAgIC8vICN0b3AgaXMgaGFuZGxlZCBpbiBsYXlvdXQtcm91dGVyLlxuICAgICAgICAgICAgbXV0YWJsZS5oYXNoRnJhZ21lbnQgJiYgbXV0YWJsZS5oYXNoRnJhZ21lbnQgIT09ICcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG11dGFibGUuaGFzaEZyYWdtZW50LnNsaWNlKDEpKSA6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQXBwbHkgY2FjaGUuXG4gICAgICAgIGNhY2hlOiBtdXRhYmxlLmNhY2hlID8gbXV0YWJsZS5jYWNoZSA6IHN0YXRlLmNhY2hlLFxuICAgICAgICBwcmVmZXRjaENhY2hlOiBzdGF0ZS5wcmVmZXRjaENhY2hlLFxuICAgICAgICAvLyBBcHBseSBwYXRjaGVkIHJvdXRlciBzdGF0ZS5cbiAgICAgICAgdHJlZTogdHlwZW9mIG11dGFibGUucGF0Y2hlZFRyZWUgIT09ICd1bmRlZmluZWQnID8gbXV0YWJsZS5wYXRjaGVkVHJlZSA6IHN0YXRlLnRyZWVcbiAgICB9O1xufVxuZnVuY3Rpb24gYXBwbHlGbGlnaHREYXRhKHN0YXRlLCBjYWNoZSwgZmxpZ2h0RGF0YVBhdGgpIHtcbiAgICAvLyBUaGUgb25lIGJlZm9yZSBsYXN0IGl0ZW0gaXMgdGhlIHJvdXRlciBzdGF0ZSB0cmVlIHBhdGNoXG4gICAgY29uc3QgW3RyZWVQYXRjaCwgc3ViVHJlZURhdGEsIGhlYWRdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMpO1xuICAgIC8vIEhhbmRsZXMgY2FzZSB3aGVyZSBwcmVmZXRjaCBvbmx5IHJldHVybnMgdGhlIHJvdXRlciB0cmVlIHBhdGNoIHdpdGhvdXQgcmVuZGVyZWQgY29tcG9uZW50cy5cbiAgICBpZiAoc3ViVHJlZURhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN1YlRyZWVEYXRhO1xuICAgICAgICAoMCwgX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkKS5maWxsTGF6eUl0ZW1zVGlsbExlYWZXaXRoSGVhZChjYWNoZSwgc3RhdGUuY2FjaGUsIHRyZWVQYXRjaCwgaGVhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29weSBzdWJUcmVlRGF0YSBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgY2FjaGUuXG4gICAgICAgIGNhY2hlLnN0YXR1cyA9IF9hcHBSb3V0ZXJDb250ZXh0LkNhY2hlU3RhdGVzLlJFQURZO1xuICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBleGlzdGluZyBjYWNoZSB3aXRoIHRoZSBzdWJUcmVlRGF0YSBhcHBsaWVkLlxuICAgICAgICAoMCwgX2ZpbGxDYWNoZVdpdGhOZXdTdWJ0cmVlRGF0YSkuZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhKGNhY2hlLCBzdGF0ZS5jYWNoZSwgZmxpZ2h0RGF0YVBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCB1cmwsIHBlbmRpbmdQdXNoKSB7XG4gICAgbXV0YWJsZS5wcmV2aW91c1RyZWUgPSBzdGF0ZS50cmVlO1xuICAgIG11dGFibGUubXBhTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSB1cmw7XG4gICAgbXV0YWJsZS5wZW5kaW5nUHVzaCA9IHBlbmRpbmdQdXNoO1xuICAgIG11dGFibGUuYXBwbHlGb2N1c0FuZFNjcm9sbCA9IGZhbHNlO1xuICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbn1cbmZ1bmN0aW9uIG5hdmlnYXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwgLCBpc0V4dGVybmFsVXJsICwgbG9jYXRpb25TZWFyY2ggLCBuYXZpZ2F0ZVR5cGUgLCBjYWNoZSAsIG11dGFibGUgLCBmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uICwgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgeyBwYXRobmFtZSAsIHNlYXJjaCAsIGhhc2ggIH0gPSB1cmw7XG4gICAgY29uc3QgaHJlZiA9ICgwLCBfY3JlYXRlSHJlZkZyb21VcmwpLmNyZWF0ZUhyZWZGcm9tVXJsKHVybCk7XG4gICAgY29uc3QgcGVuZGluZ1B1c2ggPSBuYXZpZ2F0ZVR5cGUgPT09ICdwdXNoJztcbiAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICBpZiAoaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSk7XG4gICAgfVxuICAgIGlmIChpc0V4dGVybmFsVXJsKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgdXJsLnRvU3RyaW5nKCksIHBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZmV0Y2hWYWx1ZXMgPSBzdGF0ZS5wcmVmZXRjaENhY2hlLmdldChocmVmKTtcbiAgICBpZiAocHJlZmV0Y2hWYWx1ZXMpIHtcbiAgICAgICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgICAgICBjb25zdCB7IGZsaWdodERhdGEgLCB0cmVlOiBuZXdUcmVlICwgY2Fub25pY2FsVXJsT3ZlcnJpZGUgIH0gPSBwcmVmZXRjaFZhbHVlcztcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgZmxpZ2h0RGF0YSwgcGVuZGluZ1B1c2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUcmVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgaHJlZiwgcGVuZGluZ1B1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICAgICAgICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAgICAgICAgIGNvbnN0IGZsaWdodFNlZ21lbnRQYXRoID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoMCwgLTMpO1xuICAgICAgICAgICAgY29uc3QgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShzdGF0ZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhcmROYXZpZ2F0ZSA9IC8vIFRPRE8tQVBQOiBSZXZpc2l0IHNlYXJjaFBhcmFtcyBzdXBwb3J0XG4gICAgICAgICAgICBzZWFyY2ggIT09IGxvY2F0aW9uU2VhcmNoIHx8ICgwLCBfc2hvdWxkSGFyZE5hdmlnYXRlKS5zaG91bGRIYXJkTmF2aWdhdGUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgICAgICAgICBdLCBzdGF0ZS50cmVlKTtcbiAgICAgICAgICAgIGlmIChoYXJkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zdGF0dXMgPSBfYXBwUm91dGVyQ29udGV4dC5DYWNoZVN0YXRlcy5SRUFEWTtcbiAgICAgICAgICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBjYWNoZS5zdWJUcmVlRGF0YSA9IHN0YXRlLmNhY2hlLnN1YlRyZWVEYXRhO1xuICAgICAgICAgICAgICAgICgwLCBfaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50cGF0aCkuaW52YWxpZGF0ZUNhY2hlQmVsb3dGbGlnaHRTZWdtZW50UGF0aChjYWNoZSwgc3RhdGUuY2FjaGUsIGZsaWdodFNlZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGV4aXN0aW5nIGNhY2hlIHZhbHVlIGlzIHVzZWQgd2hlbiB0aGUgY2FjaGUgd2FzIG5vdCBpbnZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFwcGxpZWQpIHtcbiAgICAgICAgICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdXRhYmxlLnByZXZpb3VzVHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICAgICAgICAgIG11dGFibGUuYXBwbHlGb2N1c0FuZFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlID8gKDAsIF9jcmVhdGVIcmVmRnJvbVVybCkuY3JlYXRlSHJlZkZyb21VcmwoY2Fub25pY2FsVXJsT3ZlcnJpZGUpIDogaHJlZjtcbiAgICAgICAgICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaDtcbiAgICAgICAgICAgIG11dGFibGUuaGFzaEZyYWdtZW50ID0gaGFzaDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXaGVuIGRvaW5nIGEgaGFyZCBwdXNoIHRoZXJlIGNhbiBiZSB0d28gY2FzZXM6IHdpdGggb3B0aW1pc3RpYyB0cmVlIGFuZCB3aXRob3V0XG4gICAgLy8gVGhlIHdpdGggb3B0aW1pc3RpYyB0cmVlIGNhc2Ugb25seSBoYXBwZW5zIHdoZW4gdGhlIGxheW91dHMgaGF2ZSBhIGxvYWRpbmcgc3RhdGUgKGxvYWRpbmcuanMpXG4gICAgLy8gVGhlIHdpdGhvdXQgb3B0aW1pc3RpYyB0cmVlIGNhc2UgaGFwcGVucyB3aGVuIHRoZXJlIGlzIG5vIGxvYWRpbmcgc3RhdGUsIGluIHRoYXQgY2FzZSB3ZSBzdXNwZW5kIGluIHRoaXMgcmVkdWNlclxuICAgIC8vIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb24gaXMgdXNlZCBmb3IgbGlua3MgdGhhdCBoYXZlIGBwcmVmZXRjaD17ZmFsc2V9YC5cbiAgICBpZiAoZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbikge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIC8vIFRPRE8tQVBQOiBmaWd1cmUgb3V0IHNvbWV0aGluZyBiZXR0ZXIgZm9yIGluZGV4IHBhZ2VzXG4gICAgICAgIHNlZ21lbnRzLnB1c2goJycpO1xuICAgICAgICAvLyBPcHRpbWlzdGljIHRyZWUgY2FzZS5cbiAgICAgICAgLy8gSWYgdGhlIG9wdGltaXN0aWMgdHJlZSBpcyBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBzdGF0ZSBsZWF2ZSB0aGF0IGRlZXBlciBwYXJ0IG91dCBvZiB0aGUgZmV0Y2hcbiAgICAgICAgY29uc3Qgb3B0aW1pc3RpY1RyZWUgPSAoMCwgX2NyZWF0ZU9wdGltaXN0aWNUcmVlKS5jcmVhdGVPcHRpbWlzdGljVHJlZShzZWdtZW50cywgc3RhdGUudHJlZSwgZmFsc2UpO1xuICAgICAgICAvLyBDb3B5IHN1YlRyZWVEYXRhIGZvciB0aGUgcm9vdCBub2RlIG9mIHRoZSBjYWNoZS5cbiAgICAgICAgY2FjaGUuc3RhdHVzID0gX2FwcFJvdXRlckNvbnRleHQuQ2FjaGVTdGF0ZXMuUkVBRFk7XG4gICAgICAgIGNhY2hlLnN1YlRyZWVEYXRhID0gc3RhdGUuY2FjaGUuc3ViVHJlZURhdGE7XG4gICAgICAgIC8vIENvcHkgZXhpc3RpbmcgY2FjaGUgbm9kZXMgYXMgZmFyIGFzIHBvc3NpYmxlIGFuZCBmaWxsIGluIGBkYXRhYCBwcm9wZXJ0eSB3aXRoIHRoZSBzdGFydGVkIGRhdGEgZmV0Y2guXG4gICAgICAgIC8vIFRoZSBgZGF0YWAgcHJvcGVydHkgaXMgdXNlZCB0byBzdXNwZW5kIGluIGxheW91dC1yb3V0ZXIgZHVyaW5nIHJlbmRlciBpZiBpdCBoYXNuJ3QgcmVzb2x2ZWQgeWV0IGJ5IHRoZSB0aW1lIGl0IHJlbmRlcnMuXG4gICAgICAgIGNvbnN0IHJlcyA9ICgwLCBfZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSkuZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eShjYWNoZSwgc3RhdGUuY2FjaGUsIC8vIFRPRE8tQVBQOiBzZWdtZW50cy5zbGljZSgxKSBzdHJpcHMgJycsIHdlIGNhbiBnZXQgcmlkIG9mICcnIGFsdG9nZXRoZXIuXG4gICAgICAgIHNlZ21lbnRzLnNsaWNlKDEpLCAoKT0+KDAsIF9mZXRjaFNlcnZlclJlc3BvbnNlKS5mZXRjaFNlcnZlclJlc3BvbnNlKHVybCwgb3B0aW1pc3RpY1RyZWUpKTtcbiAgICAgICAgLy8gSWYgb3B0aW1pc3RpYyBmZXRjaCBjb3VsZG4ndCBoYXBwZW4gaXQgZmFsbHMgYmFjayB0byB0aGUgbm9uLW9wdGltaXN0aWMgY2FzZS5cbiAgICAgICAgaWYgKCEocmVzID09IG51bGwgPyB2b2lkIDAgOiByZXMuYmFpbE9wdGltaXN0aWMpKSB7XG4gICAgICAgICAgICBtdXRhYmxlLnByZXZpb3VzVHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgICAgICAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gb3B0aW1pc3RpY1RyZWU7XG4gICAgICAgICAgICBtdXRhYmxlLnBlbmRpbmdQdXNoID0gcGVuZGluZ1B1c2g7XG4gICAgICAgICAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2g7XG4gICAgICAgICAgICBtdXRhYmxlLmFwcGx5Rm9jdXNBbmRTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgICAgICAgICAgbXV0YWJsZS5jYW5vbmljYWxVcmwgPSBocmVmO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJlbG93IGlzIHRoZSBub3Qtb3B0aW1pc3RpYyBjYXNlLiBEYXRhIGlzIGZldGNoZWQgYXQgdGhlIHJvb3QgYW5kIHN1c3BlbmRlZCB0aGVyZSB3aXRob3V0IGEgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgLy8gSWYgbm8gaW4tZmxpZ2h0IGZldGNoIGF0IHRoZSB0b3AsIHN0YXJ0IGl0LlxuICAgIGlmICghY2FjaGUuZGF0YSkge1xuICAgICAgICBjYWNoZS5kYXRhID0gKDAsIF9jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUpLmNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSgoMCwgX2ZldGNoU2VydmVyUmVzcG9uc2UpLmZldGNoU2VydmVyUmVzcG9uc2UodXJsLCBzdGF0ZS50cmVlKSk7XG4gICAgfVxuICAgIC8vIFVud3JhcCBjYWNoZSBkYXRhIHdpdGggYHVzZWAgdG8gc3VzcGVuZCBoZXJlIChpbiB0aGUgcmVkdWNlcikgdW50aWwgdGhlIGZldGNoIHJlc29sdmVzLlxuICAgIGNvbnN0IFtmbGlnaHREYXRhLCBjYW5vbmljYWxVcmxPdmVycmlkZV0gPSAoMCwgX3JlYWRSZWNvcmRWYWx1ZSkucmVhZFJlY29yZFZhbHVlKGNhY2hlLmRhdGEpO1xuICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gbmF2aWdhdGluZyB0byBwYWdlIGluIGBwYWdlc2AgZnJvbSBgYXBwYFxuICAgIGlmICh0eXBlb2YgZmxpZ2h0RGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBwZW5kaW5nUHVzaCk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBjYWNoZS5kYXRhIGFzIGl0IGhhcyBiZWVuIHJlc29sdmVkIGF0IHRoaXMgcG9pbnQuXG4gICAgY2FjaGUuZGF0YSA9IG51bGw7XG4gICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgLy8gVGhlIG9uZSBiZWZvcmUgbGFzdCBpdGVtIGlzIHRoZSByb3V0ZXIgc3RhdGUgdHJlZSBwYXRjaFxuICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGguc2xpY2UoLTMsIC0yKTtcbiAgICAvLyBQYXRoIHdpdGhvdXQgdGhlIGxhc3Qgc2VnbWVudCwgcm91dGVyIHN0YXRlLCBhbmQgdGhlIHN1YlRyZWVEYXRhXG4gICAgY29uc3QgZmxpZ2h0U2VnbWVudFBhdGggPSBmbGlnaHREYXRhUGF0aC5zbGljZSgwLCAtNCk7XG4gICAgLy8gQ3JlYXRlIG5ldyB0cmVlIGJhc2VkIG9uIHRoZSBmbGlnaHRTZWdtZW50UGF0aCBhbmQgcm91dGVyIHN0YXRlIHBhdGNoXG4gICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgIFtcbiAgICAgICAgJycsXG4gICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KS5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBwZW5kaW5nUHVzaCk7XG4gICAgfVxuICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSkgOiBocmVmO1xuICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICBtdXRhYmxlLmFwcGx5Rm9jdXNBbmRTY3JvbGwgPSB0cnVlO1xuICAgIG11dGFibGUucGVuZGluZ1B1c2ggPSBwZW5kaW5nUHVzaDtcbiAgICBtdXRhYmxlLmhhc2hGcmFnbWVudCA9IGhhc2g7XG4gICAgY29uc3QgYXBwbGllZCA9IGFwcGx5RmxpZ2h0RGF0YShzdGF0ZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGUtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYW5kbGVNdXRhYmxlIiwiYXBwbHlGbGlnaHREYXRhIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJuYXZpZ2F0ZVJlZHVjZXIiLCJfYXBwUm91dGVyQ29udGV4dCIsInJlcXVpcmUiLCJfZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIl9jcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJfcmVhZFJlY29yZFZhbHVlIiwiX2NyZWF0ZUhyZWZGcm9tVXJsIiwiX2ZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiX2ZpbGxDYWNoZVdpdGhOZXdTdWJ0cmVlRGF0YSIsIl9pbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRwYXRoIiwiX2ZpbGxDYWNoZVdpdGhEYXRhUHJvcGVydHkiLCJfY3JlYXRlT3B0aW1pc3RpY1RyZWUiLCJfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiX3Nob3VsZEhhcmROYXZpZ2F0ZSIsIl9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJzdGF0ZSIsIm11dGFibGUiLCJjYW5vbmljYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJtcGFOYXZpZ2F0aW9uIiwiZm9jdXNBbmRTY3JvbGxSZWYiLCJhcHBseSIsImFwcGx5Rm9jdXNBbmRTY3JvbGwiLCJoYXNoRnJhZ21lbnQiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbGljZSIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsInRyZWUiLCJwYXRjaGVkVHJlZSIsImZsaWdodERhdGFQYXRoIiwidHJlZVBhdGNoIiwic3ViVHJlZURhdGEiLCJoZWFkIiwibGVuZ3RoIiwic3RhdHVzIiwiQ2FjaGVTdGF0ZXMiLCJSRUFEWSIsImZpbGxMYXp5SXRlbXNUaWxsTGVhZldpdGhIZWFkIiwiZmlsbENhY2hlV2l0aE5ld1N1YlRyZWVEYXRhIiwidXJsIiwicHJldmlvdXNUcmVlIiwiYWN0aW9uIiwiaXNFeHRlcm5hbFVybCIsImxvY2F0aW9uU2VhcmNoIiwibmF2aWdhdGVUeXBlIiwiZm9yY2VPcHRpbWlzdGljTmF2aWdhdGlvbiIsInBhdGhuYW1lIiwic2VhcmNoIiwiaGFzaCIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImlzRm9yQ3VycmVudFRyZWUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9TdHJpbmciLCJwcmVmZXRjaFZhbHVlcyIsImdldCIsImZsaWdodERhdGEiLCJuZXdUcmVlIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJmbGlnaHRTZWdtZW50UGF0aCIsImFwcGxpZWQiLCJoYXJkTmF2aWdhdGUiLCJzaG91bGRIYXJkTmF2aWdhdGUiLCJpbnZhbGlkYXRlQ2FjaGVCZWxvd0ZsaWdodFNlZ21lbnRQYXRoIiwic2VnbWVudHMiLCJzcGxpdCIsInB1c2giLCJvcHRpbWlzdGljVHJlZSIsImNyZWF0ZU9wdGltaXN0aWNUcmVlIiwicmVzIiwiZmlsbENhY2hlV2l0aERhdGFQcm9wZXJ0eSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJiYWlsT3B0aW1pc3RpYyIsImRhdGEiLCJjcmVhdGVSZWNvcmRGcm9tVGhlbmFibGUiLCJyZWFkUmVjb3JkVmFsdWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJFcnJvciIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js ***!
  \**********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.prefetchReducer = prefetchReducer;\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nfunction prefetchReducer(state, action) {\n    const { url , serverResponse  } = action;\n    const [flightData, canonicalUrlOverride] = serverResponse;\n    if (typeof flightData === \"string\") {\n        return state;\n    }\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // The one before last item is the router state tree patch\n    const [treePatch] = flightDataPath.slice(-3);\n    const flightSegmentPath = flightDataPath.slice(0, -3);\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    // Patch did not apply correctly\n    if (newTree === null) {\n        return state;\n    }\n    // Create new tree based on the flightSegmentPath and router state patch\n    state.prefetchCache.set(href, {\n        flightData,\n        // Create new tree based on the flightSegmentPath and router state patch\n        tree: newTree,\n        canonicalUrlOverride\n    });\n    return state;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=prefetch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHVCQUF1QixHQUFHRTtBQUMxQixJQUFJQywrQkFBK0JDLG1CQUFPQSxDQUFDLHVKQUFxQztBQUNoRixJQUFJQyxxQkFBcUJELG1CQUFPQSxDQUFDLCtIQUF5QjtBQUMxRCxTQUFTRixnQkFBZ0JJLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ3BDLE1BQU0sRUFBRUMsSUFBRyxFQUFHQyxlQUFjLEVBQUcsR0FBR0Y7SUFDbEMsTUFBTSxDQUFDRyxZQUFZQyxxQkFBcUIsR0FBR0Y7SUFDM0MsSUFBSSxPQUFPQyxlQUFlLFVBQVU7UUFDaEMsT0FBT0o7SUFDWCxDQUFDO0lBQ0QsTUFBTU0sT0FBTyxDQUFDLEdBQUdQLGtCQUFrQixFQUFFUSxpQkFBaUIsQ0FBQ0w7SUFDdkQsMkdBQTJHO0lBQzNHLE1BQU1NLGlCQUFpQkosVUFBVSxDQUFDLEVBQUU7SUFDcEMsMERBQTBEO0lBQzFELE1BQU0sQ0FBQ0ssVUFBVSxHQUFHRCxlQUFlRSxLQUFLLENBQUMsQ0FBQztJQUMxQyxNQUFNQyxvQkFBb0JILGVBQWVFLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDbkQsTUFBTUUsVUFBVSxDQUFDLEdBQUdmLDRCQUE0QixFQUFFZ0IsMkJBQTJCLENBQzdFO1FBQ0k7V0FDR0Y7S0FDTixFQUFFWCxNQUFNYyxJQUFJLEVBQUVMO0lBQ2YsZ0NBQWdDO0lBQ2hDLElBQUlHLFlBQVksSUFBSSxFQUFFO1FBQ2xCLE9BQU9aO0lBQ1gsQ0FBQztJQUNELHdFQUF3RTtJQUN4RUEsTUFBTWUsYUFBYSxDQUFDQyxHQUFHLENBQUNWLE1BQU07UUFDMUJGO1FBQ0Esd0VBQXdFO1FBQ3hFVSxNQUFNRjtRQUNOUDtJQUNKO0lBQ0EsT0FBT0w7QUFDWDtBQUVBLElBQUksQ0FBQyxPQUFPTixRQUFRdUIsT0FBTyxLQUFLLGNBQWUsT0FBT3ZCLFFBQVF1QixPQUFPLEtBQUssWUFBWXZCLFFBQVF1QixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU92QixRQUFRdUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzFCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXVCLE9BQU8sRUFBRSxjQUFjO1FBQUV0QixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzJCLE1BQU0sQ0FBQ3pCLFFBQVF1QixPQUFPLEVBQUV2QjtJQUMvQjBCLE9BQU8xQixPQUFPLEdBQUdBLFFBQVF1QixPQUFPO0FBQ2xDLENBQUMsQ0FFRCw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyLmpzPzNiM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnByZWZldGNoUmVkdWNlciA9IHByZWZldGNoUmVkdWNlcjtcbnZhciBfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xudmFyIF9jcmVhdGVIcmVmRnJvbVVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbmZ1bmN0aW9uIHByZWZldGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwgLCBzZXJ2ZXJSZXNwb25zZSAgfSA9IGFjdGlvbjtcbiAgICBjb25zdCBbZmxpZ2h0RGF0YSwgY2Fub25pY2FsVXJsT3ZlcnJpZGVdID0gc2VydmVyUmVzcG9uc2U7XG4gICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGNvbnN0IGhyZWYgPSAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgIC8vIFRPRE8tQVBQOiBDdXJyZW50bHkgdGhlIEZsaWdodCBkYXRhIGNhbiBvbmx5IGhhdmUgb25lIGl0ZW0gYnV0IGluIHRoZSBmdXR1cmUgaXQgY2FuIGhhdmUgbXVsdGlwbGUgcGF0aHMuXG4gICAgY29uc3QgZmxpZ2h0RGF0YVBhdGggPSBmbGlnaHREYXRhWzBdO1xuICAgIC8vIFRoZSBvbmUgYmVmb3JlIGxhc3QgaXRlbSBpcyB0aGUgcm91dGVyIHN0YXRlIHRyZWUgcGF0Y2hcbiAgICBjb25zdCBbdHJlZVBhdGNoXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0zKTtcbiAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC0zKTtcbiAgICBjb25zdCBuZXdUcmVlID0gKDAsIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUpLmFwcGx5Um91dGVyU3RhdGVQYXRjaFRvVHJlZSgvLyBUT0RPLUFQUDogcmVtb3ZlICcnXG4gICAgW1xuICAgICAgICAnJyxcbiAgICAgICAgLi4uZmxpZ2h0U2VnbWVudFBhdGhcbiAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgIC8vIFBhdGNoIGRpZCBub3QgYXBwbHkgY29ycmVjdGx5XG4gICAgaWYgKG5ld1RyZWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgbmV3IHRyZWUgYmFzZWQgb24gdGhlIGZsaWdodFNlZ21lbnRQYXRoIGFuZCByb3V0ZXIgc3RhdGUgcGF0Y2hcbiAgICBzdGF0ZS5wcmVmZXRjaENhY2hlLnNldChocmVmLCB7XG4gICAgICAgIGZsaWdodERhdGEsXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgdHJlZSBiYXNlZCBvbiB0aGUgZmxpZ2h0U2VnbWVudFBhdGggYW5kIHJvdXRlciBzdGF0ZSBwYXRjaFxuICAgICAgICB0cmVlOiBuZXdUcmVlLFxuICAgICAgICBjYW5vbmljYWxVcmxPdmVycmlkZVxuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZmV0Y2gtcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwcmVmZXRjaFJlZHVjZXIiLCJfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwicmVxdWlyZSIsIl9jcmVhdGVIcmVmRnJvbVVybCIsInN0YXRlIiwiYWN0aW9uIiwidXJsIiwic2VydmVyUmVzcG9uc2UiLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJocmVmIiwiY3JlYXRlSHJlZkZyb21VcmwiLCJmbGlnaHREYXRhUGF0aCIsInRyZWVQYXRjaCIsInNsaWNlIiwiZmxpZ2h0U2VnbWVudFBhdGgiLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwidHJlZSIsInByZWZldGNoQ2FjaGUiLCJzZXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.refreshReducer = refreshReducer;\nvar _fetchServerResponse = __webpack_require__(/*! ../fetch-server-response */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nvar _createRecordFromThenable = __webpack_require__(/*! ../create-record-from-thenable */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-record-from-thenable.js\");\nvar _readRecordValue = __webpack_require__(/*! ../read-record-value */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/read-record-value.js\");\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nvar _navigateReducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction refreshReducer(state, action) {\n    const { cache , mutable , origin  } = action;\n    const href = state.canonicalUrl;\n    const isForCurrentTree = JSON.stringify(mutable.previousTree) === JSON.stringify(state.tree);\n    if (isForCurrentTree) {\n        return (0, _navigateReducer).handleMutable(state, mutable);\n    }\n    if (!cache.data) {\n        // TODO-APP: verify that `href` is not an external url.\n        // Fetch data from the root of the tree.\n        cache.data = (0, _createRecordFromThenable).createRecordFromThenable((0, _fetchServerResponse).fetchServerResponse(new URL(href, origin), [\n            state.tree[0],\n            state.tree[1],\n            state.tree[2],\n            \"refetch\"\n        ]));\n    }\n    const [flightData, canonicalUrlOverride] = (0, _readRecordValue).readRecordValue(cache.data);\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // Remove cache.data as it has been resolved at this point.\n    cache.data = null;\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // FlightDataPath with more than two items means unexpected Flight data was returned\n    if (flightDataPath.length !== 3) {\n        // TODO-APP: handle this case better\n        console.log(\"REFRESH FAILED\");\n        return state;\n    }\n    // Given the path can only have two items the items are only the router state and subTreeData for the root.\n    const [treePatch] = flightDataPath;\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\"\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, href, state.pushRef.pendingPush);\n    }\n    const canonicalUrlOverrideHref = canonicalUrlOverride ? (0, _createHrefFromUrl).createHrefFromUrl(canonicalUrlOverride) : undefined;\n    if (canonicalUrlOverride) {\n        mutable.canonicalUrl = canonicalUrlOverrideHref;\n    }\n    const applied = (0, _navigateReducer).applyFlightData(state, cache, flightDataPath);\n    if (applied) {\n        mutable.cache = cache;\n    }\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.canonicalUrl = href;\n    return (0, _navigateReducer).handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=refresh-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZWZyZXNoLXJlZHVjZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCLElBQUlDLHVCQUF1QkMsbUJBQU9BLENBQUMsaUlBQTBCO0FBQzdELElBQUlDLDRCQUE0QkQsbUJBQU9BLENBQUMsNklBQWdDO0FBQ3hFLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUMseUhBQXNCO0FBQ3JELElBQUlHLHFCQUFxQkgsbUJBQU9BLENBQUMsK0hBQXlCO0FBQzFELElBQUlJLCtCQUErQkosbUJBQU9BLENBQUMsdUpBQXFDO0FBQ2hGLElBQUlLLCtCQUErQkwsbUJBQU9BLENBQUMsdUpBQXFDO0FBQ2hGLElBQUlNLG1CQUFtQk4sbUJBQU9BLENBQUMsK0hBQW9CO0FBQ25ELFNBQVNGLGVBQWVTLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ25DLE1BQU0sRUFBRUMsTUFBSyxFQUFHQyxRQUFPLEVBQUdDLE9BQU0sRUFBRyxHQUFHSDtJQUN0QyxNQUFNSSxPQUFPTCxNQUFNTSxZQUFZO0lBQy9CLE1BQU1DLG1CQUFtQkMsS0FBS0MsU0FBUyxDQUFDTixRQUFRTyxZQUFZLE1BQU1GLEtBQUtDLFNBQVMsQ0FBQ1QsTUFBTVcsSUFBSTtJQUMzRixJQUFJSixrQkFBa0I7UUFDbEIsT0FBTyxDQUFDLEdBQUdSLGdCQUFnQixFQUFFYSxhQUFhLENBQUNaLE9BQU9HO0lBQ3RELENBQUM7SUFDRCxJQUFJLENBQUNELE1BQU1XLElBQUksRUFBRTtRQUNiLHVEQUF1RDtRQUN2RCx3Q0FBd0M7UUFDeENYLE1BQU1XLElBQUksR0FBRyxDQUFDLEdBQUduQix5QkFBeUIsRUFBRW9CLHdCQUF3QixDQUFDLENBQUMsR0FBR3RCLG9CQUFvQixFQUFFdUIsbUJBQW1CLENBQUMsSUFBSUMsSUFBSVgsTUFBTUQsU0FBUztZQUN0SUosTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFDYlgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFDYlgsTUFBTVcsSUFBSSxDQUFDLEVBQUU7WUFDYjtTQUNIO0lBQ0wsQ0FBQztJQUNELE1BQU0sQ0FBQ00sWUFBWUMscUJBQXFCLEdBQUcsQ0FBQyxHQUFHdkIsZ0JBQWdCLEVBQUV3QixlQUFlLENBQUNqQixNQUFNVyxJQUFJO0lBQzNGLDREQUE0RDtJQUM1RCxJQUFJLE9BQU9JLGVBQWUsVUFBVTtRQUNoQyxPQUFPLENBQUMsR0FBR2xCLGdCQUFnQixFQUFFcUIsaUJBQWlCLENBQUNwQixPQUFPRyxTQUFTYyxZQUFZakIsTUFBTXFCLE9BQU8sQ0FBQ0MsV0FBVztJQUN4RyxDQUFDO0lBQ0QsMkRBQTJEO0lBQzNEcEIsTUFBTVcsSUFBSSxHQUFHLElBQUk7SUFDakIsMkdBQTJHO0lBQzNHLE1BQU1VLGlCQUFpQk4sVUFBVSxDQUFDLEVBQUU7SUFDcEMsb0ZBQW9GO0lBQ3BGLElBQUlNLGVBQWVDLE1BQU0sS0FBSyxHQUFHO1FBQzdCLG9DQUFvQztRQUNwQ0MsUUFBUUMsR0FBRyxDQUFDO1FBQ1osT0FBTzFCO0lBQ1gsQ0FBQztJQUNELDJHQUEyRztJQUMzRyxNQUFNLENBQUMyQixVQUFVLEdBQUdKO0lBQ3BCLE1BQU1LLFVBQVUsQ0FBQyxHQUFHL0IsNEJBQTRCLEVBQUVnQywyQkFBMkIsQ0FDN0U7UUFDSTtLQUNILEVBQUU3QixNQUFNVyxJQUFJLEVBQUVnQjtJQUNmLElBQUlDLFlBQVksSUFBSSxFQUFFO1FBQ2xCLE1BQU0sSUFBSUUsTUFBTSxvQkFBb0I7SUFDeEMsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHaEMsNEJBQTRCLEVBQUVpQywyQkFBMkIsQ0FBQy9CLE1BQU1XLElBQUksRUFBRWlCLFVBQVU7UUFDcEYsT0FBTyxDQUFDLEdBQUc3QixnQkFBZ0IsRUFBRXFCLGlCQUFpQixDQUFDcEIsT0FBT0csU0FBU0UsTUFBTUwsTUFBTXFCLE9BQU8sQ0FBQ0MsV0FBVztJQUNsRyxDQUFDO0lBQ0QsTUFBTVUsMkJBQTJCZCx1QkFBdUIsQ0FBQyxHQUFHdEIsa0JBQWtCLEVBQUVxQyxpQkFBaUIsQ0FBQ2Ysd0JBQXdCZ0IsU0FBUztJQUNuSSxJQUFJaEIsc0JBQXNCO1FBQ3RCZixRQUFRRyxZQUFZLEdBQUcwQjtJQUMzQixDQUFDO0lBQ0QsTUFBTUcsVUFBVSxDQUFDLEdBQUdwQyxnQkFBZ0IsRUFBRXFDLGVBQWUsQ0FBQ3BDLE9BQU9FLE9BQU9xQjtJQUNwRSxJQUFJWSxTQUFTO1FBQ1RoQyxRQUFRRCxLQUFLLEdBQUdBO0lBQ3BCLENBQUM7SUFDREMsUUFBUU8sWUFBWSxHQUFHVixNQUFNVyxJQUFJO0lBQ2pDUixRQUFRa0MsV0FBVyxHQUFHVDtJQUN0QnpCLFFBQVFHLFlBQVksR0FBR0Q7SUFDdkIsT0FBTyxDQUFDLEdBQUdOLGdCQUFnQixFQUFFYSxhQUFhLENBQUNaLE9BQU9HO0FBQ3REO0FBRUEsSUFBSSxDQUFDLE9BQU9kLFFBQVFpRCxPQUFPLEtBQUssY0FBZSxPQUFPakQsUUFBUWlELE9BQU8sS0FBSyxZQUFZakQsUUFBUWlELE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2pELFFBQVFpRCxPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRaUQsT0FBTyxFQUFFLGNBQWM7UUFBRWhELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPcUQsTUFBTSxDQUFDbkQsUUFBUWlELE9BQU8sRUFBRWpEO0lBQy9Cb0QsT0FBT3BELE9BQU8sR0FBR0EsUUFBUWlELE9BQU87QUFDbEMsQ0FBQyxDQUVELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL3JlZnJlc2gtcmVkdWNlci5qcz8yOTNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWZyZXNoUmVkdWNlciA9IHJlZnJlc2hSZWR1Y2VyO1xudmFyIF9mZXRjaFNlcnZlclJlc3BvbnNlID0gcmVxdWlyZShcIi4uL2ZldGNoLXNlcnZlci1yZXNwb25zZVwiKTtcbnZhciBfY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1yZWNvcmQtZnJvbS10aGVuYWJsZVwiKTtcbnZhciBfcmVhZFJlY29yZFZhbHVlID0gcmVxdWlyZShcIi4uL3JlYWQtcmVjb3JkLXZhbHVlXCIpO1xudmFyIF9jcmVhdGVIcmVmRnJvbVVybCA9IHJlcXVpcmUoXCIuLi9jcmVhdGUtaHJlZi1mcm9tLXVybFwiKTtcbnZhciBfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlID0gcmVxdWlyZShcIi4uL2FwcGx5LXJvdXRlci1zdGF0ZS1wYXRjaC10by10cmVlXCIpO1xudmFyIF9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQgPSByZXF1aXJlKFwiLi4vaXMtbmF2aWdhdGluZy10by1uZXctcm9vdC1sYXlvdXRcIik7XG52YXIgX25hdmlnYXRlUmVkdWNlciA9IHJlcXVpcmUoXCIuL25hdmlnYXRlLXJlZHVjZXJcIik7XG5mdW5jdGlvbiByZWZyZXNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBjYWNoZSAsIG11dGFibGUgLCBvcmlnaW4gIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaHJlZiA9IHN0YXRlLmNhbm9uaWNhbFVybDtcbiAgICBjb25zdCBpc0ZvckN1cnJlbnRUcmVlID0gSlNPTi5zdHJpbmdpZnkobXV0YWJsZS5wcmV2aW91c1RyZWUpID09PSBKU09OLnN0cmluZ2lmeShzdGF0ZS50cmVlKTtcbiAgICBpZiAoaXNGb3JDdXJyZW50VHJlZSkge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZU11dGFibGUoc3RhdGUsIG11dGFibGUpO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlLmRhdGEpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IHZlcmlmeSB0aGF0IGBocmVmYCBpcyBub3QgYW4gZXh0ZXJuYWwgdXJsLlxuICAgICAgICAvLyBGZXRjaCBkYXRhIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUuXG4gICAgICAgIGNhY2hlLmRhdGEgPSAoMCwgX2NyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSkuY3JlYXRlUmVjb3JkRnJvbVRoZW5hYmxlKCgwLCBfZmV0Y2hTZXJ2ZXJSZXNwb25zZSkuZmV0Y2hTZXJ2ZXJSZXNwb25zZShuZXcgVVJMKGhyZWYsIG9yaWdpbiksIFtcbiAgICAgICAgICAgIHN0YXRlLnRyZWVbMF0sXG4gICAgICAgICAgICBzdGF0ZS50cmVlWzFdLFxuICAgICAgICAgICAgc3RhdGUudHJlZVsyXSxcbiAgICAgICAgICAgICdyZWZldGNoJywgXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgY29uc3QgW2ZsaWdodERhdGEsIGNhbm9uaWNhbFVybE92ZXJyaWRlXSA9ICgwLCBfcmVhZFJlY29yZFZhbHVlKS5yZWFkUmVjb3JkVmFsdWUoY2FjaGUuZGF0YSk7XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGNhY2hlLmRhdGEgYXMgaXQgaGFzIGJlZW4gcmVzb2x2ZWQgYXQgdGhpcyBwb2ludC5cbiAgICBjYWNoZS5kYXRhID0gbnVsbDtcbiAgICAvLyBUT0RPLUFQUDogQ3VycmVudGx5IHRoZSBGbGlnaHQgZGF0YSBjYW4gb25seSBoYXZlIG9uZSBpdGVtIGJ1dCBpbiB0aGUgZnV0dXJlIGl0IGNhbiBoYXZlIG11bHRpcGxlIHBhdGhzLlxuICAgIGNvbnN0IGZsaWdodERhdGFQYXRoID0gZmxpZ2h0RGF0YVswXTtcbiAgICAvLyBGbGlnaHREYXRhUGF0aCB3aXRoIG1vcmUgdGhhbiB0d28gaXRlbXMgbWVhbnMgdW5leHBlY3RlZCBGbGlnaHQgZGF0YSB3YXMgcmV0dXJuZWRcbiAgICBpZiAoZmxpZ2h0RGF0YVBhdGgubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIC8vIFRPRE8tQVBQOiBoYW5kbGUgdGhpcyBjYXNlIGJldHRlclxuICAgICAgICBjb25zb2xlLmxvZygnUkVGUkVTSCBGQUlMRUQnKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBHaXZlbiB0aGUgcGF0aCBjYW4gb25seSBoYXZlIHR3byBpdGVtcyB0aGUgaXRlbXMgYXJlIG9ubHkgdGhlIHJvdXRlciBzdGF0ZSBhbmQgc3ViVHJlZURhdGEgZm9yIHRoZSByb290LlxuICAgIGNvbnN0IFt0cmVlUGF0Y2hdID0gZmxpZ2h0RGF0YVBhdGg7XG4gICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgIFtcbiAgICAgICAgJydcbiAgICBdLCBzdGF0ZS50cmVlLCB0cmVlUGF0Y2gpO1xuICAgIGlmIChuZXdUcmVlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU0VHTUVOVCBNSVNNQVRDSCcpO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQpLmlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dChzdGF0ZS50cmVlLCBuZXdUcmVlKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBocmVmLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gY2Fub25pY2FsVXJsT3ZlcnJpZGUgPyAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChjYW5vbmljYWxVcmxPdmVycmlkZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlKSB7XG4gICAgICAgIG11dGFibGUuY2Fub25pY2FsVXJsID0gY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmO1xuICAgIH1cbiAgICBjb25zdCBhcHBsaWVkID0gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmFwcGx5RmxpZ2h0RGF0YShzdGF0ZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICBpZiAoYXBwbGllZCkge1xuICAgICAgICBtdXRhYmxlLmNhY2hlID0gY2FjaGU7XG4gICAgfVxuICAgIG11dGFibGUucHJldmlvdXNUcmVlID0gc3RhdGUudHJlZTtcbiAgICBtdXRhYmxlLnBhdGNoZWRUcmVlID0gbmV3VHJlZTtcbiAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGhyZWY7XG4gICAgcmV0dXJuICgwLCBfbmF2aWdhdGVSZWR1Y2VyKS5oYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmcmVzaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlZnJlc2hSZWR1Y2VyIiwiX2ZldGNoU2VydmVyUmVzcG9uc2UiLCJyZXF1aXJlIiwiX2NyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSIsIl9yZWFkUmVjb3JkVmFsdWUiLCJfY3JlYXRlSHJlZkZyb21VcmwiLCJfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsIl9uYXZpZ2F0ZVJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsImNhY2hlIiwibXV0YWJsZSIsIm9yaWdpbiIsImhyZWYiLCJjYW5vbmljYWxVcmwiLCJpc0ZvckN1cnJlbnRUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXZpb3VzVHJlZSIsInRyZWUiLCJoYW5kbGVNdXRhYmxlIiwiZGF0YSIsImNyZWF0ZVJlY29yZEZyb21UaGVuYWJsZSIsImZldGNoU2VydmVyUmVzcG9uc2UiLCJVUkwiLCJmbGlnaHREYXRhIiwiY2Fub25pY2FsVXJsT3ZlcnJpZGUiLCJyZWFkUmVjb3JkVmFsdWUiLCJoYW5kbGVFeHRlcm5hbFVybCIsInB1c2hSZWYiLCJwZW5kaW5nUHVzaCIsImZsaWdodERhdGFQYXRoIiwibGVuZ3RoIiwiY29uc29sZSIsImxvZyIsInRyZWVQYXRjaCIsIm5ld1RyZWUiLCJhcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUiLCJFcnJvciIsImlzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsImNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZiIsImNyZWF0ZUhyZWZGcm9tVXJsIiwidW5kZWZpbmVkIiwiYXBwbGllZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js ***!
  \*********************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.restoreReducer = restoreReducer;\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nfunction restoreReducer(state, action) {\n    const { url , tree  } = action;\n    const href = (0, _createHrefFromUrl).createHrefFromUrl(url);\n    return {\n        // Set canonical url\n        canonicalUrl: href,\n        pushRef: state.pushRef,\n        focusAndScrollRef: state.focusAndScrollRef,\n        cache: state.cache,\n        prefetchCache: state.prefetchCache,\n        // Restore provided tree\n        tree: tree\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=restore-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCLElBQUlDLHFCQUFxQkMsbUJBQU9BLENBQUMsK0hBQXlCO0FBQzFELFNBQVNGLGVBQWVHLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ25DLE1BQU0sRUFBRUMsSUFBRyxFQUFHQyxLQUFJLEVBQUcsR0FBR0Y7SUFDeEIsTUFBTUcsT0FBTyxDQUFDLEdBQUdOLGtCQUFrQixFQUFFTyxpQkFBaUIsQ0FBQ0g7SUFDdkQsT0FBTztRQUNILG9CQUFvQjtRQUNwQkksY0FBY0Y7UUFDZEcsU0FBU1AsTUFBTU8sT0FBTztRQUN0QkMsbUJBQW1CUixNQUFNUSxpQkFBaUI7UUFDMUNDLE9BQU9ULE1BQU1TLEtBQUs7UUFDbEJDLGVBQWVWLE1BQU1VLGFBQWE7UUFDbEMsd0JBQXdCO1FBQ3hCUCxNQUFNQTtJQUNWO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUWdCLE9BQU8sS0FBSyxjQUFlLE9BQU9oQixRQUFRZ0IsT0FBTyxLQUFLLFlBQVloQixRQUFRZ0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPaEIsUUFBUWdCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktuQixPQUFPQyxjQUFjLENBQUNDLFFBQVFnQixPQUFPLEVBQUUsY0FBYztRQUFFZixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT29CLE1BQU0sQ0FBQ2xCLFFBQVFnQixPQUFPLEVBQUVoQjtJQUMvQm1CLE9BQU9uQixPQUFPLEdBQUdBLFFBQVFnQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXIuanM/NzkzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVzdG9yZVJlZHVjZXIgPSByZXN0b3JlUmVkdWNlcjtcbnZhciBfY3JlYXRlSHJlZkZyb21VcmwgPSByZXF1aXJlKFwiLi4vY3JlYXRlLWhyZWYtZnJvbS11cmxcIik7XG5mdW5jdGlvbiByZXN0b3JlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyB1cmwgLCB0cmVlICB9ID0gYWN0aW9uO1xuICAgIGNvbnN0IGhyZWYgPSAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybCh1cmwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFNldCBjYW5vbmljYWwgdXJsXG4gICAgICAgIGNhbm9uaWNhbFVybDogaHJlZixcbiAgICAgICAgcHVzaFJlZjogc3RhdGUucHVzaFJlZixcbiAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWY6IHN0YXRlLmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjYWNoZTogc3RhdGUuY2FjaGUsXG4gICAgICAgIHByZWZldGNoQ2FjaGU6IHN0YXRlLnByZWZldGNoQ2FjaGUsXG4gICAgICAgIC8vIFJlc3RvcmUgcHJvdmlkZWQgdHJlZVxuICAgICAgICB0cmVlOiB0cmVlXG4gICAgfTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdG9yZS1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlc3RvcmVSZWR1Y2VyIiwiX2NyZWF0ZUhyZWZGcm9tVXJsIiwicmVxdWlyZSIsInN0YXRlIiwiYWN0aW9uIiwidXJsIiwidHJlZSIsImhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsImNhbm9uaWNhbFVybCIsInB1c2hSZWYiLCJmb2N1c0FuZFNjcm9sbFJlZiIsImNhY2hlIiwicHJlZmV0Y2hDYWNoZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js ***!
  \**************************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.serverPatchReducer = serverPatchReducer;\nvar _createHrefFromUrl = __webpack_require__(/*! ../create-href-from-url */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/create-href-from-url.js\");\nvar _applyRouterStatePatchToTree = __webpack_require__(/*! ../apply-router-state-patch-to-tree */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js\");\nvar _isNavigatingToNewRootLayout = __webpack_require__(/*! ../is-navigating-to-new-root-layout */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js\");\nvar _navigateReducer = __webpack_require__(/*! ./navigate-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nfunction serverPatchReducer(state, action) {\n    const { flightData , previousTree , overrideCanonicalUrl , cache , mutable  } = action;\n    const isForCurrentTree = JSON.stringify(previousTree) === JSON.stringify(state.tree);\n    // When a fetch is slow to resolve it could be that you navigated away while the request was happening or before the reducer runs.\n    // In that case opt-out of applying the patch given that the data could be stale.\n    if (!isForCurrentTree) {\n        // TODO-APP: Handle tree mismatch\n        console.log(\"TREE MISMATCH\");\n        // Keep everything as-is.\n        return state;\n    }\n    if (mutable.previousTree) {\n        return (0, _navigateReducer).handleMutable(state, mutable);\n    }\n    // Handle case when navigating to page in `pages` from `app`\n    if (typeof flightData === \"string\") {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, flightData, state.pushRef.pendingPush);\n    }\n    // TODO-APP: Currently the Flight data can only have one item but in the future it can have multiple paths.\n    const flightDataPath = flightData[0];\n    // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n    const flightSegmentPath = flightDataPath.slice(0, -4);\n    const [treePatch] = flightDataPath.slice(-3, -2);\n    const newTree = (0, _applyRouterStatePatchToTree).applyRouterStatePatchToTree([\n        \"\",\n        ...flightSegmentPath\n    ], state.tree, treePatch);\n    if (newTree === null) {\n        throw new Error(\"SEGMENT MISMATCH\");\n    }\n    if ((0, _isNavigatingToNewRootLayout).isNavigatingToNewRootLayout(state.tree, newTree)) {\n        return (0, _navigateReducer).handleExternalUrl(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);\n    }\n    const canonicalUrlOverrideHref = overrideCanonicalUrl ? (0, _createHrefFromUrl).createHrefFromUrl(overrideCanonicalUrl) : undefined;\n    if (canonicalUrlOverrideHref) {\n        mutable.canonicalUrl = canonicalUrlOverrideHref;\n    }\n    (0, _navigateReducer).applyFlightData(state, cache, flightDataPath);\n    mutable.previousTree = state.tree;\n    mutable.patchedTree = newTree;\n    mutable.cache = cache;\n    return (0, _navigateReducer).handleMutable(state, mutable);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=server-patch-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0IsSUFBSUMscUJBQXFCQyxtQkFBT0EsQ0FBQywrSEFBeUI7QUFDMUQsSUFBSUMsK0JBQStCRCxtQkFBT0EsQ0FBQyx1SkFBcUM7QUFDaEYsSUFBSUUsK0JBQStCRixtQkFBT0EsQ0FBQyx1SkFBcUM7QUFDaEYsSUFBSUcsbUJBQW1CSCxtQkFBT0EsQ0FBQywrSEFBb0I7QUFDbkQsU0FBU0YsbUJBQW1CTSxLQUFLLEVBQUVDLE1BQU0sRUFBRTtJQUN2QyxNQUFNLEVBQUVDLFdBQVUsRUFBR0MsYUFBWSxFQUFHQyxxQkFBb0IsRUFBR0MsTUFBSyxFQUFHQyxRQUFPLEVBQUcsR0FBR0w7SUFDaEYsTUFBTU0sbUJBQW1CQyxLQUFLQyxTQUFTLENBQUNOLGtCQUFrQkssS0FBS0MsU0FBUyxDQUFDVCxNQUFNVSxJQUFJO0lBQ25GLGtJQUFrSTtJQUNsSSxpRkFBaUY7SUFDakYsSUFBSSxDQUFDSCxrQkFBa0I7UUFDbkIsaUNBQWlDO1FBQ2pDSSxRQUFRQyxHQUFHLENBQUM7UUFDWix5QkFBeUI7UUFDekIsT0FBT1o7SUFDWCxDQUFDO0lBQ0QsSUFBSU0sUUFBUUgsWUFBWSxFQUFFO1FBQ3RCLE9BQU8sQ0FBQyxHQUFHSixnQkFBZ0IsRUFBRWMsYUFBYSxDQUFDYixPQUFPTTtJQUN0RCxDQUFDO0lBQ0QsNERBQTREO0lBQzVELElBQUksT0FBT0osZUFBZSxVQUFVO1FBQ2hDLE9BQU8sQ0FBQyxHQUFHSCxnQkFBZ0IsRUFBRWUsaUJBQWlCLENBQUNkLE9BQU9NLFNBQVNKLFlBQVlGLE1BQU1lLE9BQU8sQ0FBQ0MsV0FBVztJQUN4RyxDQUFDO0lBQ0QsMkdBQTJHO0lBQzNHLE1BQU1DLGlCQUFpQmYsVUFBVSxDQUFDLEVBQUU7SUFDcEMsbUZBQW1GO0lBQ25GLE1BQU1nQixvQkFBb0JELGVBQWVFLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDbkQsTUFBTSxDQUFDQyxVQUFVLEdBQUdILGVBQWVFLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUM5QyxNQUFNRSxVQUFVLENBQUMsR0FBR3hCLDRCQUE0QixFQUFFeUIsMkJBQTJCLENBQzdFO1FBQ0k7V0FDR0o7S0FDTixFQUFFbEIsTUFBTVUsSUFBSSxFQUFFVTtJQUNmLElBQUlDLFlBQVksSUFBSSxFQUFFO1FBQ2xCLE1BQU0sSUFBSUUsTUFBTSxvQkFBb0I7SUFDeEMsQ0FBQztJQUNELElBQUksQ0FBQyxHQUFHekIsNEJBQTRCLEVBQUUwQiwyQkFBMkIsQ0FBQ3hCLE1BQU1VLElBQUksRUFBRVcsVUFBVTtRQUNwRixPQUFPLENBQUMsR0FBR3RCLGdCQUFnQixFQUFFZSxpQkFBaUIsQ0FBQ2QsT0FBT00sU0FBU04sTUFBTXlCLFlBQVksRUFBRXpCLE1BQU1lLE9BQU8sQ0FBQ0MsV0FBVztJQUNoSCxDQUFDO0lBQ0QsTUFBTVUsMkJBQTJCdEIsdUJBQXVCLENBQUMsR0FBR1Qsa0JBQWtCLEVBQUVnQyxpQkFBaUIsQ0FBQ3ZCLHdCQUF3QndCLFNBQVM7SUFDbkksSUFBSUYsMEJBQTBCO1FBQzFCcEIsUUFBUW1CLFlBQVksR0FBR0M7SUFDM0IsQ0FBQztJQUNBLElBQUczQixnQkFBZ0IsRUFBRThCLGVBQWUsQ0FBQzdCLE9BQU9LLE9BQU9ZO0lBQ3BEWCxRQUFRSCxZQUFZLEdBQUdILE1BQU1VLElBQUk7SUFDakNKLFFBQVF3QixXQUFXLEdBQUdUO0lBQ3RCZixRQUFRRCxLQUFLLEdBQUdBO0lBQ2hCLE9BQU8sQ0FBQyxHQUFHTixnQkFBZ0IsRUFBRWMsYUFBYSxDQUFDYixPQUFPTTtBQUN0RDtBQUVBLElBQUksQ0FBQyxPQUFPZCxRQUFRdUMsT0FBTyxLQUFLLGNBQWUsT0FBT3ZDLFFBQVF1QyxPQUFPLEtBQUssWUFBWXZDLFFBQVF1QyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU92QyxRQUFRdUMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNySzFDLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUXVDLE9BQU8sRUFBRSxjQUFjO1FBQUV0QyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBTzJDLE1BQU0sQ0FBQ3pDLFFBQVF1QyxPQUFPLEVBQUV2QztJQUMvQjBDLE9BQU8xQyxPQUFPLEdBQUdBLFFBQVF1QyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlci5qcz9kYWYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXJ2ZXJQYXRjaFJlZHVjZXIgPSBzZXJ2ZXJQYXRjaFJlZHVjZXI7XG52YXIgX2NyZWF0ZUhyZWZGcm9tVXJsID0gcmVxdWlyZShcIi4uL2NyZWF0ZS1ocmVmLWZyb20tdXJsXCIpO1xudmFyIF9hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUgPSByZXF1aXJlKFwiLi4vYXBwbHktcm91dGVyLXN0YXRlLXBhdGNoLXRvLXRyZWVcIik7XG52YXIgX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCA9IHJlcXVpcmUoXCIuLi9pcy1uYXZpZ2F0aW5nLXRvLW5ldy1yb290LWxheW91dFwiKTtcbnZhciBfbmF2aWdhdGVSZWR1Y2VyID0gcmVxdWlyZShcIi4vbmF2aWdhdGUtcmVkdWNlclwiKTtcbmZ1bmN0aW9uIHNlcnZlclBhdGNoUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgY29uc3QgeyBmbGlnaHREYXRhICwgcHJldmlvdXNUcmVlICwgb3ZlcnJpZGVDYW5vbmljYWxVcmwgLCBjYWNoZSAsIG11dGFibGUgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgaXNGb3JDdXJyZW50VHJlZSA9IEpTT04uc3RyaW5naWZ5KHByZXZpb3VzVHJlZSkgPT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnRyZWUpO1xuICAgIC8vIFdoZW4gYSBmZXRjaCBpcyBzbG93IHRvIHJlc29sdmUgaXQgY291bGQgYmUgdGhhdCB5b3UgbmF2aWdhdGVkIGF3YXkgd2hpbGUgdGhlIHJlcXVlc3Qgd2FzIGhhcHBlbmluZyBvciBiZWZvcmUgdGhlIHJlZHVjZXIgcnVucy5cbiAgICAvLyBJbiB0aGF0IGNhc2Ugb3B0LW91dCBvZiBhcHBseWluZyB0aGUgcGF0Y2ggZ2l2ZW4gdGhhdCB0aGUgZGF0YSBjb3VsZCBiZSBzdGFsZS5cbiAgICBpZiAoIWlzRm9yQ3VycmVudFRyZWUpIHtcbiAgICAgICAgLy8gVE9ETy1BUFA6IEhhbmRsZSB0cmVlIG1pc21hdGNoXG4gICAgICAgIGNvbnNvbGUubG9nKCdUUkVFIE1JU01BVENIJyk7XG4gICAgICAgIC8vIEtlZXAgZXZlcnl0aGluZyBhcy1pcy5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBpZiAobXV0YWJsZS5wcmV2aW91c1RyZWUpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVSZWR1Y2VyKS5oYW5kbGVNdXRhYmxlKHN0YXRlLCBtdXRhYmxlKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBuYXZpZ2F0aW5nIHRvIHBhZ2UgaW4gYHBhZ2VzYCBmcm9tIGBhcHBgXG4gICAgaWYgKHR5cGVvZiBmbGlnaHREYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmhhbmRsZUV4dGVybmFsVXJsKHN0YXRlLCBtdXRhYmxlLCBmbGlnaHREYXRhLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgLy8gVE9ETy1BUFA6IEN1cnJlbnRseSB0aGUgRmxpZ2h0IGRhdGEgY2FuIG9ubHkgaGF2ZSBvbmUgaXRlbSBidXQgaW4gdGhlIGZ1dHVyZSBpdCBjYW4gaGF2ZSBtdWx0aXBsZSBwYXRocy5cbiAgICBjb25zdCBmbGlnaHREYXRhUGF0aCA9IGZsaWdodERhdGFbMF07XG4gICAgLy8gU2xpY2VzIG9mZiB0aGUgbGFzdCBzZWdtZW50ICh3aGljaCBpcyBhdCAtNCkgYXMgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSB5ZXRcbiAgICBjb25zdCBmbGlnaHRTZWdtZW50UGF0aCA9IGZsaWdodERhdGFQYXRoLnNsaWNlKDAsIC00KTtcbiAgICBjb25zdCBbdHJlZVBhdGNoXSA9IGZsaWdodERhdGFQYXRoLnNsaWNlKC0zLCAtMik7XG4gICAgY29uc3QgbmV3VHJlZSA9ICgwLCBfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlKS5hcHBseVJvdXRlclN0YXRlUGF0Y2hUb1RyZWUoLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgIFtcbiAgICAgICAgJycsXG4gICAgICAgIC4uLmZsaWdodFNlZ21lbnRQYXRoXG4gICAgXSwgc3RhdGUudHJlZSwgdHJlZVBhdGNoKTtcbiAgICBpZiAobmV3VHJlZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NFR01FTlQgTUlTTUFUQ0gnKTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaXNOYXZpZ2F0aW5nVG9OZXdSb290TGF5b3V0KS5pc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQoc3RhdGUudHJlZSwgbmV3VHJlZSkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVSZWR1Y2VyKS5oYW5kbGVFeHRlcm5hbFVybChzdGF0ZSwgbXV0YWJsZSwgc3RhdGUuY2Fub25pY2FsVXJsLCBzdGF0ZS5wdXNoUmVmLnBlbmRpbmdQdXNoKTtcbiAgICB9XG4gICAgY29uc3QgY2Fub25pY2FsVXJsT3ZlcnJpZGVIcmVmID0gb3ZlcnJpZGVDYW5vbmljYWxVcmwgPyAoMCwgX2NyZWF0ZUhyZWZGcm9tVXJsKS5jcmVhdGVIcmVmRnJvbVVybChvdmVycmlkZUNhbm9uaWNhbFVybCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZikge1xuICAgICAgICBtdXRhYmxlLmNhbm9uaWNhbFVybCA9IGNhbm9uaWNhbFVybE92ZXJyaWRlSHJlZjtcbiAgICB9XG4gICAgKDAsIF9uYXZpZ2F0ZVJlZHVjZXIpLmFwcGx5RmxpZ2h0RGF0YShzdGF0ZSwgY2FjaGUsIGZsaWdodERhdGFQYXRoKTtcbiAgICBtdXRhYmxlLnByZXZpb3VzVHJlZSA9IHN0YXRlLnRyZWU7XG4gICAgbXV0YWJsZS5wYXRjaGVkVHJlZSA9IG5ld1RyZWU7XG4gICAgbXV0YWJsZS5jYWNoZSA9IGNhY2hlO1xuICAgIHJldHVybiAoMCwgX25hdmlnYXRlUmVkdWNlcikuaGFuZGxlTXV0YWJsZShzdGF0ZSwgbXV0YWJsZSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1wYXRjaC1yZWR1Y2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNlcnZlclBhdGNoUmVkdWNlciIsIl9jcmVhdGVIcmVmRnJvbVVybCIsInJlcXVpcmUiLCJfYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiX2lzTmF2aWdhdGluZ1RvTmV3Um9vdExheW91dCIsIl9uYXZpZ2F0ZVJlZHVjZXIiLCJzdGF0ZSIsImFjdGlvbiIsImZsaWdodERhdGEiLCJwcmV2aW91c1RyZWUiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsImNhY2hlIiwibXV0YWJsZSIsImlzRm9yQ3VycmVudFRyZWUiLCJKU09OIiwic3RyaW5naWZ5IiwidHJlZSIsImNvbnNvbGUiLCJsb2ciLCJoYW5kbGVNdXRhYmxlIiwiaGFuZGxlRXh0ZXJuYWxVcmwiLCJwdXNoUmVmIiwicGVuZGluZ1B1c2giLCJmbGlnaHREYXRhUGF0aCIsImZsaWdodFNlZ21lbnRQYXRoIiwic2xpY2UiLCJ0cmVlUGF0Y2giLCJuZXdUcmVlIiwiYXBwbHlSb3V0ZXJTdGF0ZVBhdGNoVG9UcmVlIiwiRXJyb3IiLCJpc05hdmlnYXRpbmdUb05ld1Jvb3RMYXlvdXQiLCJjYW5vbmljYWxVcmwiLCJjYW5vbmljYWxVcmxPdmVycmlkZUhyZWYiLCJjcmVhdGVIcmVmRnJvbVVybCIsInVuZGVmaW5lZCIsImFwcGx5RmxpZ2h0RGF0YSIsInBhdGNoZWRUcmVlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ACTION_PREFETCH = exports.ACTION_SERVER_PATCH = exports.ACTION_RESTORE = exports.ACTION_NAVIGATE = exports.ACTION_REFRESH = void 0;\nconst ACTION_REFRESH = \"refresh\";\nexports.ACTION_REFRESH = ACTION_REFRESH;\nconst ACTION_NAVIGATE = \"navigate\";\nexports.ACTION_NAVIGATE = ACTION_NAVIGATE;\nconst ACTION_RESTORE = \"restore\";\nexports.ACTION_RESTORE = ACTION_RESTORE;\nconst ACTION_SERVER_PATCH = \"server-patch\";\nexports.ACTION_SERVER_PATCH = ACTION_SERVER_PATCH;\nconst ACTION_PREFETCH = \"prefetch\";\nexports.ACTION_PREFETCH = ACTION_PREFETCH;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx1QkFBdUIsR0FBR0EsMkJBQTJCLEdBQUdBLHNCQUFzQixHQUFHQSx1QkFBdUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUN6SSxNQUFNTSxpQkFBaUI7QUFDdkJOLHNCQUFzQixHQUFHTTtBQUN6QixNQUFNRCxrQkFBa0I7QUFDeEJMLHVCQUF1QixHQUFHSztBQUMxQixNQUFNRCxpQkFBaUI7QUFDdkJKLHNCQUFzQixHQUFHSTtBQUN6QixNQUFNRCxzQkFBc0I7QUFDNUJILDJCQUEyQixHQUFHRztBQUM5QixNQUFNRCxrQkFBa0I7QUFDeEJGLHVCQUF1QixHQUFHRTtBQUUxQixJQUFJLENBQUMsT0FBT0YsUUFBUU8sT0FBTyxLQUFLLGNBQWUsT0FBT1AsUUFBUU8sT0FBTyxLQUFLLFlBQVlQLFFBQVFPLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1AsUUFBUU8sT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRTyxPQUFPLEVBQUUsY0FBYztRQUFFTixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1csTUFBTSxDQUFDVCxRQUFRTyxPQUFPLEVBQUVQO0lBQy9CVSxPQUFPVixPQUFPLEdBQUdBLFFBQVFPLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzPzY1N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFDVElPTl9QUkVGRVRDSCA9IGV4cG9ydHMuQUNUSU9OX1NFUlZFUl9QQVRDSCA9IGV4cG9ydHMuQUNUSU9OX1JFU1RPUkUgPSBleHBvcnRzLkFDVElPTl9OQVZJR0FURSA9IGV4cG9ydHMuQUNUSU9OX1JFRlJFU0ggPSB2b2lkIDA7XG5jb25zdCBBQ1RJT05fUkVGUkVTSCA9ICdyZWZyZXNoJztcbmV4cG9ydHMuQUNUSU9OX1JFRlJFU0ggPSBBQ1RJT05fUkVGUkVTSDtcbmNvbnN0IEFDVElPTl9OQVZJR0FURSA9ICduYXZpZ2F0ZSc7XG5leHBvcnRzLkFDVElPTl9OQVZJR0FURSA9IEFDVElPTl9OQVZJR0FURTtcbmNvbnN0IEFDVElPTl9SRVNUT1JFID0gJ3Jlc3RvcmUnO1xuZXhwb3J0cy5BQ1RJT05fUkVTVE9SRSA9IEFDVElPTl9SRVNUT1JFO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9ICdzZXJ2ZXItcGF0Y2gnO1xuZXhwb3J0cy5BQ1RJT05fU0VSVkVSX1BBVENIID0gQUNUSU9OX1NFUlZFUl9QQVRDSDtcbmNvbnN0IEFDVElPTl9QUkVGRVRDSCA9ICdwcmVmZXRjaCc7XG5leHBvcnRzLkFDVElPTl9QUkVGRVRDSCA9IEFDVElPTl9QUkVGRVRDSDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXItdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQUNUSU9OX1BSRUZFVENIIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsIkFDVElPTl9SRVNUT1JFIiwiQUNUSU9OX05BVklHQVRFIiwiQUNUSU9OX1JFRlJFU0giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer.js ***!
  \***********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.reducer = void 0;\nvar _routerReducerTypes = __webpack_require__(/*! ./router-reducer-types */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nvar _navigateReducer = __webpack_require__(/*! ./reducers/navigate-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js\");\nvar _serverPatchReducer = __webpack_require__(/*! ./reducers/server-patch-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js\");\nvar _restoreReducer = __webpack_require__(/*! ./reducers/restore-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js\");\nvar _refreshReducer = __webpack_require__(/*! ./reducers/refresh-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js\");\nvar _prefetchReducer = __webpack_require__(/*! ./reducers/prefetch-reducer */ \"(app-client)/./node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js\");\n/**\n * Reducer that handles the app-router state updates.\n */ function clientReducer(state, action) {\n    switch(action.type){\n        case _routerReducerTypes.ACTION_NAVIGATE:\n            {\n                return (0, _navigateReducer).navigateReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_SERVER_PATCH:\n            {\n                return (0, _serverPatchReducer).serverPatchReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_RESTORE:\n            {\n                return (0, _restoreReducer).restoreReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_REFRESH:\n            {\n                return (0, _refreshReducer).refreshReducer(state, action);\n            }\n        case _routerReducerTypes.ACTION_PREFETCH:\n            {\n                return (0, _prefetchReducer).prefetchReducer(state, action);\n            }\n        // This case should never be hit as dispatch is strongly typed.\n        default:\n            throw new Error(\"Unknown action\");\n    }\n}\nfunction serverReducer(state, _action) {\n    return state;\n}\nconst reducer =  false ? 0 : clientReducer;\nexports.reducer = reducer;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxlQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJRyxzQkFBc0JDLG1CQUFPQSxDQUFDLDhIQUF3QjtBQUMxRCxJQUFJQyxtQkFBbUJELG1CQUFPQSxDQUFDLHdJQUE2QjtBQUM1RCxJQUFJRSxzQkFBc0JGLG1CQUFPQSxDQUFDLGdKQUFpQztBQUNuRSxJQUFJRyxrQkFBa0JILG1CQUFPQSxDQUFDLHNJQUE0QjtBQUMxRCxJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDLHNJQUE0QjtBQUMxRCxJQUFJSyxtQkFBbUJMLG1CQUFPQSxDQUFDLHdJQUE2QjtBQUM1RDs7Q0FFQyxHQUFHLFNBQVNNLGNBQWNDLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQ3RDLE9BQU9BLE9BQU9DLElBQUk7UUFDZCxLQUFLVixvQkFBb0JXLGVBQWU7WUFDcEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdULGdCQUFnQixFQUFFVSxlQUFlLENBQUNKLE9BQU9DO1lBQ3hEO1FBQ0osS0FBS1Qsb0JBQW9CYSxtQkFBbUI7WUFDeEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdWLG1CQUFtQixFQUFFVyxrQkFBa0IsQ0FBQ04sT0FBT0M7WUFDOUQ7UUFDSixLQUFLVCxvQkFBb0JlLGNBQWM7WUFDbkM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdYLGVBQWUsRUFBRVksY0FBYyxDQUFDUixPQUFPQztZQUN0RDtRQUNKLEtBQUtULG9CQUFvQmlCLGNBQWM7WUFDbkM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdaLGVBQWUsRUFBRWEsY0FBYyxDQUFDVixPQUFPQztZQUN0RDtRQUNKLEtBQUtULG9CQUFvQm1CLGVBQWU7WUFDcEM7Z0JBQ0ksT0FBTyxDQUFDLEdBQUdiLGdCQUFnQixFQUFFYyxlQUFlLENBQUNaLE9BQU9DO1lBQ3hEO1FBQ0osK0RBQStEO1FBQy9EO1lBQ0ksTUFBTSxJQUFJWSxNQUFNLGtCQUFrQjtJQUMxQztBQUNKO0FBQ0EsU0FBU0MsY0FBY2QsS0FBSyxFQUFFZSxPQUFPLEVBQUU7SUFDbkMsT0FBT2Y7QUFDWDtBQUNBLE1BQU1ULFVBQVUsTUFBa0IsR0FBY3VCLENBQWFBLEdBQUdmLGFBQWE7QUFDN0VWLGVBQWUsR0FBR0U7QUFFbEIsSUFBSSxDQUFDLE9BQU9GLFFBQVEyQixPQUFPLEtBQUssY0FBZSxPQUFPM0IsUUFBUTJCLE9BQU8sS0FBSyxZQUFZM0IsUUFBUTJCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzNCLFFBQVEyQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLOUIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRMkIsT0FBTyxFQUFFLGNBQWM7UUFBRTFCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPK0IsTUFBTSxDQUFDN0IsUUFBUTJCLE9BQU8sRUFBRTNCO0lBQy9COEIsT0FBTzlCLE9BQU8sR0FBR0EsUUFBUTJCLE9BQU87QUFDbEMsQ0FBQyxDQUVELDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLmpzPzFkZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlZHVjZXIgPSB2b2lkIDA7XG52YXIgX3JvdXRlclJlZHVjZXJUeXBlcyA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xudmFyIF9uYXZpZ2F0ZVJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9uYXZpZ2F0ZS1yZWR1Y2VyXCIpO1xudmFyIF9zZXJ2ZXJQYXRjaFJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9zZXJ2ZXItcGF0Y2gtcmVkdWNlclwiKTtcbnZhciBfcmVzdG9yZVJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9yZXN0b3JlLXJlZHVjZXJcIik7XG52YXIgX3JlZnJlc2hSZWR1Y2VyID0gcmVxdWlyZShcIi4vcmVkdWNlcnMvcmVmcmVzaC1yZWR1Y2VyXCIpO1xudmFyIF9wcmVmZXRjaFJlZHVjZXIgPSByZXF1aXJlKFwiLi9yZWR1Y2Vycy9wcmVmZXRjaC1yZWR1Y2VyXCIpO1xuLyoqXG4gKiBSZWR1Y2VyIHRoYXQgaGFuZGxlcyB0aGUgYXBwLXJvdXRlciBzdGF0ZSB1cGRhdGVzLlxuICovIGZ1bmN0aW9uIGNsaWVudFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHN3aXRjaChhY3Rpb24udHlwZSl7XG4gICAgICAgIGNhc2UgX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fTkFWSUdBVEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfbmF2aWdhdGVSZWR1Y2VyKS5uYXZpZ2F0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgX3JvdXRlclJlZHVjZXJUeXBlcy5BQ1RJT05fU0VSVkVSX1BBVENIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3NlcnZlclBhdGNoUmVkdWNlcikuc2VydmVyUGF0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1JFU1RPUkU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVzdG9yZVJlZHVjZXIpLnJlc3RvcmVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1JFRlJFU0g6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVmcmVzaFJlZHVjZXIpLnJlZnJlc2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIF9yb3V0ZXJSZWR1Y2VyVHlwZXMuQUNUSU9OX1BSRUZFVENIOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgX3ByZWZldGNoUmVkdWNlcikucHJlZmV0Y2hSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIGNhc2Ugc2hvdWxkIG5ldmVyIGJlIGhpdCBhcyBkaXNwYXRjaCBpcyBzdHJvbmdseSB0eXBlZC5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhY3Rpb24nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJ2ZXJSZWR1Y2VyKHN0YXRlLCBfYWN0aW9uKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuY29uc3QgcmVkdWNlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gc2VydmVyUmVkdWNlciA6IGNsaWVudFJlZHVjZXI7XG5leHBvcnRzLnJlZHVjZXIgPSByZWR1Y2VyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItcmVkdWNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWR1Y2VyIiwiX3JvdXRlclJlZHVjZXJUeXBlcyIsInJlcXVpcmUiLCJfbmF2aWdhdGVSZWR1Y2VyIiwiX3NlcnZlclBhdGNoUmVkdWNlciIsIl9yZXN0b3JlUmVkdWNlciIsIl9yZWZyZXNoUmVkdWNlciIsIl9wcmVmZXRjaFJlZHVjZXIiLCJjbGllbnRSZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJ0eXBlIiwiQUNUSU9OX05BVklHQVRFIiwibmF2aWdhdGVSZWR1Y2VyIiwiQUNUSU9OX1NFUlZFUl9QQVRDSCIsInNlcnZlclBhdGNoUmVkdWNlciIsIkFDVElPTl9SRVNUT1JFIiwicmVzdG9yZVJlZHVjZXIiLCJBQ1RJT05fUkVGUkVTSCIsInJlZnJlc2hSZWR1Y2VyIiwiQUNUSU9OX1BSRUZFVENIIiwicHJlZmV0Y2hSZWR1Y2VyIiwiRXJyb3IiLCJzZXJ2ZXJSZWR1Y2VyIiwiX2FjdGlvbiIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/router-reducer.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.shouldHardNavigate = shouldHardNavigate;\nvar _matchSegments = __webpack_require__(/*! ../match-segments */ \"(app-client)/./node_modules/next/dist/client/components/match-segments.js\");\nfunction shouldHardNavigate(flightSegmentPath, flightRouterState) {\n    const [segment, parallelRoutes] = flightRouterState;\n    // TODO-APP: Check if `as` can be replaced.\n    const [currentSegment, parallelRouteKey] = flightSegmentPath;\n    // Check if current segment matches the existing segment.\n    if (!(0, _matchSegments).matchSegment(currentSegment, segment)) {\n        // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n        if (Array.isArray(currentSegment)) {\n            return true;\n        }\n        // If the existing segment did not match soft navigation is triggered.\n        return false;\n    }\n    const lastSegment = flightSegmentPath.length <= 2;\n    if (lastSegment) {\n        return false;\n    }\n    return shouldHardNavigate(flightSegmentPath.slice(2), parallelRoutes[parallelRouteKey]);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=should-hard-navigate.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0IsSUFBSUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyxvR0FBbUI7QUFDaEQsU0FBU0YsbUJBQW1CRyxpQkFBaUIsRUFBRUMsaUJBQWlCLEVBQUU7SUFDOUQsTUFBTSxDQUFDQyxTQUFTQyxlQUFlLEdBQUdGO0lBQ2xDLDJDQUEyQztJQUMzQyxNQUFNLENBQUNHLGdCQUFnQkMsaUJBQWlCLEdBQUdMO0lBQzNDLHlEQUF5RDtJQUN6RCxJQUFJLENBQUMsQ0FBQyxHQUFHRixjQUFjLEVBQUVRLFlBQVksQ0FBQ0YsZ0JBQWdCRixVQUFVO1FBQzVELGtHQUFrRztRQUNsRyxJQUFJSyxNQUFNQyxPQUFPLENBQUNKLGlCQUFpQjtZQUMvQixPQUFPLElBQUk7UUFDZixDQUFDO1FBQ0Qsc0VBQXNFO1FBQ3RFLE9BQU8sS0FBSztJQUNoQixDQUFDO0lBQ0QsTUFBTUssY0FBY1Qsa0JBQWtCVSxNQUFNLElBQUk7SUFDaEQsSUFBSUQsYUFBYTtRQUNiLE9BQU8sS0FBSztJQUNoQixDQUFDO0lBQ0QsT0FBT1osbUJBQW1CRyxrQkFBa0JXLEtBQUssQ0FBQyxJQUFJUixjQUFjLENBQUNFLGlCQUFpQjtBQUMxRjtBQUVBLElBQUksQ0FBQyxPQUFPVixRQUFRaUIsT0FBTyxLQUFLLGNBQWUsT0FBT2pCLFFBQVFpQixPQUFPLEtBQUssWUFBWWpCLFFBQVFpQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9qQixRQUFRaUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3BCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWlCLE9BQU8sRUFBRSxjQUFjO1FBQUVoQixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3FCLE1BQU0sQ0FBQ25CLFFBQVFpQixPQUFPLEVBQUVqQjtJQUMvQm9CLE9BQU9wQixPQUFPLEdBQUdBLFFBQVFpQixPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9zaG91bGQtaGFyZC1uYXZpZ2F0ZS5qcz82NjMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zaG91bGRIYXJkTmF2aWdhdGUgPSBzaG91bGRIYXJkTmF2aWdhdGU7XG52YXIgX21hdGNoU2VnbWVudHMgPSByZXF1aXJlKFwiLi4vbWF0Y2gtc2VnbWVudHNcIik7XG5mdW5jdGlvbiBzaG91bGRIYXJkTmF2aWdhdGUoZmxpZ2h0U2VnbWVudFBhdGgsIGZsaWdodFJvdXRlclN0YXRlKSB7XG4gICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVzXSA9IGZsaWdodFJvdXRlclN0YXRlO1xuICAgIC8vIFRPRE8tQVBQOiBDaGVjayBpZiBgYXNgIGNhbiBiZSByZXBsYWNlZC5cbiAgICBjb25zdCBbY3VycmVudFNlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gZmxpZ2h0U2VnbWVudFBhdGg7XG4gICAgLy8gQ2hlY2sgaWYgY3VycmVudCBzZWdtZW50IG1hdGNoZXMgdGhlIGV4aXN0aW5nIHNlZ21lbnQuXG4gICAgaWYgKCEoMCwgX21hdGNoU2VnbWVudHMpLm1hdGNoU2VnbWVudChjdXJyZW50U2VnbWVudCwgc2VnbWVudCkpIHtcbiAgICAgICAgLy8gSWYgZHluYW1pYyBwYXJhbWV0ZXIgaW4gdHJlZSBkb2Vzbid0IG1hdGNoIHVwIHdpdGggc2VnbWVudCBwYXRoIGEgaGFyZCBuYXZpZ2F0aW9uIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFNlZ21lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZXhpc3Rpbmcgc2VnbWVudCBkaWQgbm90IG1hdGNoIHNvZnQgbmF2aWdhdGlvbiBpcyB0cmlnZ2VyZWQuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbGFzdFNlZ21lbnQgPSBmbGlnaHRTZWdtZW50UGF0aC5sZW5ndGggPD0gMjtcbiAgICBpZiAobGFzdFNlZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkSGFyZE5hdmlnYXRlKGZsaWdodFNlZ21lbnRQYXRoLnNsaWNlKDIpLCBwYXJhbGxlbFJvdXRlc1twYXJhbGxlbFJvdXRlS2V5XSk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNob3VsZC1oYXJkLW5hdmlnYXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNob3VsZEhhcmROYXZpZ2F0ZSIsIl9tYXRjaFNlZ21lbnRzIiwicmVxdWlyZSIsImZsaWdodFNlZ21lbnRQYXRoIiwiZmxpZ2h0Um91dGVyU3RhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZXMiLCJjdXJyZW50U2VnbWVudCIsInBhcmFsbGVsUm91dGVLZXkiLCJtYXRjaFNlZ21lbnQiLCJBcnJheSIsImlzQXJyYXkiLCJsYXN0U2VnbWVudCIsImxlbmd0aCIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/use-reducer-with-devtools.js ***!
  \*******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useReducerWithReduxDevtools = void 0;\nvar _react = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\nfunction normalizeRouterState(val) {\n    if (val instanceof Map) {\n        const obj = {};\n        for (const [key, value] of val.entries()){\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value._bundlerConfig) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (typeof val === \"object\" && val !== null) {\n        const obj = {};\n        for(const key in val){\n            const value = val[key];\n            if (typeof value === \"function\") {\n                obj[key] = \"fn()\";\n                continue;\n            }\n            if (typeof value === \"object\" && value !== null) {\n                if (value.$$typeof) {\n                    obj[key] = value.$$typeof.toString();\n                    continue;\n                }\n                if (value.hasOwnProperty(\"_bundlerConfig\")) {\n                    obj[key] = \"FlightData\";\n                    continue;\n                }\n            }\n            obj[key] = normalizeRouterState(value);\n        }\n        return obj;\n    }\n    if (Array.isArray(val)) {\n        return val.map(normalizeRouterState);\n    }\n    return val;\n}\nfunction devToolReducer(fn, ref) {\n    return (state, action)=>{\n        const res = fn(state, action);\n        if (ref.current) {\n            ref.current.send(action, normalizeRouterState(res));\n        }\n        return res;\n    };\n}\nfunction useReducerWithReduxDevtoolsNoop(fn, initialState) {\n    _s();\n    const [state, dispatch] = (0, _react).useReducer(fn, initialState);\n    return [\n        state,\n        dispatch,\n        ()=>{}\n    ];\n}\n_s(useReducerWithReduxDevtoolsNoop, \"6JWkGZ32UPfojeNx+xqn8ZU8A0Q=\");\nfunction useReducerWithReduxDevtoolsImpl(fn, initialState) {\n    _s1();\n    const devtoolsConnectionRef = (0, _react).useRef();\n    const enabledRef = (0, _react).useRef();\n    (0, _react).useEffect(()=>{\n        if (devtoolsConnectionRef.current || enabledRef.current === false) {\n            return;\n        }\n        if (enabledRef.current === undefined && typeof window.__REDUX_DEVTOOLS_EXTENSION__ === \"undefined\") {\n            enabledRef.current = false;\n            return;\n        }\n        devtoolsConnectionRef.current = window.__REDUX_DEVTOOLS_EXTENSION__.connect({\n            instanceId: 8000,\n            name: \"next-router\"\n        });\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.init(normalizeRouterState(initialState));\n        }\n        return ()=>{\n            devtoolsConnectionRef.current = undefined;\n        };\n    }, [\n        initialState\n    ]);\n    const [state, dispatch] = (0, _react).useReducer(devToolReducer(/* logReducer( */ fn /*)*/ , devtoolsConnectionRef), initialState);\n    const sync = (0, _react).useCallback(()=>{\n        if (devtoolsConnectionRef.current) {\n            devtoolsConnectionRef.current.send({\n                type: \"RENDER_SYNC\"\n            }, normalizeRouterState(state));\n        }\n    }, [\n        state\n    ]);\n    return [\n        state,\n        dispatch,\n        sync\n    ];\n}\n_s1(useReducerWithReduxDevtoolsImpl, \"pLR6zS9fUqATAvEc1j249W8BDm8=\");\nconst useReducerWithReduxDevtools =  true ? useReducerWithReduxDevtoolsImpl : 0;\nexports.useReducerWithReduxDevtools = useReducerWithReduxDevtools;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-reducer-with-devtools.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxtQ0FBbUMsR0FBRyxLQUFLO0FBQzNDLElBQUlHLFNBQVNDLG1CQUFPQSxDQUFDLDRFQUFPO0FBQzVCLFNBQVNDLHFCQUFxQkMsR0FBRyxFQUFFO0lBQy9CLElBQUlBLGVBQWVDLEtBQUs7UUFDcEIsTUFBTUMsTUFBTSxDQUFDO1FBQ2IsS0FBSyxNQUFNLENBQUNDLEtBQUtSLE1BQU0sSUFBSUssSUFBSUksT0FBTyxHQUFHO1lBQ3JDLElBQUksT0FBT1QsVUFBVSxZQUFZO2dCQUM3Qk8sR0FBRyxDQUFDQyxJQUFJLEdBQUc7Z0JBQ1gsUUFBUztZQUNiLENBQUM7WUFDRCxJQUFJLE9BQU9SLFVBQVUsWUFBWUEsVUFBVSxJQUFJLEVBQUU7Z0JBQzdDLElBQUlBLE1BQU1VLFFBQVEsRUFBRTtvQkFDaEJILEdBQUcsQ0FBQ0MsSUFBSSxHQUFHUixNQUFNVSxRQUFRLENBQUNDLFFBQVE7b0JBQ2xDLFFBQVM7Z0JBQ2IsQ0FBQztnQkFDRCxJQUFJWCxNQUFNWSxjQUFjLEVBQUU7b0JBQ3RCTCxHQUFHLENBQUNDLElBQUksR0FBRztvQkFDWCxRQUFTO2dCQUNiLENBQUM7WUFDTCxDQUFDO1lBQ0RELEdBQUcsQ0FBQ0MsSUFBSSxHQUFHSixxQkFBcUJKO1FBQ3BDO1FBQ0EsT0FBT087SUFDWCxDQUFDO0lBQ0QsSUFBSSxPQUFPRixRQUFRLFlBQVlBLFFBQVEsSUFBSSxFQUFFO1FBQ3pDLE1BQU1FLE1BQU0sQ0FBQztRQUNiLElBQUksTUFBTUMsT0FBT0gsSUFBSTtZQUNqQixNQUFNTCxRQUFRSyxHQUFHLENBQUNHLElBQUk7WUFDdEIsSUFBSSxPQUFPUixVQUFVLFlBQVk7Z0JBQzdCTyxHQUFH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LEdBQUdFO0FBRXRDLElBQUksQ0FBQyxPQUFPRixRQUFRNkMsT0FBTyxLQUFLLGNBQWUsT0FBTzdDLFFBQVE2QyxPQUFPLEtBQUssWUFBWTdDLFFBQVE2QyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU83QyxRQUFRNkMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2hELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUTZDLE9BQU8sRUFBRSxjQUFjO1FBQUU1QyxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2lELE1BQU0sQ0FBQy9DLFFBQVE2QyxPQUFPLEVBQUU3QztJQUMvQmdELE9BQU9oRCxPQUFPLEdBQUdBLFFBQVE2QyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy91c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzPzQ1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyA9IHZvaWQgMDtcbnZhciBfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB2YWwuZW50cmllcygpKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5fYnVuZGxlckNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yKGNvbnN0IGtleSBpbiB2YWwpe1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWxba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdmbigpJztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWUuJCR0eXBlb2YudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5oYXNPd25Qcm9wZXJ0eSgnX2J1bmRsZXJDb25maWcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9ICdGbGlnaHREYXRhJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tleV0gPSBub3JtYWxpemVSb3V0ZXJTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICByZXR1cm4gdmFsLm1hcChub3JtYWxpemVSb3V0ZXJTdGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZXZUb29sUmVkdWNlcihmbiwgcmVmKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKT0+e1xuICAgICAgICBjb25zdCByZXMgPSBmbihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZWYuY3VycmVudC5zZW5kKGFjdGlvbiwgbm9ybWFsaXplUm91dGVyU3RhdGUocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcChmbiwgaW5pdGlhbFN0YXRlKSB7XG4gICAgY29uc3QgW3N0YXRlLCBkaXNwYXRjaF0gPSAoMCwgX3JlYWN0KS51c2VSZWR1Y2VyKGZuLCBpbml0aWFsU3RhdGUpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgKCk9Pnt9XG4gICAgXTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwoZm4sIGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IGRldnRvb2xzQ29ubmVjdGlvblJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IGVuYWJsZWRSZWYgPSAoMCwgX3JlYWN0KS51c2VSZWYoKTtcbiAgICAoMCwgX3JlYWN0KS51c2VFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50IHx8IGVuYWJsZWRSZWYuY3VycmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlZFJlZi5jdXJyZW50ID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZW5hYmxlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQgPSB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXy5jb25uZWN0KHtcbiAgICAgICAgICAgIGluc3RhbmNlSWQ6IDgwMDAsXG4gICAgICAgICAgICBuYW1lOiAnbmV4dC1yb3V0ZXInXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGRldnRvb2xzQ29ubmVjdGlvblJlZi5jdXJyZW50LmluaXQobm9ybWFsaXplUm91dGVyU3RhdGUoaW5pdGlhbFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGluaXRpYWxTdGF0ZVxuICAgIF0pO1xuICAgIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gKDAsIF9yZWFjdCkudXNlUmVkdWNlcihkZXZUb29sUmVkdWNlcigvKiBsb2dSZWR1Y2VyKCAqLyBmbiAvKikqLyAsIGRldnRvb2xzQ29ubmVjdGlvblJlZiksIGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3Qgc3luYyA9ICgwLCBfcmVhY3QpLnVzZUNhbGxiYWNrKCgpPT57XG4gICAgICAgIGlmIChkZXZ0b29sc0Nvbm5lY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgZGV2dG9vbHNDb25uZWN0aW9uUmVmLmN1cnJlbnQuc2VuZCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1JFTkRFUl9TWU5DJ1xuICAgICAgICAgICAgfSwgbm9ybWFsaXplUm91dGVyU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgc3RhdGVcbiAgICBdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgIHN5bmNcbiAgICBdO1xufVxuY29uc3QgdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VSZWR1Y2VyV2l0aFJlZHV4RGV2dG9vbHNJbXBsIDogdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcDtcbmV4cG9ydHMudXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzID0gdXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtcmVkdWNlci13aXRoLWRldnRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29scyIsIl9yZWFjdCIsInJlcXVpcmUiLCJub3JtYWxpemVSb3V0ZXJTdGF0ZSIsInZhbCIsIk1hcCIsIm9iaiIsImtleSIsImVudHJpZXMiLCIkJHR5cGVvZiIsInRvU3RyaW5nIiwiX2J1bmRsZXJDb25maWciLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImRldlRvb2xSZWR1Y2VyIiwiZm4iLCJyZWYiLCJzdGF0ZSIsImFjdGlvbiIsInJlcyIsImN1cnJlbnQiLCJzZW5kIiwidXNlUmVkdWNlcldpdGhSZWR1eERldnRvb2xzTm9vcCIsImluaXRpYWxTdGF0ZSIsImRpc3BhdGNoIiwidXNlUmVkdWNlciIsInVzZVJlZHVjZXJXaXRoUmVkdXhEZXZ0b29sc0ltcGwiLCJkZXZ0b29sc0Nvbm5lY3Rpb25SZWYiLCJ1c2VSZWYiLCJlbmFibGVkUmVmIiwidXNlRWZmZWN0IiwidW5kZWZpbmVkIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsImNvbm5lY3QiLCJpbnN0YW5jZUlkIiwibmFtZSIsImluaXQiLCJzeW5jIiwidXNlQ2FsbGJhY2siLCJ0eXBlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/components/use-reducer-with-devtools.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathTrailingSlash = void 0;\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith(\"/\") || undefined) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    if (false) {}\n    return \"\".concat((0, _removeTrailingSlash).removeTrailingSlash(pathname)).concat(query).concat(hash);\n};\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtDQUFrQyxHQUFHLEtBQUs7QUFDMUMsSUFBSUcsdUJBQXVCQyxtQkFBT0EsQ0FBQyxnSkFBa0Q7QUFDckYsSUFBSUMsYUFBYUQsbUJBQU9BLENBQUMsMEhBQXVDO0FBQ2hFLE1BQU1GLDZCQUE2QixDQUFDSSxPQUFPO0lBQ3ZDLElBQUksQ0FBQ0EsS0FBS0MsVUFBVSxDQUFDLFFBQVFDLFNBQXdDLEVBQUU7UUFDbkUsT0FBT0Y7SUFDWCxDQUFDO0lBQ0QsTUFBTSxFQUFFSyxTQUFRLEVBQUdDLE1BQUssRUFBR0MsS0FBSSxFQUFHLEdBQUcsQ0FBQyxHQUFHUixVQUFVLEVBQUVTLFNBQVMsQ0FBQ1I7SUFDL0QsSUFBSUUsS0FBaUMsRUFBRSxFQVF0QztJQUNELE9BQU8sR0FBNkRJLE9BQTFELENBQUMsR0FBR1Qsb0JBQW9CLEVBQUVjLG1CQUFtQixDQUFDTixXQUFvQkUsT0FBUkQsT0FBYSxPQUFMQztBQUNoRjtBQUNBYixrQ0FBa0MsR0FBR0U7QUFFckMsSUFBSSxDQUFDLE9BQU9GLFFBQVFtQixPQUFPLEtBQUssY0FBZSxPQUFPbkIsUUFBUW1CLE9BQU8sS0FBSyxZQUFZbkIsUUFBUW1CLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT25CLFFBQVFtQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRbUIsT0FBTyxFQUFFLGNBQWM7UUFBRWxCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPdUIsTUFBTSxDQUFDckIsUUFBUW1CLE9BQU8sRUFBRW5CO0lBQy9Cc0IsT0FBT3RCLE9BQU8sR0FBR0EsUUFBUW1CLE9BQU87QUFDbEMsQ0FBQyxDQUVELG9EQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanM/NGMyZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG52YXIgX3JlbW92ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aFwiKTtcbmNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gKHBhdGgpPT57XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfTUFOVUFMX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgLCBoYXNoICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHsoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cGF0aG5hbWV9LyR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAkeygwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSl9JHtxdWVyeX0ke2hhc2h9YDtcbn07XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2g7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSIsIl9wYXJzZVBhdGgiLCJwYXRoIiwic3RhcnRzV2l0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfTUFOVUFMX1RSQUlMSU5HX1NMQVNIIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJ0ZXN0IiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImVuZHNXaXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/client/normalize-trailing-slash.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addPathPrefix = addPathPrefix;\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"(app-client)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith(\"/\") || !prefix) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    return \"\".concat(prefix).concat(pathname).concat(query).concat(hash);\n} //# sourceMappingURL=add-path-prefix.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9hZGQtcGF0aC1wcmVmaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUdFO0FBQ3hCLElBQUlDLGFBQWFDLG1CQUFPQSxDQUFDLGlHQUFjO0FBQ3ZDLFNBQVNGLGNBQWNHLElBQUksRUFBRUMsTUFBTSxFQUFFO0lBQ2pDLElBQUksQ0FBQ0QsS0FBS0UsVUFBVSxDQUFDLFFBQVEsQ0FBQ0QsUUFBUTtRQUNsQyxPQUFPRDtJQUNYLENBQUM7SUFDRCxNQUFNLEVBQUVHLFNBQVEsRUFBR0MsTUFBSyxFQUFHQyxLQUFJLEVBQUcsR0FBRyxDQUFDLEdBQUdQLFVBQVUsRUFBRVEsU0FBUyxDQUFDTjtJQUMvRCxPQUFPLEdBQVlHLE9BQVRGLFFBQW9CRyxPQUFYRCxVQUFtQkUsT0FBUkQsT0FBYSxPQUFMQztBQUMxQyxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeC5qcz9jMTI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRQYXRoUHJlZml4ID0gYWRkUGF0aFByZWZpeDtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4vcGFyc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIGFkZFBhdGhQcmVmaXgocGF0aCwgcHJlZml4KSB7XG4gICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoJy8nKSB8fCAhcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgLCBoYXNoICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICByZXR1cm4gYCR7cHJlZml4fSR7cGF0aG5hbWV9JHtxdWVyeX0ke2hhc2h9YDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLXBhdGgtcHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZFBhdGhQcmVmaXgiLCJfcGFyc2VQYXRoIiwicmVxdWlyZSIsInBhdGgiLCJwcmVmaXgiLCJzdGFydHNXaXRoIiwicGF0aG5hbWUiLCJxdWVyeSIsImhhc2giLCJwYXJzZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js ***!
  \********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleSmoothScroll = handleSmoothScroll;\nfunction handleSmoothScroll(fn) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    if (!options.dontForceLayout) {\n        // In Chrome-based browsers we need to force reflow before calling `scrollTo`.\n        // Otherwise it will not pickup the change in scrollBehavior\n        // More info here: https://github.com/vercel/next.js/issues/40719#issuecomment-1336248042\n        htmlElement.getClientRects();\n    }\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n} //# sourceMappingURL=handle-smooth-scroll.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0IsU0FBU0EsbUJBQW1CQyxFQUFFLEVBQWdCO1FBQWRDLFVBQUFBLGlFQUFVLENBQUMsQ0FBQztJQUN4QyxNQUFNQyxjQUFjQyxTQUFTQyxlQUFlO0lBQzVDLE1BQU1DLFdBQVdILFlBQVlJLEtBQUssQ0FBQ0MsY0FBYztJQUNqREwsWUFBWUksS0FBSyxDQUFDQyxjQUFjLEdBQUc7SUFDbkMsSUFBSSxDQUFDTixRQUFRTyxlQUFlLEVBQUU7UUFDMUIsOEVBQThFO1FBQzlFLDREQUE0RDtRQUM1RCx5RkFBeUY7UUFDekZOLFlBQVlPLGNBQWM7SUFDOUIsQ0FBQztJQUNEVDtJQUNBRSxZQUFZSSxLQUFLLENBQUNDLGNBQWMsR0FBR0Y7QUFDdkMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9oYW5kbGUtc21vb3RoLXNjcm9sbC5qcz82NTYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYW5kbGVTbW9vdGhTY3JvbGwgPSBoYW5kbGVTbW9vdGhTY3JvbGw7XG5mdW5jdGlvbiBoYW5kbGVTbW9vdGhTY3JvbGwoZm4sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3I7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0byc7XG4gICAgaWYgKCFvcHRpb25zLmRvbnRGb3JjZUxheW91dCkge1xuICAgICAgICAvLyBJbiBDaHJvbWUtYmFzZWQgYnJvd3NlcnMgd2UgbmVlZCB0byBmb3JjZSByZWZsb3cgYmVmb3JlIGNhbGxpbmcgYHNjcm9sbFRvYC5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdpbGwgbm90IHBpY2t1cCB0aGUgY2hhbmdlIGluIHNjcm9sbEJlaGF2aW9yXG4gICAgICAgIC8vIE1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzQwNzE5I2lzc3VlY29tbWVudC0xMzM2MjQ4MDQyXG4gICAgICAgIGh0bWxFbGVtZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgfVxuICAgIGZuKCk7XG4gICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSBleGlzdGluZztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFuZGxlLXNtb290aC1zY3JvbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwiZm4iLCJvcHRpb25zIiwiaHRtbEVsZW1lbnQiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsImRvbnRGb3JjZUxheW91dCIsImdldENsaWVudFJlY3RzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-bot.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isBot = isBot;\nfunction isBot(userAgent) {\n    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);\n} //# sourceMappingURL=is-bot.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsYUFBYSxHQUFHRTtBQUNoQixTQUFTQSxNQUFNQyxTQUFTLEVBQUU7SUFDdEIsT0FBTyxvVkFBb1ZDLElBQUksQ0FBQ0Q7QUFDcFcsRUFFQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1ib3QuanM/MDcxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNCb3QgPSBpc0JvdDtcbmZ1bmN0aW9uIGlzQm90KHVzZXJBZ2VudCkge1xuICAgIHJldHVybiAvR29vZ2xlYm90fE1lZGlhcGFydG5lcnMtR29vZ2xlfEFkc0JvdC1Hb29nbGV8Z29vZ2xld2VibGlnaHR8U3RvcmVib3QtR29vZ2xlfEdvb2dsZS1QYWdlUmVuZGVyZXJ8QmluZ2JvdHxCaW5nUHJldmlld3xTbHVycHxEdWNrRHVja0JvdHxiYWlkdXNwaWRlcnx5YW5kZXh8c29nb3V8TGlua2VkSW5Cb3R8Yml0bHlib3R8dHVtYmxyfHZrU2hhcmV8cXVvcmEgbGluayBwcmV2aWV3fGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmFjZWJvb2tjYXRhbG9nfFR3aXR0ZXJib3R8YXBwbGVib3R8cmVkZGl0Ym90fFNsYWNrYm90fERpc2NvcmRib3R8V2hhdHNBcHB8U2t5cGVVcmlQcmV2aWV3fGlhX2FyY2hpdmVyL2kudGVzdCh1c2VyQWdlbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1ib3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiaXNCb3QiLCJ1c2VyQWdlbnQiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/is-bot.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-path.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parsePath = parsePath;\nfunction parsePath(path) {\n    const hashIndex = path.indexOf(\"#\");\n    const queryIndex = path.indexOf(\"?\");\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : \"\",\n            hash: hashIndex > -1 ? path.slice(hashIndex) : \"\"\n        };\n    }\n    return {\n        pathname: path,\n        query: \"\",\n        hash: \"\"\n    };\n} //# sourceMappingURL=parse-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHRTtBQUNwQixTQUFTQSxVQUFVQyxJQUFJLEVBQUU7SUFDckIsTUFBTUMsWUFBWUQsS0FBS0UsT0FBTyxDQUFDO0lBQy9CLE1BQU1DLGFBQWFILEtBQUtFLE9BQU8sQ0FBQztJQUNoQyxNQUFNRSxXQUFXRCxhQUFhLENBQUMsS0FBTUYsQ0FBQUEsWUFBWSxLQUFLRSxhQUFhRixTQUFRO0lBQzNFLElBQUlHLFlBQVlILFlBQVksQ0FBQyxHQUFHO1FBQzVCLE9BQU87WUFDSEksVUFBVUwsS0FBS00sU0FBUyxDQUFDLEdBQUdGLFdBQVdELGFBQWFGLFNBQVM7WUFDN0RNLE9BQU9ILFdBQVdKLEtBQUtNLFNBQVMsQ0FBQ0gsWUFBWUYsWUFBWSxDQUFDLElBQUlBLFlBQVlPLFNBQVMsSUFBSSxFQUFFO1lBQ3pGQyxNQUFNUixZQUFZLENBQUMsSUFBSUQsS0FBS1UsS0FBSyxDQUFDVCxhQUFhLEVBQUU7UUFDckQ7SUFDSixDQUFDO0lBQ0QsT0FBTztRQUNISSxVQUFVTDtRQUNWTyxPQUFPO1FBQ1BFLE1BQU07SUFDVjtBQUNKLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aC5qcz9lNTJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICAgIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgICBjb25zdCBoYXNRdWVyeSA9IHF1ZXJ5SW5kZXggPiAtMSAmJiAoaGFzaEluZGV4IDwgMCB8fCBxdWVyeUluZGV4IDwgaGFzaEluZGV4KTtcbiAgICBpZiAoaGFzUXVlcnkgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBwYXRoLnN1YnN0cmluZygwLCBoYXNRdWVyeSA/IHF1ZXJ5SW5kZXggOiBoYXNoSW5kZXgpLFxuICAgICAgICAgICAgcXVlcnk6IGhhc1F1ZXJ5ID8gcGF0aC5zdWJzdHJpbmcocXVlcnlJbmRleCwgaGFzaEluZGV4ID4gLTEgPyBoYXNoSW5kZXggOiB1bmRlZmluZWQpIDogJycsXG4gICAgICAgICAgICBoYXNoOiBoYXNoSW5kZXggPiAtMSA/IHBhdGguc2xpY2UoaGFzaEluZGV4KSA6ICcnXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICBxdWVyeTogJycsXG4gICAgICAgIGhhc2g6ICcnXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJwYXJzZVBhdGgiLCJwYXRoIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInF1ZXJ5SW5kZXgiLCJoYXNRdWVyeSIsInBhdGhuYW1lIiwic3Vic3RyaW5nIiwicXVlcnkiLCJ1bmRlZmluZWQiLCJoYXNoIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/parse-path.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js ***!
  \*********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeTrailingSlash = removeTrailingSlash;\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, \"\") || \"/\";\n} //# sourceMappingURL=remove-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUdFO0FBQzlCLFNBQVNBLG9CQUFvQkMsS0FBSyxFQUFFO0lBQ2hDLE9BQU9BLE1BQU1DLE9BQU8sQ0FBQyxPQUFPLE9BQU87QUFDdkMsRUFFQSxpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2guanM/ZWMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlbW92ZVRyYWlsaW5nU2xhc2g7XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHJvdXRlKSB7XG4gICAgcmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtdHJhaWxpbmctc2xhc2guanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJvdXRlIiwicmVwbGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Fapp-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Flayout-router.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Frender-from-template-context.js&modules=%2FUsers%2Frahul%2FDocuments%2FNext-Issue%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fcomponents%2Ferror-boundary.js&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);